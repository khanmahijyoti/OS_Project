
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

00100000 <pmmap_init.cold>:
  100000:	80 7c 24 2f 00       	cmpb   $0x0,0x2f(%esp)
  100005:	8b 7c 24 20          	mov    0x20(%esp),%edi
  100009:	74 06                	je     100011 <pmmap_init.cold+0x11>
  10000b:	89 bd 84 96 08 00    	mov    %edi,0x89684(%ebp)
    int sublist_nr;

    /*
     * Step 1: Merge overlapped entries in pmmap_list.
     */
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100011:	80 7c 24 14 00       	cmpb   $0x0,0x14(%esp)
  100016:	74 0a                	je     100022 <pmmap_init.cold+0x22>
  100018:	c7 85 88 96 08 00 80 	movl   $0x80,0x89688(%ebp)
  10001f:	00 00 00 
        KERN_PANIC("More than 128 E820 entries.\n");
  100022:	50                   	push   %eax
  100023:	8d 85 31 61 ff ff    	lea    -0x9ecf(%ebp),%eax
  100029:	89 eb                	mov    %ebp,%ebx
  10002b:	50                   	push   %eax
  10002c:	8d 85 4e 61 ff ff    	lea    -0x9eb2(%ebp),%eax
  100032:	6a 3c                	push   $0x3c
  100034:	50                   	push   %eax
  100035:	e8 b6 47 00 00       	call   1047f0 <debug_panic>
    free_slot->start = start;
  10003a:	31 d2                	xor    %edx,%edx
  10003c:	89 15 00 00 00 00    	mov    %edx,0x0
  100042:	0f 0b                	ud2
  100044:	66 90                	xchg   %ax,%ax
  100046:	66 90                	xchg   %ax,%ax
  100048:	66 90                	xchg   %ax,%ax
  10004a:	66 90                	xchg   %ax,%ax
  10004c:	66 90                	xchg   %ax,%ax
  10004e:	66 90                	xchg   %ax,%ax

00100050 <video_init>:
    unsigned pos;

    /* Get a pointer to the memory-mapped text display buffer. */
    cp = (uint16_t *) CGA_BUF;
    was = *cp;
    *cp = (uint16_t) 0xA55A;
  100050:	b9 5a a5 ff ff       	mov    $0xffffa55a,%ecx
{
  100055:	57                   	push   %edi
  100056:	56                   	push   %esi
  100057:	53                   	push   %ebx
    was = *cp;
  100058:	0f b7 15 00 80 0b 00 	movzwl 0xb8000,%edx
    *cp = (uint16_t) 0xA55A;
  10005f:	e8 3e 03 00 00       	call   1003a2 <__x86.get_pc_thunk.bx>
  100064:	81 c3 90 6f 01 00    	add    $0x16f90,%ebx
  10006a:	66 89 0d 00 80 0b 00 	mov    %cx,0xb8000
    if (*cp != 0xA55A) {
  100071:	0f b7 05 00 80 0b 00 	movzwl 0xb8000,%eax
  100078:	66 3d 5a a5          	cmp    $0xa55a,%ax
  10007c:	0f 84 96 00 00 00    	je     100118 <video_init+0xc8>
        cp = (uint16_t *) MONO_BUF;
        addr_6845 = MONO_BASE;
        dprintf("addr_6845:%x\n", addr_6845);
  100082:	83 ec 08             	sub    $0x8,%esp
  100085:	8d 83 0c 60 ff ff    	lea    -0x9ff4(%ebx),%eax
        cp = (uint16_t *) MONO_BUF;
  10008b:	bf 00 00 0b 00       	mov    $0xb0000,%edi
        addr_6845 = MONO_BASE;
  100090:	c7 83 18 90 08 00 b4 	movl   $0x3b4,0x89018(%ebx)
  100097:	03 00 00 
        dprintf("addr_6845:%x\n", addr_6845);
  10009a:	68 b4 03 00 00       	push   $0x3b4
  10009f:	50                   	push   %eax
  1000a0:	e8 bb 49 00 00       	call   104a60 <dprintf>
  1000a5:	83 c4 10             	add    $0x10,%esp
        addr_6845 = CGA_BASE;
        dprintf("addr_6845:%x\n", addr_6845);
    }

    /* Extract cursor location */
    outb(addr_6845, 14);
  1000a8:	83 ec 08             	sub    $0x8,%esp
  1000ab:	6a 0e                	push   $0xe
  1000ad:	ff b3 18 90 08 00    	push   0x89018(%ebx)
  1000b3:	e8 68 55 00 00       	call   105620 <outb>
    pos = inb(addr_6845 + 1) << 8;
  1000b8:	8b 83 18 90 08 00    	mov    0x89018(%ebx),%eax
  1000be:	83 c0 01             	add    $0x1,%eax
  1000c1:	89 04 24             	mov    %eax,(%esp)
  1000c4:	e8 27 55 00 00       	call   1055f0 <inb>
  1000c9:	0f b6 f0             	movzbl %al,%esi
    outb(addr_6845, 15);
  1000cc:	58                   	pop    %eax
  1000cd:	5a                   	pop    %edx
  1000ce:	6a 0f                	push   $0xf
  1000d0:	ff b3 18 90 08 00    	push   0x89018(%ebx)
    pos = inb(addr_6845 + 1) << 8;
  1000d6:	c1 e6 08             	shl    $0x8,%esi
    outb(addr_6845, 15);
  1000d9:	e8 42 55 00 00       	call   105620 <outb>
    pos |= inb(addr_6845 + 1);
  1000de:	8b 83 18 90 08 00    	mov    0x89018(%ebx),%eax
  1000e4:	83 c0 01             	add    $0x1,%eax
  1000e7:	89 04 24             	mov    %eax,(%esp)
  1000ea:	e8 01 55 00 00       	call   1055f0 <inb>

    terminal.crt_buf = (uint16_t *) cp;
    terminal.crt_pos = pos;
    terminal.active_console = 0;
}
  1000ef:	83 c4 10             	add    $0x10,%esp
    terminal.crt_buf = (uint16_t *) cp;
  1000f2:	89 bb 0c 90 08 00    	mov    %edi,0x8900c(%ebx)
    terminal.active_console = 0;
  1000f8:	c7 83 14 90 08 00 00 	movl   $0x0,0x89014(%ebx)
  1000ff:	00 00 00 
    pos |= inb(addr_6845 + 1);
  100102:	0f b6 c0             	movzbl %al,%eax
  100105:	09 f0                	or     %esi,%eax
    terminal.crt_pos = pos;
  100107:	66 89 83 10 90 08 00 	mov    %ax,0x89010(%ebx)
}
  10010e:	5b                   	pop    %ebx
  10010f:	5e                   	pop    %esi
  100110:	5f                   	pop    %edi
  100111:	c3                   	ret
  100112:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        dprintf("addr_6845:%x\n", addr_6845);
  100118:	83 ec 08             	sub    $0x8,%esp
  10011b:	8d 83 0c 60 ff ff    	lea    -0x9ff4(%ebx),%eax
    cp = (uint16_t *) CGA_BUF;
  100121:	bf 00 80 0b 00       	mov    $0xb8000,%edi
        *cp = was;
  100126:	66 89 15 00 80 0b 00 	mov    %dx,0xb8000
        dprintf("addr_6845:%x\n", addr_6845);
  10012d:	68 d4 03 00 00       	push   $0x3d4
  100132:	50                   	push   %eax
        addr_6845 = CGA_BASE;
  100133:	c7 83 18 90 08 00 d4 	movl   $0x3d4,0x89018(%ebx)
  10013a:	03 00 00 
        dprintf("addr_6845:%x\n", addr_6845);
  10013d:	e8 1e 49 00 00       	call   104a60 <dprintf>
  100142:	83 c4 10             	add    $0x10,%esp
  100145:	e9 5e ff ff ff       	jmp    1000a8 <video_init+0x58>
  10014a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00100150 <video_putc>:

void video_putc(int c)
{
  100150:	56                   	push   %esi
  100151:	53                   	push   %ebx
  100152:	e8 4b 02 00 00       	call   1003a2 <__x86.get_pc_thunk.bx>
  100157:	81 c3 9d 6e 01 00    	add    $0x16e9d,%ebx
  10015d:	83 ec 04             	sub    $0x4,%esp
  100160:	8b 54 24 10          	mov    0x10(%esp),%edx
    // if no attribute given, then use black on white
    if (!(c & ~0xFF))
        c |= 0x0700;
  100164:	89 d0                	mov    %edx,%eax
  100166:	80 cc 07             	or     $0x7,%ah
  100169:	81 fa 00 01 00 00    	cmp    $0x100,%edx
  10016f:	0f 42 d0             	cmovb  %eax,%edx

    switch (c & 0xff) {
  100172:	0f b6 c2             	movzbl %dl,%eax
  100175:	83 f8 0a             	cmp    $0xa,%eax
  100178:	0f 84 9c 01 00 00    	je     10031a <video_putc+0x1ca>
  10017e:	0f 8f 4c 01 00 00    	jg     1002d0 <video_putc+0x180>
  100184:	83 f8 08             	cmp    $0x8,%eax
  100187:	0f 84 ae 00 00 00    	je     10023b <video_putc+0xeb>
  10018d:	83 f8 09             	cmp    $0x9,%eax
  100190:	0f 85 64 01 00 00    	jne    1002fa <video_putc+0x1aa>
        /* fallthru */
    case '\r':
        terminal.crt_pos -= (terminal.crt_pos % CRT_COLS);
        break;
    case '\t':
        video_putc(' ');
  100196:	83 ec 0c             	sub    $0xc,%esp
  100199:	6a 20                	push   $0x20
  10019b:	e8 b0 ff ff ff       	call   100150 <video_putc>
        video_putc(' ');
  1001a0:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1001a7:	e8 a4 ff ff ff       	call   100150 <video_putc>
        video_putc(' ');
  1001ac:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1001b3:	e8 98 ff ff ff       	call   100150 <video_putc>
        video_putc(' ');
  1001b8:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1001bf:	e8 8c ff ff ff       	call   100150 <video_putc>
        video_putc(' ');
  1001c4:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1001cb:	e8 80 ff ff ff       	call   100150 <video_putc>
    default:
        terminal.crt_buf[terminal.crt_pos++] = c;  /* write the character */
        break;
    }

    if (terminal.crt_pos >= CRT_SIZE) {
  1001d0:	0f b7 83 10 90 08 00 	movzwl 0x89010(%ebx),%eax
        break;
  1001d7:	83 c4 10             	add    $0x10,%esp
    if (terminal.crt_pos >= CRT_SIZE) {
  1001da:	66 3d cf 07          	cmp    $0x7cf,%ax
  1001de:	0f 87 8c 00 00 00    	ja     100270 <video_putc+0x120>
            terminal.crt_buf[i] = 0x0700 | ' ';
        terminal.crt_pos -= CRT_COLS;
    }

    /* move that little blinky thing */
    outb(addr_6845, 14);
  1001e4:	83 ec 08             	sub    $0x8,%esp
  1001e7:	6a 0e                	push   $0xe
  1001e9:	ff b3 18 90 08 00    	push   0x89018(%ebx)
  1001ef:	e8 2c 54 00 00       	call   105620 <outb>
    outb(addr_6845 + 1, terminal.crt_pos >> 8);
  1001f4:	58                   	pop    %eax
  1001f5:	0f b6 83 11 90 08 00 	movzbl 0x89011(%ebx),%eax
  1001fc:	5a                   	pop    %edx
  1001fd:	50                   	push   %eax
  1001fe:	8b 83 18 90 08 00    	mov    0x89018(%ebx),%eax
  100204:	83 c0 01             	add    $0x1,%eax
  100207:	50                   	push   %eax
  100208:	e8 13 54 00 00       	call   105620 <outb>
    outb(addr_6845, 15);
  10020d:	59                   	pop    %ecx
  10020e:	5e                   	pop    %esi
  10020f:	6a 0f                	push   $0xf
  100211:	ff b3 18 90 08 00    	push   0x89018(%ebx)
  100217:	e8 04 54 00 00       	call   105620 <outb>
    outb(addr_6845 + 1, terminal.crt_pos);
  10021c:	58                   	pop    %eax
  10021d:	0f b6 83 10 90 08 00 	movzbl 0x89010(%ebx),%eax
  100224:	5a                   	pop    %edx
  100225:	50                   	push   %eax
  100226:	8b 83 18 90 08 00    	mov    0x89018(%ebx),%eax
  10022c:	83 c0 01             	add    $0x1,%eax
  10022f:	50                   	push   %eax
  100230:	e8 eb 53 00 00       	call   105620 <outb>
}
  100235:	83 c4 14             	add    $0x14,%esp
  100238:	5b                   	pop    %ebx
  100239:	5e                   	pop    %esi
  10023a:	c3                   	ret
        if (terminal.crt_pos > 0) {
  10023b:	0f b7 83 10 90 08 00 	movzwl 0x89010(%ebx),%eax
  100242:	66 85 c0             	test   %ax,%ax
  100245:	74 9d                	je     1001e4 <video_putc+0x94>
            terminal.crt_pos--;
  100247:	83 e8 01             	sub    $0x1,%eax
            terminal.crt_buf[terminal.crt_pos] = (c & ~0xff) | ' ';
  10024a:	8b 8b 0c 90 08 00    	mov    0x8900c(%ebx),%ecx
  100250:	30 d2                	xor    %dl,%dl
  100252:	0f b7 f0             	movzwl %ax,%esi
  100255:	83 ca 20             	or     $0x20,%edx
            terminal.crt_pos--;
  100258:	66 89 83 10 90 08 00 	mov    %ax,0x89010(%ebx)
            terminal.crt_buf[terminal.crt_pos] = (c & ~0xff) | ' ';
  10025f:	66 89 14 71          	mov    %dx,(%ecx,%esi,2)
    if (terminal.crt_pos >= CRT_SIZE) {
  100263:	66 3d cf 07          	cmp    $0x7cf,%ax
  100267:	0f 86 77 ff ff ff    	jbe    1001e4 <video_putc+0x94>
  10026d:	8d 76 00             	lea    0x0(%esi),%esi
        memmove(terminal.crt_buf, terminal.crt_buf + CRT_COLS,
  100270:	8b 83 0c 90 08 00    	mov    0x8900c(%ebx),%eax
  100276:	83 ec 04             	sub    $0x4,%esp
  100279:	68 00 0f 00 00       	push   $0xf00
  10027e:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
  100284:	52                   	push   %edx
  100285:	50                   	push   %eax
  100286:	e8 e5 41 00 00       	call   104470 <memmove>
            terminal.crt_buf[i] = 0x0700 | ' ';
  10028b:	8b 93 0c 90 08 00    	mov    0x8900c(%ebx),%edx
  100291:	83 c4 10             	add    $0x10,%esp
  100294:	8d 82 00 0f 00 00    	lea    0xf00(%edx),%eax
  10029a:	81 c2 a0 0f 00 00    	add    $0xfa0,%edx
  1002a0:	b9 20 07 00 00       	mov    $0x720,%ecx
  1002a5:	be 20 07 00 00       	mov    $0x720,%esi
        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  1002aa:	83 c0 04             	add    $0x4,%eax
            terminal.crt_buf[i] = 0x0700 | ' ';
  1002ad:	66 89 48 fc          	mov    %cx,-0x4(%eax)
  1002b1:	66 89 70 fe          	mov    %si,-0x2(%eax)
        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  1002b5:	39 c2                	cmp    %eax,%edx
  1002b7:	75 e7                	jne    1002a0 <video_putc+0x150>
        terminal.crt_pos -= CRT_COLS;
  1002b9:	66 83 ab 10 90 08 00 	subw   $0x50,0x89010(%ebx)
  1002c0:	50 
  1002c1:	e9 1e ff ff ff       	jmp    1001e4 <video_putc+0x94>
  1002c6:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1002cd:	00 
  1002ce:	66 90                	xchg   %ax,%ax
    switch (c & 0xff) {
  1002d0:	83 f8 0d             	cmp    $0xd,%eax
  1002d3:	75 25                	jne    1002fa <video_putc+0x1aa>
        if (terminal.crt_pos > 0) {
  1002d5:	0f b7 83 10 90 08 00 	movzwl 0x89010(%ebx),%eax
        terminal.crt_pos -= (terminal.crt_pos % CRT_COLS);
  1002dc:	0f b7 c0             	movzwl %ax,%eax
  1002df:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  1002e5:	c1 e8 16             	shr    $0x16,%eax
  1002e8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  1002eb:	c1 e0 04             	shl    $0x4,%eax
  1002ee:	66 89 83 10 90 08 00 	mov    %ax,0x89010(%ebx)
        break;
  1002f5:	e9 e0 fe ff ff       	jmp    1001da <video_putc+0x8a>
        terminal.crt_buf[terminal.crt_pos++] = c;  /* write the character */
  1002fa:	0f b7 8b 10 90 08 00 	movzwl 0x89010(%ebx),%ecx
  100301:	8b b3 0c 90 08 00    	mov    0x8900c(%ebx),%esi
  100307:	8d 41 01             	lea    0x1(%ecx),%eax
  10030a:	66 89 14 4e          	mov    %dx,(%esi,%ecx,2)
  10030e:	66 89 83 10 90 08 00 	mov    %ax,0x89010(%ebx)
        break;
  100315:	e9 c0 fe ff ff       	jmp    1001da <video_putc+0x8a>
        terminal.crt_pos += CRT_COLS;
  10031a:	0f b7 83 10 90 08 00 	movzwl 0x89010(%ebx),%eax
  100321:	83 c0 50             	add    $0x50,%eax
  100324:	eb b6                	jmp    1002dc <video_putc+0x18c>
  100326:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10032d:	00 
  10032e:	66 90                	xchg   %ax,%ax

00100330 <video_set_cursor>:

void video_set_cursor(int x, int y)
{
    terminal.crt_pos = x * CRT_COLS + y;
  100330:	e8 69 00 00 00       	call   10039e <__x86.get_pc_thunk.dx>
  100335:	81 c2 bf 6c 01 00    	add    $0x16cbf,%edx
{
  10033b:	8b 44 24 04          	mov    0x4(%esp),%eax
    terminal.crt_pos = x * CRT_COLS + y;
  10033f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  100342:	c1 e0 04             	shl    $0x4,%eax
  100345:	66 03 44 24 08       	add    0x8(%esp),%ax
  10034a:	66 89 82 10 90 08 00 	mov    %ax,0x89010(%edx)
}
  100351:	c3                   	ret
  100352:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  100359:	00 
  10035a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00100360 <video_clear_screen>:

void video_clear_screen()
{
    int i;
    for (i = 0; i < CRT_SIZE; i++) {
  100360:	e8 35 00 00 00       	call   10039a <__x86.get_pc_thunk.ax>
  100365:	05 8f 6c 01 00       	add    $0x16c8f,%eax
  10036a:	8b 80 0c 90 08 00    	mov    0x8900c(%eax),%eax
  100370:	8d 90 a0 0f 00 00    	lea    0xfa0(%eax),%edx
  100376:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10037d:	00 
  10037e:	66 90                	xchg   %ax,%ax
        terminal.crt_buf[i] = ' ';
  100380:	b9 20 00 00 00       	mov    $0x20,%ecx
    for (i = 0; i < CRT_SIZE; i++) {
  100385:	83 c0 04             	add    $0x4,%eax
        terminal.crt_buf[i] = ' ';
  100388:	66 89 48 fc          	mov    %cx,-0x4(%eax)
  10038c:	b9 20 00 00 00       	mov    $0x20,%ecx
  100391:	66 89 48 fe          	mov    %cx,-0x2(%eax)
    for (i = 0; i < CRT_SIZE; i++) {
  100395:	39 d0                	cmp    %edx,%eax
  100397:	75 e7                	jne    100380 <video_clear_screen+0x20>
    }
}
  100399:	c3                   	ret

0010039a <__x86.get_pc_thunk.ax>:
  10039a:	8b 04 24             	mov    (%esp),%eax
  10039d:	c3                   	ret

0010039e <__x86.get_pc_thunk.dx>:
  10039e:	8b 14 24             	mov    (%esp),%edx
  1003a1:	c3                   	ret

001003a2 <__x86.get_pc_thunk.bx>:
  1003a2:	8b 1c 24             	mov    (%esp),%ebx
  1003a5:	c3                   	ret
  1003a6:	66 90                	xchg   %ax,%ax
  1003a8:	66 90                	xchg   %ax,%ax
  1003aa:	66 90                	xchg   %ax,%ax
  1003ac:	66 90                	xchg   %ax,%ax
  1003ae:	66 90                	xchg   %ax,%ax

001003b0 <cons_init>:
    char buf[CONSOLE_BUFFER_SIZE];
    uint32_t rpos, wpos;
} cons;

void cons_init()
{
  1003b0:	53                   	push   %ebx
  1003b1:	e8 ec ff ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1003b6:	81 c3 3e 6c 01 00    	add    $0x16c3e,%ebx
  1003bc:	83 ec 0c             	sub    $0xc,%esp
    memset(&cons, 0x0, sizeof(cons));
  1003bf:	68 08 02 00 00       	push   $0x208
  1003c4:	6a 00                	push   $0x0
  1003c6:	8d 83 2c 90 08 00    	lea    0x8902c(%ebx),%eax
  1003cc:	50                   	push   %eax
  1003cd:	e8 5e 40 00 00       	call   104430 <memset>
    serial_init();
  1003d2:	e8 19 04 00 00       	call   1007f0 <serial_init>
    video_init();
  1003d7:	e8 74 fc ff ff       	call   100050 <video_init>
    spinlock_init(&cons_lk);
  1003dc:	8d 83 34 92 08 00    	lea    0x89234(%ebx),%eax
  1003e2:	89 04 24             	mov    %eax,(%esp)
  1003e5:	e8 d6 5a 00 00       	call   105ec0 <spinlock_init>
}
  1003ea:	83 c4 18             	add    $0x18,%esp
  1003ed:	5b                   	pop    %ebx
  1003ee:	c3                   	ret
  1003ef:	90                   	nop

001003f0 <cons_intr>:

void cons_intr(int (*proc)(void))
{
  1003f0:	55                   	push   %ebp
  1003f1:	57                   	push   %edi
  1003f2:	56                   	push   %esi

    spinlock_acquire(&cons_lk);
    while ((c = (*proc)()) != -1) {
        if (c == 0)
            continue;
        cons.buf[cons.wpos++] = c;
  1003f3:	8d 35 2c 90 08 00    	lea    0x8902c,%esi
{
  1003f9:	53                   	push   %ebx
  1003fa:	e8 a3 ff ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1003ff:	81 c3 f5 6b 01 00    	add    $0x16bf5,%ebx
  100405:	83 ec 28             	sub    $0x28,%esp
  100408:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    spinlock_acquire(&cons_lk);
  10040c:	8d 83 34 92 08 00    	lea    0x89234(%ebx),%eax
        cons.buf[cons.wpos++] = c;
  100412:	8d 2c 33             	lea    (%ebx,%esi,1),%ebp
    spinlock_acquire(&cons_lk);
  100415:	89 44 24 18          	mov    %eax,0x18(%esp)
  100419:	50                   	push   %eax
  10041a:	e8 31 5b 00 00       	call   105f50 <spinlock_acquire>
    while ((c = (*proc)()) != -1) {
  10041f:	83 c4 10             	add    $0x10,%esp
  100422:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  100428:	ff d7                	call   *%edi
  10042a:	83 f8 ff             	cmp    $0xffffffff,%eax
  10042d:	74 33                	je     100462 <cons_intr+0x72>
        if (c == 0)
  10042f:	85 c0                	test   %eax,%eax
  100431:	74 f5                	je     100428 <cons_intr+0x38>
        cons.buf[cons.wpos++] = c;
  100433:	8b 8c 33 04 02 00 00 	mov    0x204(%ebx,%esi,1),%ecx
  10043a:	8d 51 01             	lea    0x1(%ecx),%edx
  10043d:	88 44 0d 00          	mov    %al,0x0(%ebp,%ecx,1)
  100441:	89 94 33 04 02 00 00 	mov    %edx,0x204(%ebx,%esi,1)
        if (cons.wpos == CONSOLE_BUFFER_SIZE)
  100448:	81 fa 00 02 00 00    	cmp    $0x200,%edx
  10044e:	75 d8                	jne    100428 <cons_intr+0x38>
            cons.wpos = 0;
  100450:	c7 84 1e 04 02 00 00 	movl   $0x0,0x204(%esi,%ebx,1)
  100457:	00 00 00 00 
    while ((c = (*proc)()) != -1) {
  10045b:	ff d7                	call   *%edi
  10045d:	83 f8 ff             	cmp    $0xffffffff,%eax
  100460:	75 cd                	jne    10042f <cons_intr+0x3f>
    }
    spinlock_release(&cons_lk);
  100462:	83 ec 0c             	sub    $0xc,%esp
  100465:	ff 74 24 18          	push   0x18(%esp)
  100469:	e8 62 5b 00 00       	call   105fd0 <spinlock_release>
}
  10046e:	83 c4 2c             	add    $0x2c,%esp
  100471:	5b                   	pop    %ebx
  100472:	5e                   	pop    %esi
  100473:	5f                   	pop    %edi
  100474:	5d                   	pop    %ebp
  100475:	c3                   	ret
  100476:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10047d:	00 
  10047e:	66 90                	xchg   %ax,%ax

00100480 <cons_getc>:

char cons_getc(void)
{
  100480:	57                   	push   %edi
  100481:	56                   	push   %esi
  100482:	53                   	push   %ebx
  100483:	e8 1a ff ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  100488:	81 c3 6c 6b 01 00    	add    $0x16b6c,%ebx
    int c;

    // poll for any pending input characters,
    // so that this function works even when interrupts are disabled
    // (e.g., when called from the kernel monitor).
    serial_intr();
  10048e:	e8 5d 02 00 00       	call   1006f0 <serial_intr>
    keyboard_intr();
    spinlock_acquire(&cons_lk);
  100493:	8d b3 34 92 08 00    	lea    0x89234(%ebx),%esi
    keyboard_intr();
  100499:	e8 c2 05 00 00       	call   100a60 <keyboard_intr>
    spinlock_acquire(&cons_lk);
  10049e:	83 ec 0c             	sub    $0xc,%esp
  1004a1:	56                   	push   %esi
  1004a2:	e8 a9 5a 00 00       	call   105f50 <spinlock_acquire>

    // grab the next character from the input buffer.
    if (cons.rpos != cons.wpos) {
  1004a7:	8b 83 2c 92 08 00    	mov    0x8922c(%ebx),%eax
  1004ad:	83 c4 10             	add    $0x10,%esp
  1004b0:	3b 83 30 92 08 00    	cmp    0x89230(%ebx),%eax
  1004b6:	74 38                	je     1004f0 <cons_getc+0x70>
        c = cons.buf[cons.rpos++];
  1004b8:	0f b6 bc 03 2c 90 08 	movzbl 0x8902c(%ebx,%eax,1),%edi
  1004bf:	00 
        if (cons.rpos == CONSOLE_BUFFER_SIZE)
            cons.rpos = 0;
  1004c0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
        c = cons.buf[cons.rpos++];
  1004c5:	8d 50 01             	lea    0x1(%eax),%edx
            cons.rpos = 0;
  1004c8:	b8 00 00 00 00       	mov    $0x0,%eax
  1004cd:	0f 44 d0             	cmove  %eax,%edx
        spinlock_release(&cons_lk);
  1004d0:	83 ec 0c             	sub    $0xc,%esp
  1004d3:	56                   	push   %esi
  1004d4:	89 93 2c 92 08 00    	mov    %edx,0x8922c(%ebx)
  1004da:	e8 f1 5a 00 00       	call   105fd0 <spinlock_release>
        return c;
  1004df:	83 c4 10             	add    $0x10,%esp
    }
    spinlock_release(&cons_lk);
    return 0;
}
  1004e2:	89 f8                	mov    %edi,%eax
  1004e4:	5b                   	pop    %ebx
  1004e5:	5e                   	pop    %esi
  1004e6:	5f                   	pop    %edi
  1004e7:	c3                   	ret
  1004e8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1004ef:	00 
    spinlock_release(&cons_lk);
  1004f0:	83 ec 0c             	sub    $0xc,%esp
    return 0;
  1004f3:	31 ff                	xor    %edi,%edi
    spinlock_release(&cons_lk);
  1004f5:	56                   	push   %esi
  1004f6:	e8 d5 5a 00 00       	call   105fd0 <spinlock_release>
    return 0;
  1004fb:	83 c4 10             	add    $0x10,%esp
}
  1004fe:	89 f8                	mov    %edi,%eax
  100500:	5b                   	pop    %ebx
  100501:	5e                   	pop    %esi
  100502:	5f                   	pop    %edi
  100503:	c3                   	ret
  100504:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10050b:	00 
  10050c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00100510 <cons_putc>:

void cons_putc(char c)
{
  100510:	56                   	push   %esi
  100511:	53                   	push   %ebx
  100512:	e8 8b fe ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  100517:	81 c3 dd 6a 01 00    	add    $0x16add,%ebx
  10051d:	83 ec 10             	sub    $0x10,%esp
    serial_putc(c);
  100520:	0f be 74 24 1c       	movsbl 0x1c(%esp),%esi
  100525:	56                   	push   %esi
  100526:	e8 05 02 00 00       	call   100730 <serial_putc>
    video_putc(c);
  10052b:	89 34 24             	mov    %esi,(%esp)
  10052e:	e8 1d fc ff ff       	call   100150 <video_putc>
}
  100533:	83 c4 14             	add    $0x14,%esp
  100536:	5b                   	pop    %ebx
  100537:	5e                   	pop    %esi
  100538:	c3                   	ret
  100539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00100540 <getchar>:

char getchar(void)
{
  100540:	83 ec 0c             	sub    $0xc,%esp
    char c;

    while ((c = cons_getc()) == 0)
  100543:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
  100548:	e8 33 ff ff ff       	call   100480 <cons_getc>
  10054d:	84 c0                	test   %al,%al
  10054f:	74 f7                	je     100548 <getchar+0x8>
        /* do nothing */ ;
    return c;
}
  100551:	83 c4 0c             	add    $0xc,%esp
  100554:	c3                   	ret
  100555:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10055c:	00 
  10055d:	8d 76 00             	lea    0x0(%esi),%esi

00100560 <putchar>:

void putchar(char c)
  100560:	56                   	push   %esi
  100561:	53                   	push   %ebx
  100562:	e8 3b fe ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  100567:	81 c3 8d 6a 01 00    	add    $0x16a8d,%ebx
  10056d:	83 ec 10             	sub    $0x10,%esp
  100570:	0f be 74 24 1c       	movsbl 0x1c(%esp),%esi
  100575:	56                   	push   %esi
  100576:	e8 b5 01 00 00       	call   100730 <serial_putc>
  10057b:	89 34 24             	mov    %esi,(%esp)
  10057e:	e8 cd fb ff ff       	call   100150 <video_putc>
  100583:	83 c4 14             	add    $0x14,%esp
  100586:	5b                   	pop    %ebx
  100587:	5e                   	pop    %esi
  100588:	c3                   	ret
  100589:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00100590 <readline>:
{
    cons_putc(c);
}

char *readline(const char *prompt)
{
  100590:	55                   	push   %ebp
  100591:	57                   	push   %edi
  100592:	56                   	push   %esi
  100593:	53                   	push   %ebx
  100594:	e8 09 fe ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  100599:	81 c3 5b 6a 01 00    	add    $0x16a5b,%ebx
  10059f:	83 ec 1c             	sub    $0x1c,%esp
  1005a2:	8b 44 24 30          	mov    0x30(%esp),%eax
    int i;
    char c;

    if (prompt != NULL)
  1005a6:	85 c0                	test   %eax,%eax
  1005a8:	74 13                	je     1005bd <readline+0x2d>
        dprintf("%s", prompt);
  1005aa:	83 ec 08             	sub    $0x8,%esp
  1005ad:	50                   	push   %eax
  1005ae:	8d 83 1a 60 ff ff    	lea    -0x9fe6(%ebx),%eax
  1005b4:	50                   	push   %eax
  1005b5:	e8 a6 44 00 00       	call   104a60 <dprintf>
  1005ba:	83 c4 10             	add    $0x10,%esp
        } else if ((c == '\b' || c == '\x7f') && i > 0) {
            putchar('\b');
            i--;
        } else if (c >= ' ' && i < BUFLEN - 1) {
            putchar(c);
            linebuf[i++] = c;
  1005bd:	31 f6                	xor    %esi,%esi
  1005bf:	8d bb 4c 92 08 00    	lea    0x8924c(%ebx),%edi
  1005c5:	8d 76 00             	lea    0x0(%esi),%esi
    while ((c = cons_getc()) == 0)
  1005c8:	e8 b3 fe ff ff       	call   100480 <cons_getc>
  1005cd:	84 c0                	test   %al,%al
  1005cf:	74 f7                	je     1005c8 <readline+0x38>
        if (c < 0) {
  1005d1:	0f 88 a2 00 00 00    	js     100679 <readline+0xe9>
        } else if ((c == '\b' || c == '\x7f') && i > 0) {
  1005d7:	3c 08                	cmp    $0x8,%al
  1005d9:	0f 94 c2             	sete   %dl
  1005dc:	3c 7f                	cmp    $0x7f,%al
  1005de:	0f 94 c1             	sete   %cl
  1005e1:	08 ca                	or     %cl,%dl
  1005e3:	74 04                	je     1005e9 <readline+0x59>
  1005e5:	85 f6                	test   %esi,%esi
  1005e7:	7f 6f                	jg     100658 <readline+0xc8>
        } else if (c >= ' ' && i < BUFLEN - 1) {
  1005e9:	3c 1f                	cmp    $0x1f,%al
  1005eb:	7e 33                	jle    100620 <readline+0x90>
  1005ed:	81 fe fe 03 00 00    	cmp    $0x3fe,%esi
  1005f3:	7f 2b                	jg     100620 <readline+0x90>
    serial_putc(c);
  1005f5:	88 44 24 0f          	mov    %al,0xf(%esp)
  1005f9:	0f be e8             	movsbl %al,%ebp
  1005fc:	83 ec 0c             	sub    $0xc,%esp
  1005ff:	55                   	push   %ebp
  100600:	e8 2b 01 00 00       	call   100730 <serial_putc>
    video_putc(c);
  100605:	89 2c 24             	mov    %ebp,(%esp)
  100608:	e8 43 fb ff ff       	call   100150 <video_putc>
            linebuf[i++] = c;
  10060d:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  100612:	83 c4 10             	add    $0x10,%esp
  100615:	88 04 37             	mov    %al,(%edi,%esi,1)
  100618:	83 c6 01             	add    $0x1,%esi
  10061b:	eb ab                	jmp    1005c8 <readline+0x38>
  10061d:	8d 76 00             	lea    0x0(%esi),%esi
        } else if (c == '\n' || c == '\r') {
  100620:	3c 0a                	cmp    $0xa,%al
  100622:	74 04                	je     100628 <readline+0x98>
  100624:	3c 0d                	cmp    $0xd,%al
  100626:	75 a0                	jne    1005c8 <readline+0x38>
    serial_putc(c);
  100628:	83 ec 0c             	sub    $0xc,%esp
  10062b:	6a 0a                	push   $0xa
  10062d:	e8 fe 00 00 00       	call   100730 <serial_putc>
    video_putc(c);
  100632:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  100639:	e8 12 fb ff ff       	call   100150 <video_putc>
            putchar('\n');
            linebuf[i] = 0;
  10063e:	8d 83 4c 92 08 00    	lea    0x8924c(%ebx),%eax
            return linebuf;
  100644:	83 c4 10             	add    $0x10,%esp
            linebuf[i] = 0;
  100647:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
        }
    }
}
  10064b:	83 c4 1c             	add    $0x1c,%esp
  10064e:	5b                   	pop    %ebx
  10064f:	5e                   	pop    %esi
  100650:	5f                   	pop    %edi
  100651:	5d                   	pop    %ebp
  100652:	c3                   	ret
  100653:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    serial_putc(c);
  100658:	83 ec 0c             	sub    $0xc,%esp
            i--;
  10065b:	83 ee 01             	sub    $0x1,%esi
    serial_putc(c);
  10065e:	6a 08                	push   $0x8
  100660:	e8 cb 00 00 00       	call   100730 <serial_putc>
    video_putc(c);
  100665:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  10066c:	e8 df fa ff ff       	call   100150 <video_putc>
            i--;
  100671:	83 c4 10             	add    $0x10,%esp
  100674:	e9 4f ff ff ff       	jmp    1005c8 <readline+0x38>
            dprintf("read error: %e\n", c);
  100679:	83 ec 08             	sub    $0x8,%esp
  10067c:	0f be c0             	movsbl %al,%eax
  10067f:	50                   	push   %eax
  100680:	8d 83 1d 60 ff ff    	lea    -0x9fe3(%ebx),%eax
  100686:	50                   	push   %eax
  100687:	e8 d4 43 00 00       	call   104a60 <dprintf>
            return NULL;
  10068c:	83 c4 10             	add    $0x10,%esp
  10068f:	31 c0                	xor    %eax,%eax
}
  100691:	83 c4 1c             	add    $0x1c,%esp
  100694:	5b                   	pop    %ebx
  100695:	5e                   	pop    %esi
  100696:	5f                   	pop    %edi
  100697:	5d                   	pop    %ebp
  100698:	c3                   	ret
  100699:	66 90                	xchg   %ax,%ax
  10069b:	66 90                	xchg   %ax,%ax
  10069d:	66 90                	xchg   %ax,%ax
  10069f:	90                   	nop

001006a0 <serial_proc_data>:
    inb(0x84);
    inb(0x84);
}

static int serial_proc_data(void)
{
  1006a0:	53                   	push   %ebx
  1006a1:	e8 fc fc ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1006a6:	81 c3 4e 69 01 00    	add    $0x1694e,%ebx
  1006ac:	83 ec 14             	sub    $0x14,%esp
    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA))
  1006af:	68 fd 03 00 00       	push   $0x3fd
  1006b4:	e8 37 4f 00 00       	call   1055f0 <inb>
  1006b9:	83 c4 10             	add    $0x10,%esp
  1006bc:	a8 01                	test   $0x1,%al
  1006be:	74 20                	je     1006e0 <serial_proc_data+0x40>
        return -1;
    return inb(COM1 + COM_RX);
  1006c0:	83 ec 0c             	sub    $0xc,%esp
  1006c3:	68 f8 03 00 00       	push   $0x3f8
  1006c8:	e8 23 4f 00 00       	call   1055f0 <inb>
  1006cd:	83 c4 10             	add    $0x10,%esp
  1006d0:	0f b6 c0             	movzbl %al,%eax
}
  1006d3:	83 c4 08             	add    $0x8,%esp
  1006d6:	5b                   	pop    %ebx
  1006d7:	c3                   	ret
  1006d8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1006df:	00 
        return -1;
  1006e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1006e5:	eb ec                	jmp    1006d3 <serial_proc_data+0x33>
  1006e7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1006ee:	00 
  1006ef:	90                   	nop

001006f0 <serial_intr>:

void serial_intr(void)
{
  1006f0:	53                   	push   %ebx
  1006f1:	e8 ac fc ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1006f6:	81 c3 fe 68 01 00    	add    $0x168fe,%ebx
  1006fc:	83 ec 08             	sub    $0x8,%esp
    if (serial_exists)
  1006ff:	80 bb 4c 96 08 00 00 	cmpb   $0x0,0x8964c(%ebx)
  100706:	75 08                	jne    100710 <serial_intr+0x20>
        cons_intr(serial_proc_data);
}
  100708:	83 c4 08             	add    $0x8,%esp
  10070b:	5b                   	pop    %ebx
  10070c:	c3                   	ret
  10070d:	8d 76 00             	lea    0x0(%esi),%esi
        cons_intr(serial_proc_data);
  100710:	83 ec 0c             	sub    $0xc,%esp
  100713:	8d 83 ac 96 fe ff    	lea    -0x16954(%ebx),%eax
  100719:	50                   	push   %eax
  10071a:	e8 d1 fc ff ff       	call   1003f0 <cons_intr>
}
  10071f:	83 c4 10             	add    $0x10,%esp
  100722:	83 c4 08             	add    $0x8,%esp
  100725:	5b                   	pop    %ebx
  100726:	c3                   	ret
  100727:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10072e:	00 
  10072f:	90                   	nop

00100730 <serial_putc>:
    } else
        return 0;
}

void serial_putc(char c)
{
  100730:	57                   	push   %edi
  100731:	56                   	push   %esi
    if (!serial_exists)
        return;

    int i;
    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i++)
  100732:	31 f6                	xor    %esi,%esi
{
  100734:	53                   	push   %ebx
  100735:	8b 7c 24 10          	mov    0x10(%esp),%edi
  100739:	e8 64 fc ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10073e:	81 c3 b6 68 01 00    	add    $0x168b6,%ebx
    if (!serial_exists)
  100744:	80 bb 4c 96 08 00 00 	cmpb   $0x0,0x8964c(%ebx)
  10074b:	75 42                	jne    10078f <serial_putc+0x5f>
  10074d:	eb 6e                	jmp    1007bd <serial_putc+0x8d>
  10074f:	90                   	nop
    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i++)
  100750:	81 fe 00 32 00 00    	cmp    $0x3200,%esi
  100756:	74 4b                	je     1007a3 <serial_putc+0x73>
    inb(0x84);
  100758:	83 ec 0c             	sub    $0xc,%esp
    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i++)
  10075b:	83 c6 01             	add    $0x1,%esi
    inb(0x84);
  10075e:	68 84 00 00 00       	push   $0x84
  100763:	e8 88 4e 00 00       	call   1055f0 <inb>
    inb(0x84);
  100768:	c7 04 24 84 00 00 00 	movl   $0x84,(%esp)
  10076f:	e8 7c 4e 00 00       	call   1055f0 <inb>
    inb(0x84);
  100774:	c7 04 24 84 00 00 00 	movl   $0x84,(%esp)
  10077b:	e8 70 4e 00 00       	call   1055f0 <inb>
    inb(0x84);
  100780:	c7 04 24 84 00 00 00 	movl   $0x84,(%esp)
  100787:	e8 64 4e 00 00       	call   1055f0 <inb>
    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i++)
  10078c:	83 c4 10             	add    $0x10,%esp
  10078f:	83 ec 0c             	sub    $0xc,%esp
  100792:	68 fd 03 00 00       	push   $0x3fd
  100797:	e8 54 4e 00 00       	call   1055f0 <inb>
  10079c:	83 c4 10             	add    $0x10,%esp
  10079f:	a8 20                	test   $0x20,%al
  1007a1:	74 ad                	je     100750 <serial_putc+0x20>
    if (c == nl) {
  1007a3:	89 f8                	mov    %edi,%eax
  1007a5:	3c 0a                	cmp    $0xa,%al
  1007a7:	74 1f                	je     1007c8 <serial_putc+0x98>
        delay();

    if (!serial_reformatnewline(c, COM1 + COM_TX))
        outb(COM1 + COM_TX, c);
  1007a9:	83 ec 08             	sub    $0x8,%esp
  1007ac:	0f b6 f8             	movzbl %al,%edi
  1007af:	57                   	push   %edi
  1007b0:	68 f8 03 00 00       	push   $0x3f8
  1007b5:	e8 66 4e 00 00       	call   105620 <outb>
  1007ba:	83 c4 10             	add    $0x10,%esp
}
  1007bd:	5b                   	pop    %ebx
  1007be:	5e                   	pop    %esi
  1007bf:	5f                   	pop    %edi
  1007c0:	c3                   	ret
  1007c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        outb(p, cr);
  1007c8:	83 ec 08             	sub    $0x8,%esp
  1007cb:	6a 0d                	push   $0xd
  1007cd:	68 f8 03 00 00       	push   $0x3f8
  1007d2:	e8 49 4e 00 00       	call   105620 <outb>
        outb(p, nl);
  1007d7:	58                   	pop    %eax
  1007d8:	5a                   	pop    %edx
  1007d9:	6a 0a                	push   $0xa
  1007db:	68 f8 03 00 00       	push   $0x3f8
  1007e0:	e8 3b 4e 00 00       	call   105620 <outb>
  1007e5:	83 c4 10             	add    $0x10,%esp
}
  1007e8:	5b                   	pop    %ebx
  1007e9:	5e                   	pop    %esi
  1007ea:	5f                   	pop    %edi
  1007eb:	c3                   	ret
  1007ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001007f0 <serial_init>:

void serial_init(void)
{
  1007f0:	53                   	push   %ebx
  1007f1:	e8 ac fb ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1007f6:	81 c3 fe 67 01 00    	add    $0x167fe,%ebx
  1007fc:	83 ec 10             	sub    $0x10,%esp
    /* turn off interrupt */
    outb(COM1 + COM_IER, 0);
  1007ff:	6a 00                	push   $0x0
  100801:	68 f9 03 00 00       	push   $0x3f9
  100806:	e8 15 4e 00 00       	call   105620 <outb>

    /* set DLAB */
    outb(COM1 + COM_LCR, COM_LCR_DLAB);
  10080b:	58                   	pop    %eax
  10080c:	5a                   	pop    %edx
  10080d:	68 80 00 00 00       	push   $0x80
  100812:	68 fb 03 00 00       	push   $0x3fb
  100817:	e8 04 4e 00 00       	call   105620 <outb>

    /* set baud rate */
    outb(COM1 + COM_DLL, 0x0001 & 0xff);
  10081c:	59                   	pop    %ecx
  10081d:	58                   	pop    %eax
  10081e:	6a 01                	push   $0x1
  100820:	68 f8 03 00 00       	push   $0x3f8
  100825:	e8 f6 4d 00 00       	call   105620 <outb>
    outb(COM1 + COM_DLM, 0x0001 >> 8);
  10082a:	58                   	pop    %eax
  10082b:	5a                   	pop    %edx
  10082c:	6a 00                	push   $0x0
  10082e:	68 f9 03 00 00       	push   $0x3f9
  100833:	e8 e8 4d 00 00       	call   105620 <outb>

    /* Set the line status. */
    outb(COM1 + COM_LCR, COM_LCR_WLEN8 & ~COM_LCR_DLAB);
  100838:	59                   	pop    %ecx
  100839:	58                   	pop    %eax
  10083a:	6a 03                	push   $0x3
  10083c:	68 fb 03 00 00       	push   $0x3fb
  100841:	e8 da 4d 00 00       	call   105620 <outb>

    /* Enable the FIFO. */
    outb(COM1 + COM_FCR, 0xc7);
  100846:	58                   	pop    %eax
  100847:	5a                   	pop    %edx
  100848:	68 c7 00 00 00       	push   $0xc7
  10084d:	68 fa 03 00 00       	push   $0x3fa
  100852:	e8 c9 4d 00 00       	call   105620 <outb>

    /* Turn on DTR, RTS, and OUT2. */
    outb(COM1 + COM_MCR, 0x0b);
  100857:	59                   	pop    %ecx
  100858:	58                   	pop    %eax
  100859:	6a 0b                	push   $0xb
  10085b:	68 fc 03 00 00       	push   $0x3fc
  100860:	e8 bb 4d 00 00       	call   105620 <outb>

    // Clear any preexisting overrun indications and interrupts
    // Serial COM1 doesn't exist if COM_LSR returns 0xFF
    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
  100865:	c7 04 24 fd 03 00 00 	movl   $0x3fd,(%esp)
  10086c:	e8 7f 4d 00 00       	call   1055f0 <inb>
    (void) inb(COM1 + COM_IIR);
  100871:	c7 04 24 fa 03 00 00 	movl   $0x3fa,(%esp)
    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
  100878:	3c ff                	cmp    $0xff,%al
  10087a:	0f 95 83 4c 96 08 00 	setne  0x8964c(%ebx)
    (void) inb(COM1 + COM_IIR);
  100881:	e8 6a 4d 00 00       	call   1055f0 <inb>
    (void) inb(COM1 + COM_RX);
  100886:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
  10088d:	e8 5e 4d 00 00       	call   1055f0 <inb>
}
  100892:	83 c4 18             	add    $0x18,%esp
  100895:	5b                   	pop    %ebx
  100896:	c3                   	ret
  100897:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10089e:	00 
  10089f:	90                   	nop

001008a0 <serial_intenable>:

void serial_intenable(void)
{
  1008a0:	53                   	push   %ebx
  1008a1:	e8 fc fa ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1008a6:	81 c3 4e 67 01 00    	add    $0x1674e,%ebx
  1008ac:	83 ec 08             	sub    $0x8,%esp
    if (serial_exists) {
  1008af:	80 bb 4c 96 08 00 00 	cmpb   $0x0,0x8964c(%ebx)
  1008b6:	75 08                	jne    1008c0 <serial_intenable+0x20>
        outb(COM1 + COM_IER, 1);
        serial_intr();
    }
}
  1008b8:	83 c4 08             	add    $0x8,%esp
  1008bb:	5b                   	pop    %ebx
  1008bc:	c3                   	ret
  1008bd:	8d 76 00             	lea    0x0(%esi),%esi
        outb(COM1 + COM_IER, 1);
  1008c0:	83 ec 08             	sub    $0x8,%esp
  1008c3:	6a 01                	push   $0x1
  1008c5:	68 f9 03 00 00       	push   $0x3f9
  1008ca:	e8 51 4d 00 00       	call   105620 <outb>
    if (serial_exists)
  1008cf:	83 c4 10             	add    $0x10,%esp
  1008d2:	80 bb 4c 96 08 00 00 	cmpb   $0x0,0x8964c(%ebx)
  1008d9:	74 dd                	je     1008b8 <serial_intenable+0x18>
        cons_intr(serial_proc_data);
  1008db:	83 ec 0c             	sub    $0xc,%esp
  1008de:	8d 83 ac 96 fe ff    	lea    -0x16954(%ebx),%eax
  1008e4:	50                   	push   %eax
  1008e5:	e8 06 fb ff ff       	call   1003f0 <cons_intr>
}
  1008ea:	83 c4 10             	add    $0x10,%esp
}
  1008ed:	83 c4 08             	add    $0x8,%esp
  1008f0:	5b                   	pop    %ebx
  1008f1:	c3                   	ret
  1008f2:	66 90                	xchg   %ax,%ax
  1008f4:	66 90                	xchg   %ax,%ax
  1008f6:	66 90                	xchg   %ax,%ax
  1008f8:	66 90                	xchg   %ax,%ax
  1008fa:	66 90                	xchg   %ax,%ax
  1008fc:	66 90                	xchg   %ax,%ax
  1008fe:	66 90                	xchg   %ax,%ax

00100900 <kbd_proc_data>:
/*
 * Get data from the keyboard. If we finish a character, return it. Else 0.
 * Return -1 if no data.
 */
static int kbd_proc_data(void)
{
  100900:	56                   	push   %esi
  100901:	53                   	push   %ebx
  100902:	e8 9b fa ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  100907:	81 c3 ed 66 01 00    	add    $0x166ed,%ebx
  10090d:	83 ec 10             	sub    $0x10,%esp
    int c;
    uint8_t data;
    static uint32_t shift;

    if ((inb(KBSTATP) & KBS_DIB) == 0)
  100910:	6a 64                	push   $0x64
  100912:	e8 d9 4c 00 00       	call   1055f0 <inb>
  100917:	83 c4 10             	add    $0x10,%esp
  10091a:	a8 01                	test   $0x1,%al
  10091c:	0f 84 26 01 00 00    	je     100a48 <kbd_proc_data+0x148>
        return -1;

    data = inb(KBDATAP);
  100922:	83 ec 0c             	sub    $0xc,%esp
  100925:	6a 60                	push   $0x60
  100927:	e8 c4 4c 00 00       	call   1055f0 <inb>

    if (data == 0xE0) {
  10092c:	83 c4 10             	add    $0x10,%esp
  10092f:	3c e0                	cmp    $0xe0,%al
  100931:	0f 84 89 00 00 00    	je     1009c0 <kbd_proc_data+0xc0>
        // E0 escape character
        shift |= E0ESC;
  100937:	8b 8b 50 96 08 00    	mov    0x89650(%ebx),%ecx
        return 0;
    } else if (data & 0x80) {
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
  10093d:	89 ca                	mov    %ecx,%edx
  10093f:	83 e2 40             	and    $0x40,%edx
    } else if (data & 0x80) {
  100942:	84 c0                	test   %al,%al
  100944:	0f 88 8e 00 00 00    	js     1009d8 <kbd_proc_data+0xd8>
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if (shift & E0ESC) {
  10094a:	85 d2                	test   %edx,%edx
  10094c:	74 06                	je     100954 <kbd_proc_data+0x54>
        // Last character was an E0 escape; or with 0x80
        data |= 0x80;
  10094e:	83 c8 80             	or     $0xffffff80,%eax
        shift &= ~E0ESC;
  100951:	83 e1 bf             	and    $0xffffffbf,%ecx
    }

    shift |= shiftcode[data];
  100954:	0f b6 c0             	movzbl %al,%eax
  100957:	0f b6 94 03 4c 6b ff 	movzbl -0x94b4(%ebx,%eax,1),%edx
  10095e:	ff 
  10095f:	09 ca                	or     %ecx,%edx
    shift ^= togglecode[data];
  100961:	0f b6 8c 03 4c 6a ff 	movzbl -0x95b4(%ebx,%eax,1),%ecx
  100968:	ff 
  100969:	31 ca                	xor    %ecx,%edx

    c = charcode[shift & (CTL | SHIFT)][data];
  10096b:	89 d1                	mov    %edx,%ecx
    shift ^= togglecode[data];
  10096d:	89 93 50 96 08 00    	mov    %edx,0x89650(%ebx)
    c = charcode[shift & (CTL | SHIFT)][data];
  100973:	83 e1 03             	and    $0x3,%ecx
  100976:	8b 8c 8b c8 ff ff ff 	mov    -0x38(%ebx,%ecx,4),%ecx
  10097d:	0f b6 34 01          	movzbl (%ecx,%eax,1),%esi
    if (shift & CAPSLOCK) {
  100981:	f6 c2 08             	test   $0x8,%dl
  100984:	75 22                	jne    1009a8 <kbd_proc_data+0xa8>
        else if ('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    // Process special keys
    // Ctrl-Alt-Del: reboot
    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  100986:	f7 d2                	not    %edx
  100988:	83 e2 06             	and    $0x6,%edx
  10098b:	75 0c                	jne    100999 <kbd_proc_data+0x99>
  10098d:	81 fe e9 00 00 00    	cmp    $0xe9,%esi
  100993:	0f 84 87 00 00 00    	je     100a20 <kbd_proc_data+0x120>
        dprintf("Rebooting!\n");
        outb(0x92, 0x3);  // courtesy of Chris Frost
    }

    return c;
}
  100999:	83 c4 04             	add    $0x4,%esp
  10099c:	89 f0                	mov    %esi,%eax
  10099e:	5b                   	pop    %ebx
  10099f:	5e                   	pop    %esi
  1009a0:	c3                   	ret
  1009a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        if ('a' <= c && c <= 'z')
  1009a8:	8d 46 9f             	lea    -0x61(%esi),%eax
  1009ab:	83 f8 19             	cmp    $0x19,%eax
  1009ae:	77 58                	ja     100a08 <kbd_proc_data+0x108>
            c += 'A' - 'a';
  1009b0:	83 ee 20             	sub    $0x20,%esi
}
  1009b3:	83 c4 04             	add    $0x4,%esp
  1009b6:	89 f0                	mov    %esi,%eax
  1009b8:	5b                   	pop    %ebx
  1009b9:	5e                   	pop    %esi
  1009ba:	c3                   	ret
  1009bb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        shift |= E0ESC;
  1009c0:	83 8b 50 96 08 00 40 	orl    $0x40,0x89650(%ebx)
        return 0;
  1009c7:	31 f6                	xor    %esi,%esi
}
  1009c9:	83 c4 04             	add    $0x4,%esp
  1009cc:	89 f0                	mov    %esi,%eax
  1009ce:	5b                   	pop    %ebx
  1009cf:	5e                   	pop    %esi
  1009d0:	c3                   	ret
  1009d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        data = (shift & E0ESC ? data : data & 0x7F);
  1009d8:	89 c6                	mov    %eax,%esi
  1009da:	83 e6 7f             	and    $0x7f,%esi
  1009dd:	85 d2                	test   %edx,%edx
  1009df:	0f 44 c6             	cmove  %esi,%eax
        return 0;
  1009e2:	31 f6                	xor    %esi,%esi
        shift &= ~(shiftcode[data] | E0ESC);
  1009e4:	0f b6 c0             	movzbl %al,%eax
  1009e7:	0f b6 84 03 4c 6b ff 	movzbl -0x94b4(%ebx,%eax,1),%eax
  1009ee:	ff 
  1009ef:	83 c8 40             	or     $0x40,%eax
  1009f2:	0f b6 c0             	movzbl %al,%eax
  1009f5:	f7 d0                	not    %eax
  1009f7:	21 c8                	and    %ecx,%eax
  1009f9:	89 83 50 96 08 00    	mov    %eax,0x89650(%ebx)
        return 0;
  1009ff:	eb c8                	jmp    1009c9 <kbd_proc_data+0xc9>
  100a01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        else if ('A' <= c && c <= 'Z')
  100a08:	8d 4e bf             	lea    -0x41(%esi),%ecx
            c += 'a' - 'A';
  100a0b:	8d 46 20             	lea    0x20(%esi),%eax
  100a0e:	83 f9 1a             	cmp    $0x1a,%ecx
  100a11:	0f 42 f0             	cmovb  %eax,%esi
  100a14:	e9 6d ff ff ff       	jmp    100986 <kbd_proc_data+0x86>
  100a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        dprintf("Rebooting!\n");
  100a20:	83 ec 0c             	sub    $0xc,%esp
  100a23:	8d 83 2d 60 ff ff    	lea    -0x9fd3(%ebx),%eax
  100a29:	50                   	push   %eax
  100a2a:	e8 31 40 00 00       	call   104a60 <dprintf>
        outb(0x92, 0x3);  // courtesy of Chris Frost
  100a2f:	58                   	pop    %eax
  100a30:	5a                   	pop    %edx
  100a31:	6a 03                	push   $0x3
  100a33:	68 92 00 00 00       	push   $0x92
  100a38:	e8 e3 4b 00 00       	call   105620 <outb>
  100a3d:	83 c4 10             	add    $0x10,%esp
  100a40:	e9 54 ff ff ff       	jmp    100999 <kbd_proc_data+0x99>
  100a45:	8d 76 00             	lea    0x0(%esi),%esi
        return -1;
  100a48:	be ff ff ff ff       	mov    $0xffffffff,%esi
  100a4d:	e9 47 ff ff ff       	jmp    100999 <kbd_proc_data+0x99>
  100a52:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  100a59:	00 
  100a5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00100a60 <keyboard_intr>:

void keyboard_intr(void)
{
  100a60:	53                   	push   %ebx
  100a61:	e8 3c f9 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  100a66:	81 c3 8e 65 01 00    	add    $0x1658e,%ebx
  100a6c:	83 ec 14             	sub    $0x14,%esp
    cons_intr(kbd_proc_data);
  100a6f:	8d 83 0c 99 fe ff    	lea    -0x166f4(%ebx),%eax
  100a75:	50                   	push   %eax
  100a76:	e8 75 f9 ff ff       	call   1003f0 <cons_intr>
}
  100a7b:	83 c4 18             	add    $0x18,%esp
  100a7e:	5b                   	pop    %ebx
  100a7f:	c3                   	ret

00100a80 <devinit>:
void inode_init(void);
void file_init(void);
void fs_init(void);

void devinit(uintptr_t mbi_addr)
{
  100a80:	56                   	push   %esi
  100a81:	53                   	push   %ebx
  100a82:	e8 1b f9 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  100a87:	81 c3 6d 65 01 00    	add    $0x1656d,%ebx
  100a8d:	83 ec 10             	sub    $0x10,%esp
  100a90:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    seg_init(0);
  100a94:	6a 00                	push   $0x0
  100a96:	e8 15 46 00 00       	call   1050b0 <seg_init>

    enable_sse();
  100a9b:	e8 f0 49 00 00       	call   105490 <enable_sse>

    cons_init();
  100aa0:	e8 0b f9 ff ff       	call   1003b0 <cons_init>

    debug_init();
  100aa5:	e8 46 3c 00 00       	call   1046f0 <debug_init>
    KERN_INFO("[BSP KERN] cons initialized.\n");
  100aaa:	8d 83 39 60 ff ff    	lea    -0x9fc7(%ebx),%eax
  100ab0:	89 04 24             	mov    %eax,(%esp)
  100ab3:	e8 98 3c 00 00       	call   104750 <debug_info>
    KERN_INFO("[BSP KERN] devinit mbi_addr: %d\n", mbi_addr);
  100ab8:	58                   	pop    %eax
  100ab9:	8d 83 4c 6c ff ff    	lea    -0x93b4(%ebx),%eax
  100abf:	5a                   	pop    %edx
  100ac0:	56                   	push   %esi
  100ac1:	50                   	push   %eax
  100ac2:	e8 89 3c 00 00       	call   104750 <debug_info>

    /* pcpu init codes */
    pcpu_init();
  100ac7:	e8 14 59 00 00       	call   1063e0 <pcpu_init>
    KERN_INFO("[BSP KERN] PCPU initialized\n");
  100acc:	8d 83 57 60 ff ff    	lea    -0x9fa9(%ebx),%eax
  100ad2:	89 04 24             	mov    %eax,(%esp)
  100ad5:	e8 76 3c 00 00       	call   104750 <debug_info>

    tsc_init();
  100ada:	e8 f1 11 00 00       	call   101cd0 <tsc_init>
    KERN_INFO("[BSP KERN] TSC initialized\n");
  100adf:	8d 83 74 60 ff ff    	lea    -0x9f8c(%ebx),%eax
  100ae5:	89 04 24             	mov    %eax,(%esp)
  100ae8:	e8 63 3c 00 00       	call   104750 <debug_info>

    intr_init();
  100aed:	e8 1e 07 00 00       	call   101210 <intr_init>
    KERN_INFO("[BSP KERN] INTR initialized\n");
  100af2:	8d 83 90 60 ff ff    	lea    -0x9f70(%ebx),%eax
  100af8:	89 04 24             	mov    %eax,(%esp)
  100afb:	e8 50 3c 00 00       	call   104750 <debug_info>

    trap_init(0);
  100b00:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100b07:	e8 e4 81 00 00       	call   108cf0 <trap_init>

    pmmap_init(mbi_addr);
  100b0c:	89 34 24             	mov    %esi,(%esp)
  100b0f:	e8 6c 01 00 00       	call   100c80 <pmmap_init>

    bufcache_init();  // buffer cache
  100b14:	e8 c7 84 00 00       	call   108fe0 <bufcache_init>
    file_init();      // file table
  100b19:	e8 f2 9b 00 00       	call   10a710 <file_init>
    inode_init();     // inode cache
  100b1e:	e8 ed 8e 00 00       	call   109a10 <inode_init>
    ide_init();
  100b23:	e8 c8 33 00 00       	call   103ef0 <ide_init>
    fs_init();
  100b28:	e8 03 a3 00 00       	call   10ae30 <fs_init>
    KERN_INFO("[BSP KERN] IDE disk driver initialized\n");
  100b2d:	8d 83 70 6c ff ff    	lea    -0x9390(%ebx),%eax
  100b33:	89 04 24             	mov    %eax,(%esp)
  100b36:	e8 15 3c 00 00       	call   104750 <debug_info>
}
  100b3b:	83 c4 14             	add    $0x14,%esp
  100b3e:	5b                   	pop    %ebx
  100b3f:	5e                   	pop    %esi
  100b40:	c3                   	ret
  100b41:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  100b48:	00 
  100b49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00100b50 <devinit_ap>:

void devinit_ap(void)
{
  100b50:	56                   	push   %esi
  100b51:	53                   	push   %ebx
  100b52:	e8 4b f8 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  100b57:	81 c3 9d 64 01 00    	add    $0x1649d,%ebx
  100b5d:	83 ec 04             	sub    $0x4,%esp
    /* Figure out the current (booting) kernel stack) */
    struct kstack *ks = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  100b60:	e8 5b 48 00 00       	call   1053c0 <read_esp>

    KERN_ASSERT(ks != NULL);
  100b65:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100b6a:	89 c6                	mov    %eax,%esi
  100b6c:	74 6a                	je     100bd8 <devinit_ap+0x88>
    KERN_ASSERT(1 <= ks->cpu_idx && ks->cpu_idx < 8);
  100b6e:	8b 86 1c 01 00 00    	mov    0x11c(%esi),%eax
  100b74:	8d 50 ff             	lea    -0x1(%eax),%edx
  100b77:	83 fa 06             	cmp    $0x6,%edx
  100b7a:	0f 87 89 00 00 00    	ja     100c09 <devinit_ap+0xb9>

    /* kernel stack for this cpu initialized */
    seg_init(ks->cpu_idx);
  100b80:	83 ec 0c             	sub    $0xc,%esp
  100b83:	50                   	push   %eax
  100b84:	e8 27 45 00 00       	call   1050b0 <seg_init>

    pcpu_init();
  100b89:	e8 52 58 00 00       	call   1063e0 <pcpu_init>
    KERN_INFO("[AP%d KERN] PCPU initialized\n", ks->cpu_idx);
  100b8e:	58                   	pop    %eax
  100b8f:	8d 83 e8 60 ff ff    	lea    -0x9f18(%ebx),%eax
  100b95:	5a                   	pop    %edx
  100b96:	ff b6 1c 01 00 00    	push   0x11c(%esi)
  100b9c:	50                   	push   %eax
  100b9d:	e8 ae 3b 00 00       	call   104750 <debug_info>

    intr_init();
  100ba2:	e8 69 06 00 00       	call   101210 <intr_init>
    KERN_INFO("[AP%d KERN] INTR initialized.\n", ks->cpu_idx);
  100ba7:	59                   	pop    %ecx
  100ba8:	58                   	pop    %eax
  100ba9:	8d 83 bc 6c ff ff    	lea    -0x9344(%ebx),%eax
  100baf:	ff b6 1c 01 00 00    	push   0x11c(%esi)
  100bb5:	50                   	push   %eax
  100bb6:	e8 95 3b 00 00       	call   104750 <debug_info>

    trap_init(ks->cpu_idx);
  100bbb:	58                   	pop    %eax
  100bbc:	ff b6 1c 01 00 00    	push   0x11c(%esi)
  100bc2:	e8 29 81 00 00       	call   108cf0 <trap_init>

    paging_init_ap();
  100bc7:	e8 04 67 00 00       	call   1072d0 <paging_init_ap>
}
  100bcc:	83 c4 14             	add    $0x14,%esp
  100bcf:	5b                   	pop    %ebx
  100bd0:	5e                   	pop    %esi
  100bd1:	c3                   	ret
  100bd2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    KERN_ASSERT(ks != NULL);
  100bd8:	8d 83 ad 60 ff ff    	lea    -0x9f53(%ebx),%eax
  100bde:	50                   	push   %eax
  100bdf:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  100be5:	50                   	push   %eax
  100be6:	8d 83 d5 60 ff ff    	lea    -0x9f2b(%ebx),%eax
  100bec:	6a 3f                	push   $0x3f
  100bee:	50                   	push   %eax
  100bef:	e8 fc 3b 00 00       	call   1047f0 <debug_panic>
    KERN_ASSERT(1 <= ks->cpu_idx && ks->cpu_idx < 8);
  100bf4:	8b 86 1c 01 00 00    	mov    0x11c(%esi),%eax
    KERN_ASSERT(ks != NULL);
  100bfa:	83 c4 10             	add    $0x10,%esp
    KERN_ASSERT(1 <= ks->cpu_idx && ks->cpu_idx < 8);
  100bfd:	8d 50 ff             	lea    -0x1(%eax),%edx
  100c00:	83 fa 06             	cmp    $0x6,%edx
  100c03:	0f 86 77 ff ff ff    	jbe    100b80 <devinit_ap+0x30>
  100c09:	8d 83 98 6c ff ff    	lea    -0x9368(%ebx),%eax
  100c0f:	50                   	push   %eax
  100c10:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  100c16:	50                   	push   %eax
  100c17:	8d 83 d5 60 ff ff    	lea    -0x9f2b(%ebx),%eax
  100c1d:	6a 40                	push   $0x40
  100c1f:	50                   	push   %eax
  100c20:	e8 cb 3b 00 00       	call   1047f0 <debug_panic>
    seg_init(ks->cpu_idx);
  100c25:	8b 86 1c 01 00 00    	mov    0x11c(%esi),%eax
  100c2b:	83 c4 10             	add    $0x10,%esp
  100c2e:	e9 4d ff ff ff       	jmp    100b80 <devinit_ap+0x30>
  100c33:	66 90                	xchg   %ax,%ax
  100c35:	66 90                	xchg   %ax,%ax
  100c37:	66 90                	xchg   %ax,%ax
  100c39:	66 90                	xchg   %ax,%ax
  100c3b:	66 90                	xchg   %ax,%ax
  100c3d:	66 90                	xchg   %ax,%ax
  100c3f:	90                   	nop

00100c40 <pmmap_alloc_slot>:
    if (unlikely(pmmap_slots_next_free == 128))
  100c40:	e8 59 f7 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  100c45:	81 c2 af 63 01 00    	add    $0x163af,%edx
  100c4b:	8b 82 88 96 08 00    	mov    0x89688(%edx),%eax
  100c51:	3d 80 00 00 00       	cmp    $0x80,%eax
  100c56:	74 18                	je     100c70 <pmmap_alloc_slot+0x30>
    return &pmmap_slots[pmmap_slots_next_free++];
  100c58:	8d 48 01             	lea    0x1(%eax),%ecx
  100c5b:	8d 04 80             	lea    (%eax,%eax,4),%eax
  100c5e:	89 8a 88 96 08 00    	mov    %ecx,0x89688(%edx)
  100c64:	8d 84 82 8c 96 08 00 	lea    0x8968c(%edx,%eax,4),%eax
  100c6b:	c3                   	ret
  100c6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return NULL;
  100c70:	31 c0                	xor    %eax,%eax
}
  100c72:	c3                   	ret
  100c73:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  100c7a:	00 
  100c7b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00100c80 <pmmap_init>:
                  (slot->type == MEM_NVS) ? "ACPI NVS" : "unknown");
    }
}

void pmmap_init(uintptr_t mbi_addr)
{
  100c80:	55                   	push   %ebp
  100c81:	e8 83 05 00 00       	call   101209 <__x86.get_pc_thunk.bp>
  100c86:	81 c5 6e 63 01 00    	add    $0x1636e,%ebp
  100c8c:	57                   	push   %edi
  100c8d:	56                   	push   %esi
  100c8e:	53                   	push   %ebx
  100c8f:	83 ec 58             	sub    $0x58,%esp
    KERN_INFO("\n");
  100c92:	8d 85 90 65 ff ff    	lea    -0x9a70(%ebp),%eax
{
  100c98:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    KERN_INFO("\n");
  100c9c:	89 eb                	mov    %ebp,%ebx
  100c9e:	50                   	push   %eax
  100c9f:	e8 ac 3a 00 00       	call   104750 <debug_info>

    mboot_info_t *mbi = (mboot_info_t *) mbi_addr;
    mboot_mmap_t *p = (mboot_mmap_t *) mbi->mmap_addr;
  100ca4:	8b 46 30             	mov    0x30(%esi),%eax
    SLIST_INIT(&pmmap_sublist[PMMAP_NVS]);

    /*
     * Copy memory map information from multiboot information mbi to pmmap.
     */
    while ((uintptr_t) p - (uintptr_t) mbi->mmap_addr < mbi->mmap_length) {
  100ca7:	8b 76 2c             	mov    0x2c(%esi),%esi
    SLIST_INIT(&pmmap_list);
  100caa:	c7 85 84 96 08 00 00 	movl   $0x0,0x89684(%ebp)
  100cb1:	00 00 00 
    SLIST_INIT(&pmmap_sublist[PMMAP_USABLE]);
  100cb4:	c7 85 74 96 08 00 00 	movl   $0x0,0x89674(%ebp)
  100cbb:	00 00 00 
    while ((uintptr_t) p - (uintptr_t) mbi->mmap_addr < mbi->mmap_length) {
  100cbe:	89 74 24 34          	mov    %esi,0x34(%esp)
  100cc2:	83 c4 10             	add    $0x10,%esp
    SLIST_INIT(&pmmap_sublist[PMMAP_RESV]);
  100cc5:	c7 85 78 96 08 00 00 	movl   $0x0,0x89678(%ebp)
  100ccc:	00 00 00 
    SLIST_INIT(&pmmap_sublist[PMMAP_ACPI]);
  100ccf:	c7 85 7c 96 08 00 00 	movl   $0x0,0x8967c(%ebp)
  100cd6:	00 00 00 
    SLIST_INIT(&pmmap_sublist[PMMAP_NVS]);
  100cd9:	c7 85 80 96 08 00 00 	movl   $0x0,0x89680(%ebp)
  100ce0:	00 00 00 
    while ((uintptr_t) p - (uintptr_t) mbi->mmap_addr < mbi->mmap_length) {
  100ce3:	85 f6                	test   %esi,%esi
  100ce5:	0f 84 4f 03 00 00    	je     10103a <pmmap_init+0x3ba>
  100ceb:	ba e8 ff ff ff       	mov    $0xffffffe8,%edx
  100cf0:	8d 58 18             	lea    0x18(%eax),%ebx
  100cf3:	31 ff                	xor    %edi,%edi
  100cf5:	c6 44 24 2f 00       	movb   $0x0,0x2f(%esp)
  100cfa:	29 c2                	sub    %eax,%edx
  100cfc:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  100d00:	8b b5 88 96 08 00    	mov    0x89688(%ebp),%esi
  100d06:	c6 44 24 14 00       	movb   $0x0,0x14(%esp)
  100d0b:	89 54 24 28          	mov    %edx,0x28(%esp)
  100d0f:	89 7c 24 20          	mov    %edi,0x20(%esp)
  100d13:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        uintptr_t start, end;
        uint32_t type;

        if (p->base_addr_high != 0)  /* ignore address above 4G */
  100d18:	8b 78 08             	mov    0x8(%eax),%edi
  100d1b:	85 ff                	test   %edi,%edi
  100d1d:	0f 85 c5 00 00 00    	jne    100de8 <pmmap_init+0x168>
            goto next;
        else
            start = p->base_addr_low;

        if (p->length_high != 0 || p->length_low >= 0xffffffff - start)
  100d23:	8b 58 10             	mov    0x10(%eax),%ebx
            start = p->base_addr_low;
  100d26:	8b 50 04             	mov    0x4(%eax),%edx
            end = 0xffffffff;
  100d29:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
        if (p->length_high != 0 || p->length_low >= 0xffffffff - start)
  100d2e:	85 db                	test   %ebx,%ebx
  100d30:	75 0f                	jne    100d41 <pmmap_init+0xc1>
        else
            end = start + p->length_low;
  100d32:	8b 78 0c             	mov    0xc(%eax),%edi
  100d35:	89 d3                	mov    %edx,%ebx
  100d37:	f7 d3                	not    %ebx
  100d39:	01 d7                	add    %edx,%edi
  100d3b:	39 58 0c             	cmp    %ebx,0xc(%eax)
  100d3e:	0f 42 cf             	cmovb  %edi,%ecx

        type = p->type;
  100d41:	8b 40 14             	mov    0x14(%eax),%eax
  100d44:	89 44 24 10          	mov    %eax,0x10(%esp)
    if (unlikely(pmmap_slots_next_free == 128))
  100d48:	81 fe 80 00 00 00    	cmp    $0x80,%esi
  100d4e:	0f 84 ac f2 ff ff    	je     100000 <pmmap_init.cold>
    return &pmmap_slots[pmmap_slots_next_free++];
  100d54:	8d 46 01             	lea    0x1(%esi),%eax
  100d57:	8d 1c b5 00 00 00 00 	lea    0x0(,%esi,4),%ebx
  100d5e:	89 44 24 14          	mov    %eax,0x14(%esp)
  100d62:	8d 04 33             	lea    (%ebx,%esi,1),%eax
  100d65:	c1 e0 02             	shl    $0x2,%eax
  100d68:	8d bc 05 8c 96 08 00 	lea    0x8968c(%ebp,%eax,1),%edi
    free_slot->end = end;
  100d6f:	8d 84 05 8c 96 08 00 	lea    0x8968c(%ebp,%eax,1),%eax
  100d76:	89 48 04             	mov    %ecx,0x4(%eax)
    free_slot->type = type;
  100d79:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    return &pmmap_slots[pmmap_slots_next_free++];
  100d7d:	89 7c 24 18          	mov    %edi,0x18(%esp)
    free_slot->type = type;
  100d81:	89 48 08             	mov    %ecx,0x8(%eax)
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100d84:	8b 44 24 20          	mov    0x20(%esp),%eax
    free_slot->start = start;
  100d88:	89 17                	mov    %edx,(%edi)
    free_slot->end = end;
  100d8a:	8d 3d 8c 96 08 00    	lea    0x8968c,%edi
  100d90:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100d94:	85 c0                	test   %eax,%eax
  100d96:	74 25                	je     100dbd <pmmap_init+0x13d>
    last_slot = NULL;
  100d98:	31 ff                	xor    %edi,%edi
  100d9a:	eb 13                	jmp    100daf <pmmap_init+0x12f>
  100d9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100da0:	8b 48 0c             	mov    0xc(%eax),%ecx
  100da3:	89 c7                	mov    %eax,%edi
  100da5:	85 c9                	test   %ecx,%ecx
  100da7:	0f 84 33 02 00 00    	je     100fe0 <pmmap_init+0x360>
  100dad:	89 c8                	mov    %ecx,%eax
        if (start < slot->start)
  100daf:	3b 10                	cmp    (%eax),%edx
  100db1:	73 ed                	jae    100da0 <pmmap_init+0x120>
    if (last_slot == NULL) {
  100db3:	89 f8                	mov    %edi,%eax
  100db5:	85 ff                	test   %edi,%edi
  100db7:	0f 85 23 02 00 00    	jne    100fe0 <pmmap_init+0x360>
        SLIST_INSERT_HEAD(&pmmap_list, free_slot, next);
  100dbd:	01 f3                	add    %esi,%ebx
  100dbf:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  100dc3:	c6 44 24 2f 01       	movb   $0x1,0x2f(%esp)
  100dc8:	8d 44 9d 00          	lea    0x0(%ebp,%ebx,4),%eax
  100dcc:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  100dd0:	89 5c 06 0c          	mov    %ebx,0xc(%esi,%eax,1)
  100dd4:	8b 44 24 18          	mov    0x18(%esp),%eax
    return &pmmap_slots[pmmap_slots_next_free++];
  100dd8:	8b 74 24 14          	mov    0x14(%esp),%esi
  100ddc:	c6 44 24 14 01       	movb   $0x1,0x14(%esp)
        SLIST_INSERT_HEAD(&pmmap_list, free_slot, next);
  100de1:	89 44 24 20          	mov    %eax,0x20(%esp)
  100de5:	8d 76 00             	lea    0x0(%esi),%esi

        pmmap_insert(start, end, type);

      next:
        p = (mboot_mmap_t *) (((uint32_t) p) + sizeof(mboot_mmap_t) /* p->size */);
  100de8:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
    while ((uintptr_t) p - (uintptr_t) mbi->mmap_addr < mbi->mmap_length) {
  100dec:	8b 7c 24 28          	mov    0x28(%esp),%edi
        p = (mboot_mmap_t *) (((uint32_t) p) + sizeof(mboot_mmap_t) /* p->size */);
  100df0:	89 d8                	mov    %ebx,%eax
    while ((uintptr_t) p - (uintptr_t) mbi->mmap_addr < mbi->mmap_length) {
  100df2:	83 c3 18             	add    $0x18,%ebx
  100df5:	8d 14 1f             	lea    (%edi,%ebx,1),%edx
  100df8:	8b 7c 24 24          	mov    0x24(%esp),%edi
  100dfc:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  100e00:	39 fa                	cmp    %edi,%edx
  100e02:	0f 82 10 ff ff ff    	jb     100d18 <pmmap_init+0x98>
  100e08:	80 7c 24 2f 00       	cmpb   $0x0,0x2f(%esp)
  100e0d:	8b 7c 24 20          	mov    0x20(%esp),%edi
  100e11:	0f 84 52 02 00 00    	je     101069 <pmmap_init+0x3e9>
  100e17:	80 7c 24 14 00       	cmpb   $0x0,0x14(%esp)
  100e1c:	89 bd 84 96 08 00    	mov    %edi,0x89684(%ebp)
  100e22:	74 06                	je     100e2a <pmmap_init+0x1aa>
  100e24:	89 b5 88 96 08 00    	mov    %esi,0x89688(%ebp)
    struct pmmap *last_slot[4] = { NULL, NULL, NULL, NULL };
  100e2a:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
  100e31:	00 
  100e32:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
  100e39:	00 
  100e3a:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
  100e41:	00 
  100e42:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
  100e49:	00 
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100e4a:	85 ff                	test   %edi,%edi
  100e4c:	0f 84 e8 01 00 00    	je     10103a <pmmap_init+0x3ba>
        if ((next_slot = SLIST_NEXT(slot, next)) == NULL)
  100e52:	8b 47 0c             	mov    0xc(%edi),%eax
  100e55:	85 c0                	test   %eax,%eax
  100e57:	74 29                	je     100e82 <pmmap_init+0x202>
  100e59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        if (slot->start <= next_slot->start &&
  100e60:	8b 10                	mov    (%eax),%edx
  100e62:	3b 17                	cmp    (%edi),%edx
  100e64:	72 13                	jb     100e79 <pmmap_init+0x1f9>
            slot->end >= next_slot->start &&
  100e66:	8b 4f 04             	mov    0x4(%edi),%ecx
        if (slot->start <= next_slot->start &&
  100e69:	39 d1                	cmp    %edx,%ecx
  100e6b:	72 0c                	jb     100e79 <pmmap_init+0x1f9>
            slot->end >= next_slot->start &&
  100e6d:	8b 70 08             	mov    0x8(%eax),%esi
  100e70:	39 77 08             	cmp    %esi,0x8(%edi)
  100e73:	0f 84 36 01 00 00    	je     100faf <pmmap_init+0x32f>
  100e79:	89 c7                	mov    %eax,%edi
        if ((next_slot = SLIST_NEXT(slot, next)) == NULL)
  100e7b:	8b 47 0c             	mov    0xc(%edi),%eax
  100e7e:	85 c0                	test   %eax,%eax
  100e80:	75 de                	jne    100e60 <pmmap_init+0x1e0>
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100e82:	8b b5 84 96 08 00    	mov    0x89684(%ebp),%esi
            SLIST_INSERT_HEAD(&pmmap_sublist[sublist_nr], slot, type_next);
  100e88:	8d bd 74 96 08 00    	lea    0x89674(%ebp),%edi
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100e8e:	85 f6                	test   %esi,%esi
  100e90:	75 2a                	jne    100ebc <pmmap_init+0x23c>
  100e92:	e9 a3 01 00 00       	jmp    10103a <pmmap_init+0x3ba>
  100e97:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  100e9e:	00 
  100e9f:	90                   	nop
        if (last_slot[sublist_nr] != NULL)
  100ea0:	8b 54 84 30          	mov    0x30(%esp,%eax,4),%edx
  100ea4:	85 d2                	test   %edx,%edx
  100ea6:	74 4d                	je     100ef5 <pmmap_init+0x275>
            SLIST_INSERT_AFTER(last_slot[sublist_nr], slot, type_next);
  100ea8:	8b 4a 10             	mov    0x10(%edx),%ecx
        last_slot[sublist_nr] = slot;
  100eab:	89 74 84 30          	mov    %esi,0x30(%esp,%eax,4)
            SLIST_INSERT_AFTER(last_slot[sublist_nr], slot, type_next);
  100eaf:	89 4e 10             	mov    %ecx,0x10(%esi)
  100eb2:	89 72 10             	mov    %esi,0x10(%edx)
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100eb5:	8b 76 0c             	mov    0xc(%esi),%esi
  100eb8:	85 f6                	test   %esi,%esi
  100eba:	74 4d                	je     100f09 <pmmap_init+0x289>
        sublist_nr = PMMAP_SUBLIST_NR(slot->type);
  100ebc:	8b 46 08             	mov    0x8(%esi),%eax
  100ebf:	83 e8 01             	sub    $0x1,%eax
  100ec2:	83 f8 03             	cmp    $0x3,%eax
  100ec5:	76 d9                	jbe    100ea0 <pmmap_init+0x220>
        KERN_ASSERT(sublist_nr != -1);
  100ec7:	8d 85 5f 61 ff ff    	lea    -0x9ea1(%ebp),%eax
  100ecd:	89 eb                	mov    %ebp,%ebx
  100ecf:	50                   	push   %eax
  100ed0:	8d 85 b8 60 ff ff    	lea    -0x9f48(%ebp),%eax
  100ed6:	50                   	push   %eax
  100ed7:	8d 85 4e 61 ff ff    	lea    -0x9eb2(%ebp),%eax
  100edd:	6a 6b                	push   $0x6b
  100edf:	50                   	push   %eax
  100ee0:	e8 0b 39 00 00       	call   1047f0 <debug_panic>
  100ee5:	83 c4 10             	add    $0x10,%esp
        sublist_nr = PMMAP_SUBLIST_NR(slot->type);
  100ee8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        if (last_slot[sublist_nr] != NULL)
  100eed:	8b 54 84 30          	mov    0x30(%esp,%eax,4),%edx
  100ef1:	85 d2                	test   %edx,%edx
  100ef3:	75 b3                	jne    100ea8 <pmmap_init+0x228>
            SLIST_INSERT_HEAD(&pmmap_sublist[sublist_nr], slot, type_next);
  100ef5:	8b 14 87             	mov    (%edi,%eax,4),%edx
        last_slot[sublist_nr] = slot;
  100ef8:	89 74 84 30          	mov    %esi,0x30(%esp,%eax,4)
            SLIST_INSERT_HEAD(&pmmap_sublist[sublist_nr], slot, type_next);
  100efc:	89 34 87             	mov    %esi,(%edi,%eax,4)
  100eff:	89 56 10             	mov    %edx,0x10(%esi)
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100f02:	8b 76 0c             	mov    0xc(%esi),%esi
  100f05:	85 f6                	test   %esi,%esi
  100f07:	75 b3                	jne    100ebc <pmmap_init+0x23c>
    if (last_slot[PMMAP_USABLE] != NULL)
  100f09:	8b 44 24 30          	mov    0x30(%esp),%eax
  100f0d:	85 c0                	test   %eax,%eax
  100f0f:	74 09                	je     100f1a <pmmap_init+0x29a>
        max_usable_memory = last_slot[PMMAP_USABLE]->end;
  100f11:	8b 40 04             	mov    0x4(%eax),%eax
  100f14:	89 85 70 96 08 00    	mov    %eax,0x89670(%ebp)
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100f1a:	8b b5 84 96 08 00    	mov    0x89684(%ebp),%esi
  100f20:	85 f6                	test   %esi,%esi
  100f22:	0f 84 12 01 00 00    	je     10103a <pmmap_init+0x3ba>
        KERN_INFO("BIOS-e820: 0x%08x - 0x%08x (%s)\n",
  100f28:	8d 85 1e 61 ff ff    	lea    -0x9ee2(%ebp),%eax
  100f2e:	8d bd dc 6c ff ff    	lea    -0x9324(%ebp),%edi
  100f34:	89 44 24 10          	mov    %eax,0x10(%esp)
  100f38:	8d 85 28 61 ff ff    	lea    -0x9ed8(%ebp),%eax
  100f3e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  100f42:	eb 4d                	jmp    100f91 <pmmap_init+0x311>
  100f44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  100f48:	8d 95 0e 61 ff ff    	lea    -0x9ef2(%ebp),%edx
  100f4e:	83 f8 01             	cmp    $0x1,%eax
  100f51:	74 12                	je     100f65 <pmmap_init+0x2e5>
  100f53:	83 f8 02             	cmp    $0x2,%eax
  100f56:	8d 95 06 61 ff ff    	lea    -0x9efa(%ebp),%edx
  100f5c:	8d 85 15 61 ff ff    	lea    -0x9eeb(%ebp),%eax
  100f62:	0f 44 d0             	cmove  %eax,%edx
  100f65:	8b 0e                	mov    (%esi),%ecx
  100f67:	8b 46 04             	mov    0x4(%esi),%eax
  100f6a:	39 c1                	cmp    %eax,%ecx
  100f6c:	74 0a                	je     100f78 <pmmap_init+0x2f8>
  100f6e:	31 db                	xor    %ebx,%ebx
  100f70:	83 f8 ff             	cmp    $0xffffffff,%eax
  100f73:	0f 95 c3             	setne  %bl
  100f76:	29 d8                	sub    %ebx,%eax
  100f78:	52                   	push   %edx
  100f79:	89 eb                	mov    %ebp,%ebx
  100f7b:	50                   	push   %eax
  100f7c:	51                   	push   %ecx
  100f7d:	57                   	push   %edi
  100f7e:	e8 cd 37 00 00       	call   104750 <debug_info>
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100f83:	8b 76 0c             	mov    0xc(%esi),%esi
  100f86:	83 c4 10             	add    $0x10,%esp
  100f89:	85 f6                	test   %esi,%esi
  100f8b:	0f 84 7f 00 00 00    	je     101010 <pmmap_init+0x390>
        KERN_INFO("BIOS-e820: 0x%08x - 0x%08x (%s)\n",
  100f91:	8b 46 08             	mov    0x8(%esi),%eax
  100f94:	83 f8 03             	cmp    $0x3,%eax
  100f97:	0f 84 c3 00 00 00    	je     101060 <pmmap_init+0x3e0>
  100f9d:	76 a9                	jbe    100f48 <pmmap_init+0x2c8>
  100f9f:	83 f8 04             	cmp    $0x4,%eax
  100fa2:	8d 95 06 61 ff ff    	lea    -0x9efa(%ebp),%edx
  100fa8:	0f 44 54 24 0c       	cmove  0xc(%esp),%edx
  100fad:	eb b6                	jmp    100f65 <pmmap_init+0x2e5>
            slot->end = max(slot->end, next_slot->end);
  100faf:	83 ec 08             	sub    $0x8,%esp
  100fb2:	ff 70 04             	push   0x4(%eax)
  100fb5:	89 eb                	mov    %ebp,%ebx
  100fb7:	51                   	push   %ecx
  100fb8:	e8 a3 43 00 00       	call   105360 <max>
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100fbd:	83 c4 10             	add    $0x10,%esp
            slot->end = max(slot->end, next_slot->end);
  100fc0:	89 47 04             	mov    %eax,0x4(%edi)
            SLIST_REMOVE_AFTER(slot, next);
  100fc3:	8b 47 0c             	mov    0xc(%edi),%eax
  100fc6:	8b 40 0c             	mov    0xc(%eax),%eax
  100fc9:	89 47 0c             	mov    %eax,0xc(%edi)
    SLIST_FOREACH(slot, &pmmap_list, next) {
  100fcc:	85 c0                	test   %eax,%eax
  100fce:	0f 84 ae fe ff ff    	je     100e82 <pmmap_init+0x202>
  100fd4:	89 c7                	mov    %eax,%edi
  100fd6:	e9 a0 fe ff ff       	jmp    100e7b <pmmap_init+0x1fb>
  100fdb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        SLIST_INSERT_AFTER(last_slot, free_slot, next);
  100fe0:	8b 48 0c             	mov    0xc(%eax),%ecx
  100fe3:	01 f3                	add    %esi,%ebx
  100fe5:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  100fe9:	8d 54 9d 00          	lea    0x0(%ebp,%ebx,4),%edx
  100fed:	89 4c 16 0c          	mov    %ecx,0xc(%esi,%edx,1)
  100ff1:	8b 74 24 18          	mov    0x18(%esp),%esi
  100ff5:	89 70 0c             	mov    %esi,0xc(%eax)
    return &pmmap_slots[pmmap_slots_next_free++];
  100ff8:	8b 74 24 14          	mov    0x14(%esp),%esi
        SLIST_INSERT_AFTER(last_slot, free_slot, next);
  100ffc:	c6 44 24 14 01       	movb   $0x1,0x14(%esp)
  101001:	e9 e2 fd ff ff       	jmp    100de8 <pmmap_init+0x168>
  101006:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10100d:	00 
  10100e:	66 90                	xchg   %ax,%ax
    pmmap_merge();
    pmmap_dump();

    /* count the number of pmmap entries */
    struct pmmap *slot;
    SLIST_FOREACH(slot, &pmmap_list, next) {
  101010:	8b 95 84 96 08 00    	mov    0x89684(%ebp),%edx
  101016:	85 d2                	test   %edx,%edx
  101018:	74 20                	je     10103a <pmmap_init+0x3ba>
  10101a:	8b 85 6c 96 08 00    	mov    0x8966c(%ebp),%eax
  101020:	83 c0 01             	add    $0x1,%eax
  101023:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
  101028:	8b 52 0c             	mov    0xc(%edx),%edx
  10102b:	89 c1                	mov    %eax,%ecx
  10102d:	83 c0 01             	add    $0x1,%eax
  101030:	85 d2                	test   %edx,%edx
  101032:	75 f4                	jne    101028 <pmmap_init+0x3a8>
  101034:	89 8d 6c 96 08 00    	mov    %ecx,0x8966c(%ebp)
        pmmap_nentries++;
    }

    /* Calculate the maximum page number */
    mem_npages = rounddown(max_usable_memory, PAGESIZE) / PAGESIZE;
  10103a:	83 ec 08             	sub    $0x8,%esp
  10103d:	89 eb                	mov    %ebp,%ebx
  10103f:	68 00 10 00 00       	push   $0x1000
  101044:	ff b5 70 96 08 00    	push   0x89670(%ebp)
  10104a:	e8 31 43 00 00       	call   105380 <rounddown>
}
  10104f:	83 c4 5c             	add    $0x5c,%esp
  101052:	5b                   	pop    %ebx
  101053:	5e                   	pop    %esi
  101054:	5f                   	pop    %edi
  101055:	5d                   	pop    %ebp
  101056:	c3                   	ret
  101057:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10105e:	00 
  10105f:	90                   	nop
        KERN_INFO("BIOS-e820: 0x%08x - 0x%08x (%s)\n",
  101060:	8b 54 24 10          	mov    0x10(%esp),%edx
  101064:	e9 fc fe ff ff       	jmp    100f65 <pmmap_init+0x2e5>
  101069:	80 7c 24 14 00       	cmpb   $0x0,0x14(%esp)
  10106e:	74 ca                	je     10103a <pmmap_init+0x3ba>
  101070:	89 b5 88 96 08 00    	mov    %esi,0x89688(%ebp)
    SLIST_FOREACH(slot, &pmmap_list, next) {
  101076:	eb c2                	jmp    10103a <pmmap_init+0x3ba>
  101078:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10107f:	00 

00101080 <get_size>:

int get_size(void)
{
    return pmmap_nentries;
  101080:	e8 15 f3 ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  101085:	05 6f 5f 01 00       	add    $0x15f6f,%eax
  10108a:	8b 80 6c 96 08 00    	mov    0x8966c(%eax),%eax
}
  101090:	c3                   	ret
  101091:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  101098:	00 
  101099:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001010a0 <get_mms>:

uint32_t get_mms(int idx)
{
  1010a0:	53                   	push   %ebx
  1010a1:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1010a5:	e8 f8 f2 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1010aa:	81 c3 4a 5f 01 00    	add    $0x15f4a,%ebx
    int i = 0;
    struct pmmap *slot = NULL;

    SLIST_FOREACH(slot, &pmmap_list, next) {
  1010b0:	8b 83 84 96 08 00    	mov    0x89684(%ebx),%eax
  1010b6:	85 c0                	test   %eax,%eax
  1010b8:	74 1c                	je     1010d6 <get_mms+0x36>
    int i = 0;
  1010ba:	31 d2                	xor    %edx,%edx
        if (i == idx)
  1010bc:	85 c9                	test   %ecx,%ecx
  1010be:	75 0c                	jne    1010cc <get_mms+0x2c>
  1010c0:	eb 1e                	jmp    1010e0 <get_mms+0x40>
  1010c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1010c8:	39 d1                	cmp    %edx,%ecx
  1010ca:	74 14                	je     1010e0 <get_mms+0x40>
    SLIST_FOREACH(slot, &pmmap_list, next) {
  1010cc:	8b 40 0c             	mov    0xc(%eax),%eax
            break;
        i++;
  1010cf:	83 c2 01             	add    $0x1,%edx
    SLIST_FOREACH(slot, &pmmap_list, next) {
  1010d2:	85 c0                	test   %eax,%eax
  1010d4:	75 f2                	jne    1010c8 <get_mms+0x28>
    }

    if (slot == NULL || i == pmmap_nentries)
        return 0;
  1010d6:	31 c9                	xor    %ecx,%ecx

    return slot->start;
}
  1010d8:	89 c8                	mov    %ecx,%eax
  1010da:	5b                   	pop    %ebx
  1010db:	c3                   	ret
  1010dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return 0;
  1010e0:	31 c9                	xor    %ecx,%ecx
    if (slot == NULL || i == pmmap_nentries)
  1010e2:	39 93 6c 96 08 00    	cmp    %edx,0x8966c(%ebx)
  1010e8:	74 ee                	je     1010d8 <get_mms+0x38>
    return slot->start;
  1010ea:	8b 08                	mov    (%eax),%ecx
}
  1010ec:	5b                   	pop    %ebx
  1010ed:	89 c8                	mov    %ecx,%eax
  1010ef:	c3                   	ret

001010f0 <get_mml>:

uint32_t get_mml(int idx)
{
  1010f0:	53                   	push   %ebx
  1010f1:	8b 44 24 08          	mov    0x8(%esp),%eax
  1010f5:	e8 a8 f2 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1010fa:	81 c3 fa 5e 01 00    	add    $0x15efa,%ebx
    int i = 0;
    struct pmmap *slot = NULL;

    SLIST_FOREACH(slot, &pmmap_list, next) {
  101100:	8b 93 84 96 08 00    	mov    0x89684(%ebx),%edx
  101106:	85 d2                	test   %edx,%edx
  101108:	74 1c                	je     101126 <get_mml+0x36>
    int i = 0;
  10110a:	31 c9                	xor    %ecx,%ecx
        if (i == idx)
  10110c:	85 c0                	test   %eax,%eax
  10110e:	75 0c                	jne    10111c <get_mml+0x2c>
  101110:	eb 1e                	jmp    101130 <get_mml+0x40>
  101112:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  101118:	39 c8                	cmp    %ecx,%eax
  10111a:	74 14                	je     101130 <get_mml+0x40>
    SLIST_FOREACH(slot, &pmmap_list, next) {
  10111c:	8b 52 0c             	mov    0xc(%edx),%edx
            break;
        i++;
  10111f:	83 c1 01             	add    $0x1,%ecx
    SLIST_FOREACH(slot, &pmmap_list, next) {
  101122:	85 d2                	test   %edx,%edx
  101124:	75 f2                	jne    101118 <get_mml+0x28>
    }

    if (slot == NULL || i == pmmap_nentries)
        return 0;
  101126:	31 c0                	xor    %eax,%eax

    return slot->end - slot->start;
}
  101128:	5b                   	pop    %ebx
  101129:	c3                   	ret
  10112a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        return 0;
  101130:	31 c0                	xor    %eax,%eax
    if (slot == NULL || i == pmmap_nentries)
  101132:	39 8b 6c 96 08 00    	cmp    %ecx,0x8966c(%ebx)
  101138:	74 ee                	je     101128 <get_mml+0x38>
    return slot->end - slot->start;
  10113a:	8b 42 04             	mov    0x4(%edx),%eax
}
  10113d:	5b                   	pop    %ebx
    return slot->end - slot->start;
  10113e:	2b 02                	sub    (%edx),%eax
}
  101140:	c3                   	ret
  101141:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  101148:	00 
  101149:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00101150 <is_usable>:

int is_usable(int idx)
{
  101150:	53                   	push   %ebx
  101151:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  101155:	e8 48 f2 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10115a:	81 c3 9a 5e 01 00    	add    $0x15e9a,%ebx
    int i = 0;
    struct pmmap *slot = NULL;

    SLIST_FOREACH(slot, &pmmap_list, next) {
  101160:	8b 83 84 96 08 00    	mov    0x89684(%ebx),%eax
  101166:	85 c0                	test   %eax,%eax
  101168:	74 1c                	je     101186 <is_usable+0x36>
    int i = 0;
  10116a:	31 d2                	xor    %edx,%edx
        if (i == idx)
  10116c:	85 c9                	test   %ecx,%ecx
  10116e:	75 0c                	jne    10117c <is_usable+0x2c>
  101170:	eb 1e                	jmp    101190 <is_usable+0x40>
  101172:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  101178:	39 d1                	cmp    %edx,%ecx
  10117a:	74 14                	je     101190 <is_usable+0x40>
    SLIST_FOREACH(slot, &pmmap_list, next) {
  10117c:	8b 40 0c             	mov    0xc(%eax),%eax
            break;
        i++;
  10117f:	83 c2 01             	add    $0x1,%edx
    SLIST_FOREACH(slot, &pmmap_list, next) {
  101182:	85 c0                	test   %eax,%eax
  101184:	75 f2                	jne    101178 <is_usable+0x28>
    }

    if (slot == NULL || i == pmmap_nentries)
        return 0;
  101186:	31 c9                	xor    %ecx,%ecx

    return slot->type == MEM_RAM;
}
  101188:	89 c8                	mov    %ecx,%eax
  10118a:	5b                   	pop    %ebx
  10118b:	c3                   	ret
  10118c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return 0;
  101190:	31 c9                	xor    %ecx,%ecx
    if (slot == NULL || i == pmmap_nentries)
  101192:	39 93 6c 96 08 00    	cmp    %edx,0x8966c(%ebx)
  101198:	74 ee                	je     101188 <is_usable+0x38>
    return slot->type == MEM_RAM;
  10119a:	31 c9                	xor    %ecx,%ecx
  10119c:	83 78 08 01          	cmpl   $0x1,0x8(%eax)
}
  1011a0:	5b                   	pop    %ebx
    return slot->type == MEM_RAM;
  1011a1:	0f 94 c1             	sete   %cl
}
  1011a4:	89 c8                	mov    %ecx,%eax
  1011a6:	c3                   	ret
  1011a7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1011ae:	00 
  1011af:	90                   	nop

001011b0 <set_cr3>:

void set_cr3(unsigned int **pdir)
{
  1011b0:	53                   	push   %ebx
  1011b1:	e8 ec f1 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1011b6:	81 c3 3e 5e 01 00    	add    $0x15e3e,%ebx
  1011bc:	83 ec 14             	sub    $0x14,%esp
    lcr3((uint32_t) pdir);
  1011bf:	ff 74 24 1c          	push   0x1c(%esp)
  1011c3:	e8 f8 43 00 00       	call   1055c0 <lcr3>
}
  1011c8:	83 c4 18             	add    $0x18,%esp
  1011cb:	5b                   	pop    %ebx
  1011cc:	c3                   	ret
  1011cd:	8d 76 00             	lea    0x0(%esi),%esi

001011d0 <enable_paging>:

void enable_paging(void)
{
  1011d0:	53                   	push   %ebx
  1011d1:	e8 cc f1 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1011d6:	81 c3 1e 5e 01 00    	add    $0x15e1e,%ebx
  1011dc:	83 ec 08             	sub    $0x8,%esp
    /* enable global pages (Sec 4.10.2.4, Intel ASDM Vol3) */
    uint32_t cr4 = rcr4();
  1011df:	e8 fc 43 00 00       	call   1055e0 <rcr4>
    cr4 |= CR4_PGE;
    lcr4(cr4);
  1011e4:	83 ec 0c             	sub    $0xc,%esp
    cr4 |= CR4_PGE;
  1011e7:	0c 80                	or     $0x80,%al
    lcr4(cr4);
  1011e9:	50                   	push   %eax
  1011ea:	e8 e1 43 00 00       	call   1055d0 <lcr4>

    /* turn on paging */
    uint32_t cr0 = rcr0();
  1011ef:	e8 ac 43 00 00       	call   1055a0 <rcr0>
    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_MP;
    cr0 &= ~(CR0_EM | CR0_TS);
  1011f4:	83 e0 f3             	and    $0xfffffff3,%eax
  1011f7:	0d 23 00 05 80       	or     $0x80050023,%eax
    lcr0(cr0);
  1011fc:	89 04 24             	mov    %eax,(%esp)
  1011ff:	e8 8c 43 00 00       	call   105590 <lcr0>
}
  101204:	83 c4 18             	add    $0x18,%esp
  101207:	5b                   	pop    %ebx
  101208:	c3                   	ret

00101209 <__x86.get_pc_thunk.bp>:
  101209:	8b 2c 24             	mov    (%esp),%ebp
  10120c:	c3                   	ret
  10120d:	66 90                	xchg   %ax,%ax
  10120f:	90                   	nop

00101210 <intr_init>:
{
    asm volatile ("lidt %0" :: "m" (idt_pd));
}

void intr_init(void)
{
  101210:	55                   	push   %ebp
  101211:	57                   	push   %edi
  101212:	56                   	push   %esi
  101213:	53                   	push   %ebx
  101214:	e8 89 f1 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  101219:	81 c3 db 5d 01 00    	add    $0x15ddb,%ebx
  10121f:	83 ec 38             	sub    $0x38,%esp
    uint32_t dummy, edx;

    cpuid(0x00000001, &dummy, &dummy, &dummy, &edx);
  101222:	8d 44 24 28          	lea    0x28(%esp),%eax
  101226:	50                   	push   %eax
  101227:	8d 44 24 28          	lea    0x28(%esp),%eax
  10122b:	50                   	push   %eax
  10122c:	50                   	push   %eax
  10122d:	50                   	push   %eax
  10122e:	6a 01                	push   $0x1
  101230:	e8 8b 42 00 00       	call   1054c0 <cpuid>
    using_apic = (edx & CPUID_FEATURE_APIC) ? TRUE : FALSE;
  101235:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    KERN_ASSERT(using_apic == TRUE);
  101239:	83 c4 20             	add    $0x20,%esp
    using_apic = (edx & CPUID_FEATURE_APIC) ? TRUE : FALSE;
  10123c:	c1 e8 09             	shr    $0x9,%eax
  10123f:	83 e0 01             	and    $0x1,%eax
  101242:	88 83 8c a8 08 00    	mov    %al,0x8a88c(%ebx)
    KERN_ASSERT(using_apic == TRUE);
  101248:	0f b6 83 8c a8 08 00 	movzbl 0x8a88c(%ebx),%eax
  10124f:	3c 01                	cmp    $0x1,%al
  101251:	74 1f                	je     101272 <intr_init+0x62>
  101253:	8d 83 70 61 ff ff    	lea    -0x9e90(%ebx),%eax
  101259:	50                   	push   %eax
  10125a:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  101260:	50                   	push   %eax
  101261:	8d 83 83 61 ff ff    	lea    -0x9e7d(%ebx),%eax
  101267:	6a 63                	push   $0x63
  101269:	50                   	push   %eax
  10126a:	e8 81 35 00 00       	call   1047f0 <debug_panic>
  10126f:	83 c4 10             	add    $0x10,%esp

    if (pcpu_onboot())
  101272:	e8 99 28 00 00       	call   103b10 <pcpu_onboot>
  101277:	84 c0                	test   %al,%al
  101279:	75 25                	jne    1012a0 <intr_init+0x90>
            intr_init_idt();
        }
    }

    /* all processors */
    if (using_apic)
  10127b:	0f b6 83 8c a8 08 00 	movzbl 0x8a88c(%ebx),%eax
  101282:	84 c0                	test   %al,%al
  101284:	0f 85 56 05 00 00    	jne    1017e0 <intr_init+0x5d0>
    asm volatile ("lidt %0" :: "m" (idt_pd));
  10128a:	0f 01 9b 0c 03 00 00 	lidtl  0x30c(%ebx)
    {
        lapic_init();
    }
    intr_install_idt();
}
  101291:	83 c4 2c             	add    $0x2c,%esp
  101294:	5b                   	pop    %ebx
  101295:	5e                   	pop    %esi
  101296:	5f                   	pop    %edi
  101297:	5d                   	pop    %ebp
  101298:	c3                   	ret
  101299:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        pic_init();
  1012a0:	e8 5b 07 00 00       	call   101a00 <pic_init>
        if (using_apic)
  1012a5:	0f b6 83 8c a8 08 00 	movzbl 0x8a88c(%ebx),%eax
  1012ac:	84 c0                	test   %al,%al
  1012ae:	74 cb                	je     10127b <intr_init+0x6b>
            ioapic_init();
  1012b0:	e8 8b 18 00 00       	call   102b40 <ioapic_init>
        SETGATE(idt[i], 0, CPU_GDT_KCODE, &Xdefault, 0);
  1012b5:	c7 c0 5e 22 10 00    	mov    $0x10225e,%eax
  1012bb:	8d 35 8c a0 08 00    	lea    0x8a08c,%esi
  1012c1:	8d 8b 8c a0 08 00    	lea    0x8a08c(%ebx),%ecx
  1012c7:	89 c2                	mov    %eax,%edx
  1012c9:	89 44 24 08          	mov    %eax,0x8(%esp)
  1012cd:	89 c7                	mov    %eax,%edi
    for (i = 0; i < sizeof(idt) / sizeof(idt[0]); i++)
  1012cf:	31 c0                	xor    %eax,%eax
        SETGATE(idt[i], 0, CPU_GDT_KCODE, &Xdefault, 0);
  1012d1:	c1 ea 10             	shr    $0x10,%edx
  1012d4:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1012d8:	89 d5                	mov    %edx,%ebp
  1012da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1012e0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  1012e7:	66 89 3c c1          	mov    %di,(%ecx,%eax,8)
    for (i = 0; i < sizeof(idt) / sizeof(idt[0]); i++)
  1012eb:	83 c0 01             	add    $0x1,%eax
        SETGATE(idt[i], 0, CPU_GDT_KCODE, &Xdefault, 0);
  1012ee:	c7 84 13 8e a0 08 00 	movl   $0x8e000008,0x8a08e(%ebx,%edx,1)
  1012f5:	08 00 00 8e 
  1012f9:	01 da                	add    %ebx,%edx
  1012fb:	66 89 6c 16 06       	mov    %bp,0x6(%esi,%edx,1)
    for (i = 0; i < sizeof(idt) / sizeof(idt[0]); i++)
  101300:	3d 00 01 00 00       	cmp    $0x100,%eax
  101305:	75 d9                	jne    1012e0 <intr_init+0xd0>
    SETGATE(idt[T_DIVIDE],                  0, CPU_GDT_KCODE, &Xdivide,         0);
  101307:	c7 c0 50 21 10 00    	mov    $0x102150,%eax
  10130d:	8b 54 24 0c          	mov    0xc(%esp),%edx
  101311:	c7 83 8e a0 08 00 08 	movl   $0x8e000008,0x8a08e(%ebx)
  101318:	00 00 8e 
    SETGATE(idt[T_FPERR],                   0, CPU_GDT_KCODE, &Xfperr,          0);
  10131b:	b9 08 00 00 00       	mov    $0x8,%ecx
    SETGATE(idt[T_DEBUG],                   0, CPU_GDT_KCODE, &Xdebug,          0);
  101320:	c7 83 96 a0 08 00 08 	movl   $0x8e000008,0x8a096(%ebx)
  101327:	00 00 8e 
    SETGATE(idt[T_FPERR],                   0, CPU_GDT_KCODE, &Xfperr,          0);
  10132a:	be 00 8e ff ff       	mov    $0xffff8e00,%esi
    SETGATE(idt[T_DIVIDE],                  0, CPU_GDT_KCODE, &Xdivide,         0);
  10132f:	66 89 83 8c a0 08 00 	mov    %ax,0x8a08c(%ebx)
  101336:	c1 e8 10             	shr    $0x10,%eax
  101339:	66 89 83 92 a0 08 00 	mov    %ax,0x8a092(%ebx)
    SETGATE(idt[T_DEBUG],                   0, CPU_GDT_KCODE, &Xdebug,          0);
  101340:	c7 c0 5a 21 10 00    	mov    $0x10215a,%eax
    SETGATE(idt[T_NMI],                     0, CPU_GDT_KCODE, &Xnmi,            0);
  101346:	c7 83 9e a0 08 00 08 	movl   $0x8e000008,0x8a09e(%ebx)
  10134d:	00 00 8e 
    SETGATE(idt[T_DEBUG],                   0, CPU_GDT_KCODE, &Xdebug,          0);
  101350:	66 89 83 94 a0 08 00 	mov    %ax,0x8a094(%ebx)
  101357:	c1 e8 10             	shr    $0x10,%eax
  10135a:	66 89 83 9a a0 08 00 	mov    %ax,0x8a09a(%ebx)
    SETGATE(idt[T_NMI],                     0, CPU_GDT_KCODE, &Xnmi,            0);
  101361:	c7 c0 64 21 10 00    	mov    $0x102164,%eax
    SETGATE(idt[T_BRKPT],                   0, CPU_GDT_KCODE, &Xbrkpt,          3);
  101367:	c7 83 a6 a0 08 00 08 	movl   $0xee000008,0x8a0a6(%ebx)
  10136e:	00 00 ee 
    SETGATE(idt[T_NMI],                     0, CPU_GDT_KCODE, &Xnmi,            0);
  101371:	66 89 83 9c a0 08 00 	mov    %ax,0x8a09c(%ebx)
  101378:	c1 e8 10             	shr    $0x10,%eax
  10137b:	66 89 83 a2 a0 08 00 	mov    %ax,0x8a0a2(%ebx)
    SETGATE(idt[T_BRKPT],                   0, CPU_GDT_KCODE, &Xbrkpt,          3);
  101382:	c7 c0 6e 21 10 00    	mov    $0x10216e,%eax
    SETGATE(idt[T_OFLOW],                   0, CPU_GDT_KCODE, &Xoflow,          3);
  101388:	c7 83 ae a0 08 00 08 	movl   $0xee000008,0x8a0ae(%ebx)
  10138f:	00 00 ee 
    SETGATE(idt[T_BRKPT],                   0, CPU_GDT_KCODE, &Xbrkpt,          3);
  101392:	66 89 83 a4 a0 08 00 	mov    %ax,0x8a0a4(%ebx)
  101399:	c1 e8 10             	shr    $0x10,%eax
  10139c:	66 89 83 aa a0 08 00 	mov    %ax,0x8a0aa(%ebx)
    SETGATE(idt[T_OFLOW],                   0, CPU_GDT_KCODE, &Xoflow,          3);
  1013a3:	c7 c0 78 21 10 00    	mov    $0x102178,%eax
    SETGATE(idt[T_BOUND],                   0, CPU_GDT_KCODE, &Xbound,          0);
  1013a9:	c7 83 b6 a0 08 00 08 	movl   $0x8e000008,0x8a0b6(%ebx)
  1013b0:	00 00 8e 
    SETGATE(idt[T_OFLOW],                   0, CPU_GDT_KCODE, &Xoflow,          3);
  1013b3:	66 89 83 ac a0 08 00 	mov    %ax,0x8a0ac(%ebx)
  1013ba:	c1 e8 10             	shr    $0x10,%eax
  1013bd:	66 89 83 b2 a0 08 00 	mov    %ax,0x8a0b2(%ebx)
    SETGATE(idt[T_BOUND],                   0, CPU_GDT_KCODE, &Xbound,          0);
  1013c4:	c7 c0 82 21 10 00    	mov    $0x102182,%eax
    SETGATE(idt[T_ILLOP],                   0, CPU_GDT_KCODE, &Xillop,          0);
  1013ca:	c7 83 be a0 08 00 08 	movl   $0x8e000008,0x8a0be(%ebx)
  1013d1:	00 00 8e 
    SETGATE(idt[T_BOUND],                   0, CPU_GDT_KCODE, &Xbound,          0);
  1013d4:	66 89 83 b4 a0 08 00 	mov    %ax,0x8a0b4(%ebx)
  1013db:	c1 e8 10             	shr    $0x10,%eax
  1013de:	66 89 83 ba a0 08 00 	mov    %ax,0x8a0ba(%ebx)
    SETGATE(idt[T_ILLOP],                   0, CPU_GDT_KCODE, &Xillop,          0);
  1013e5:	c7 c0 8c 21 10 00    	mov    $0x10218c,%eax
    SETGATE(idt[T_DEVICE],                  0, CPU_GDT_KCODE, &Xdevice,         0);
  1013eb:	c7 83 c6 a0 08 00 08 	movl   $0x8e000008,0x8a0c6(%ebx)
  1013f2:	00 00 8e 
    SETGATE(idt[T_ILLOP],                   0, CPU_GDT_KCODE, &Xillop,          0);
  1013f5:	66 89 83 bc a0 08 00 	mov    %ax,0x8a0bc(%ebx)
  1013fc:	c1 e8 10             	shr    $0x10,%eax
  1013ff:	66 89 83 c2 a0 08 00 	mov    %ax,0x8a0c2(%ebx)
    SETGATE(idt[T_DEVICE],                  0, CPU_GDT_KCODE, &Xdevice,         0);
  101406:	c7 c0 96 21 10 00    	mov    $0x102196,%eax
  10140c:	66 89 83 c4 a0 08 00 	mov    %ax,0x8a0c4(%ebx)
  101413:	c1 e8 10             	shr    $0x10,%eax
  101416:	66 89 83 ca a0 08 00 	mov    %ax,0x8a0ca(%ebx)
    SETGATE(idt[T_DBLFLT],                  0, CPU_GDT_KCODE, &Xdblflt,         0);
  10141d:	c7 c0 a0 21 10 00    	mov    $0x1021a0,%eax
    SETGATE(idt[T_FPERR],                   0, CPU_GDT_KCODE, &Xfperr,          0);
  101423:	66 89 8b 0e a1 08 00 	mov    %cx,0x8a10e(%ebx)
    SETGATE(idt[T_DBLFLT],                  0, CPU_GDT_KCODE, &Xdblflt,         0);
  10142a:	66 89 83 cc a0 08 00 	mov    %ax,0x8a0cc(%ebx)
  101431:	c1 e8 10             	shr    $0x10,%eax
  101434:	66 89 83 d2 a0 08 00 	mov    %ax,0x8a0d2(%ebx)
    SETGATE(idt[T_TSS],                     0, CPU_GDT_KCODE, &Xtss,            0);
  10143b:	c7 c0 b2 21 10 00    	mov    $0x1021b2,%eax
    SETGATE(idt[T_DBLFLT],                  0, CPU_GDT_KCODE, &Xdblflt,         0);
  101441:	c7 83 ce a0 08 00 08 	movl   $0x8e000008,0x8a0ce(%ebx)
  101448:	00 00 8e 
    SETGATE(idt[T_TSS],                     0, CPU_GDT_KCODE, &Xtss,            0);
  10144b:	66 89 83 dc a0 08 00 	mov    %ax,0x8a0dc(%ebx)
  101452:	c1 e8 10             	shr    $0x10,%eax
  101455:	66 89 83 e2 a0 08 00 	mov    %ax,0x8a0e2(%ebx)
    SETGATE(idt[T_SEGNP],                   0, CPU_GDT_KCODE, &Xsegnp,          0);
  10145c:	c7 c0 ba 21 10 00    	mov    $0x1021ba,%eax
    SETGATE(idt[T_TSS],                     0, CPU_GDT_KCODE, &Xtss,            0);
  101462:	c7 83 de a0 08 00 08 	movl   $0x8e000008,0x8a0de(%ebx)
  101469:	00 00 8e 
    SETGATE(idt[T_SEGNP],                   0, CPU_GDT_KCODE, &Xsegnp,          0);
  10146c:	66 89 83 e4 a0 08 00 	mov    %ax,0x8a0e4(%ebx)
  101473:	c1 e8 10             	shr    $0x10,%eax
  101476:	66 89 83 ea a0 08 00 	mov    %ax,0x8a0ea(%ebx)
    SETGATE(idt[T_STACK],                   0, CPU_GDT_KCODE, &Xstack,          0);
  10147d:	c7 c0 c2 21 10 00    	mov    $0x1021c2,%eax
    SETGATE(idt[T_SEGNP],                   0, CPU_GDT_KCODE, &Xsegnp,          0);
  101483:	c7 83 e6 a0 08 00 08 	movl   $0x8e000008,0x8a0e6(%ebx)
  10148a:	00 00 8e 
    SETGATE(idt[T_STACK],                   0, CPU_GDT_KCODE, &Xstack,          0);
  10148d:	66 89 83 ec a0 08 00 	mov    %ax,0x8a0ec(%ebx)
  101494:	c1 e8 10             	shr    $0x10,%eax
  101497:	66 89 83 f2 a0 08 00 	mov    %ax,0x8a0f2(%ebx)
    SETGATE(idt[T_GPFLT],                   0, CPU_GDT_KCODE, &Xgpflt,          0);
  10149e:	c7 c0 ca 21 10 00    	mov    $0x1021ca,%eax
    SETGATE(idt[T_STACK],                   0, CPU_GDT_KCODE, &Xstack,          0);
  1014a4:	c7 83 ee a0 08 00 08 	movl   $0x8e000008,0x8a0ee(%ebx)
  1014ab:	00 00 8e 
    SETGATE(idt[T_GPFLT],                   0, CPU_GDT_KCODE, &Xgpflt,          0);
  1014ae:	66 89 83 f4 a0 08 00 	mov    %ax,0x8a0f4(%ebx)
  1014b5:	c1 e8 10             	shr    $0x10,%eax
  1014b8:	66 89 83 fa a0 08 00 	mov    %ax,0x8a0fa(%ebx)
    SETGATE(idt[T_PGFLT],                   0, CPU_GDT_KCODE, &Xpgflt,          0);
  1014bf:	c7 c0 d2 21 10 00    	mov    $0x1021d2,%eax
    SETGATE(idt[T_GPFLT],                   0, CPU_GDT_KCODE, &Xgpflt,          0);
  1014c5:	c7 83 f6 a0 08 00 08 	movl   $0x8e000008,0x8a0f6(%ebx)
  1014cc:	00 00 8e 
    SETGATE(idt[T_PGFLT],                   0, CPU_GDT_KCODE, &Xpgflt,          0);
  1014cf:	66 89 83 fc a0 08 00 	mov    %ax,0x8a0fc(%ebx)
  1014d6:	c1 e8 10             	shr    $0x10,%eax
  1014d9:	66 89 83 02 a1 08 00 	mov    %ax,0x8a102(%ebx)
    SETGATE(idt[T_FPERR],                   0, CPU_GDT_KCODE, &Xfperr,          0);
  1014e0:	c7 c0 e4 21 10 00    	mov    $0x1021e4,%eax
    SETGATE(idt[T_PGFLT],                   0, CPU_GDT_KCODE, &Xpgflt,          0);
  1014e6:	c7 83 fe a0 08 00 08 	movl   $0x8e000008,0x8a0fe(%ebx)
  1014ed:	00 00 8e 
    SETGATE(idt[T_FPERR],                   0, CPU_GDT_KCODE, &Xfperr,          0);
  1014f0:	66 89 83 0c a1 08 00 	mov    %ax,0x8a10c(%ebx)
  1014f7:	c1 e8 10             	shr    $0x10,%eax
  1014fa:	66 89 83 12 a1 08 00 	mov    %ax,0x8a112(%ebx)
    SETGATE(idt[T_ALIGN],                   0, CPU_GDT_KCODE, &Xalign,          0);
  101501:	c7 c0 ee 21 10 00    	mov    $0x1021ee,%eax
    SETGATE(idt[T_FPERR],                   0, CPU_GDT_KCODE, &Xfperr,          0);
  101507:	66 89 b3 10 a1 08 00 	mov    %si,0x8a110(%ebx)
    SETGATE(idt[T_ALIGN],                   0, CPU_GDT_KCODE, &Xalign,          0);
  10150e:	66 89 83 14 a1 08 00 	mov    %ax,0x8a114(%ebx)
  101515:	c1 e8 10             	shr    $0x10,%eax
  101518:	c7 83 16 a1 08 00 08 	movl   $0x8e000008,0x8a116(%ebx)
  10151f:	00 00 8e 
  101522:	66 89 83 1a a1 08 00 	mov    %ax,0x8a11a(%ebx)
    SETGATE(idt[T_MCHK],                    0, CPU_GDT_KCODE, &Xmchk,           0);
  101529:	c7 c0 f2 21 10 00    	mov    $0x1021f2,%eax
  10152f:	c7 83 1e a1 08 00 08 	movl   $0x8e000008,0x8a11e(%ebx)
  101536:	00 00 8e 
    SETGATE(idt[T_IRQ0 + IRQ_SERIAL13],     0, CPU_GDT_KCODE, &Xirq_serial1,    0);
  101539:	c7 c1 10 22 10 00    	mov    $0x102210,%ecx
    SETGATE(idt[T_MCHK],                    0, CPU_GDT_KCODE, &Xmchk,           0);
  10153f:	66 89 83 1c a1 08 00 	mov    %ax,0x8a11c(%ebx)
  101546:	c1 e8 10             	shr    $0x10,%eax
  101549:	66 89 83 22 a1 08 00 	mov    %ax,0x8a122(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_TIMER],        0, CPU_GDT_KCODE, &Xirq_timer,      0);
  101550:	c7 c0 f8 21 10 00    	mov    $0x1021f8,%eax
    SETGATE(idt[T_IRQ0 + IRQ_SERIAL13],     0, CPU_GDT_KCODE, &Xirq_serial1,    0);
  101556:	66 89 8b ac a1 08 00 	mov    %cx,0x8a1ac(%ebx)
  10155d:	c1 e9 10             	shr    $0x10,%ecx
    SETGATE(idt[T_IRQ0 + IRQ_TIMER],        0, CPU_GDT_KCODE, &Xirq_timer,      0);
  101560:	66 89 83 8c a1 08 00 	mov    %ax,0x8a18c(%ebx)
  101567:	c1 e8 10             	shr    $0x10,%eax
  10156a:	66 89 83 92 a1 08 00 	mov    %ax,0x8a192(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_KBD],          0, CPU_GDT_KCODE, &Xirq_kbd,        0);
  101571:	c7 c0 fe 21 10 00    	mov    $0x1021fe,%eax
    SETGATE(idt[T_IRQ0 + IRQ_SERIAL13],     0, CPU_GDT_KCODE, &Xirq_serial1,    0);
  101577:	66 89 8b b2 a1 08 00 	mov    %cx,0x8a1b2(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_KBD],          0, CPU_GDT_KCODE, &Xirq_kbd,        0);
  10157e:	66 89 83 94 a1 08 00 	mov    %ax,0x8a194(%ebx)
  101585:	c1 e8 10             	shr    $0x10,%eax
  101588:	66 89 83 9a a1 08 00 	mov    %ax,0x8a19a(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_SLAVE],        0, CPU_GDT_KCODE, &Xirq_slave,      0);
  10158f:	c7 c0 04 22 10 00    	mov    $0x102204,%eax
    SETGATE(idt[T_IRQ0 + IRQ_TIMER],        0, CPU_GDT_KCODE, &Xirq_timer,      0);
  101595:	c7 83 8e a1 08 00 08 	movl   $0x8e000008,0x8a18e(%ebx)
  10159c:	00 00 8e 
    SETGATE(idt[T_IRQ0 + IRQ_SLAVE],        0, CPU_GDT_KCODE, &Xirq_slave,      0);
  10159f:	66 89 83 9c a1 08 00 	mov    %ax,0x8a19c(%ebx)
  1015a6:	c1 e8 10             	shr    $0x10,%eax
  1015a9:	66 89 83 a2 a1 08 00 	mov    %ax,0x8a1a2(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_SERIAL24],     0, CPU_GDT_KCODE, &Xirq_serial2,    0);
  1015b0:	c7 c0 0a 22 10 00    	mov    $0x10220a,%eax
    SETGATE(idt[T_IRQ0 + IRQ_KBD],          0, CPU_GDT_KCODE, &Xirq_kbd,        0);
  1015b6:	c7 83 96 a1 08 00 08 	movl   $0x8e000008,0x8a196(%ebx)
  1015bd:	00 00 8e 
    SETGATE(idt[T_IRQ0 + IRQ_SERIAL24],     0, CPU_GDT_KCODE, &Xirq_serial2,    0);
  1015c0:	66 89 83 a4 a1 08 00 	mov    %ax,0x8a1a4(%ebx)
  1015c7:	c1 e8 10             	shr    $0x10,%eax
  1015ca:	66 89 83 aa a1 08 00 	mov    %ax,0x8a1aa(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_SERIAL13],     0, CPU_GDT_KCODE, &Xirq_serial1,    0);
  1015d1:	8b 83 ae a1 08 00    	mov    0x8a1ae(%ebx),%eax
    SETGATE(idt[T_IRQ0 + IRQ_SLAVE],        0, CPU_GDT_KCODE, &Xirq_slave,      0);
  1015d7:	c7 83 9e a1 08 00 08 	movl   $0x8e000008,0x8a19e(%ebx)
  1015de:	00 00 8e 
    SETGATE(idt[T_IRQ0 + IRQ_SERIAL24],     0, CPU_GDT_KCODE, &Xirq_serial2,    0);
  1015e1:	c7 83 a6 a1 08 00 08 	movl   $0x8e000008,0x8a1a6(%ebx)
  1015e8:	00 00 8e 
    SETGATE(idt[T_IRQ0 + IRQ_SERIAL13],     0, CPU_GDT_KCODE, &Xirq_serial1,    0);
  1015eb:	25 00 00 e0 ff       	and    $0xffe00000,%eax
    SETGATE(idt[T_IRQ0 + IRQ_LPT2],         0, CPU_GDT_KCODE, &Xirq_lpt,        0);
  1015f0:	c7 83 b6 a1 08 00 08 	movl   $0x8e000008,0x8a1b6(%ebx)
  1015f7:	00 00 8e 
    SETGATE(idt[T_IRQ0 + IRQ_SERIAL13],     0, CPU_GDT_KCODE, &Xirq_serial1,    0);
  1015fa:	83 c8 08             	or     $0x8,%eax
  1015fd:	89 83 ae a1 08 00    	mov    %eax,0x8a1ae(%ebx)
  101603:	0f b7 83 b0 a1 08 00 	movzwl 0x8a1b0(%ebx),%eax
  10160a:	83 e0 1f             	and    $0x1f,%eax
  10160d:	66 0d 00 8e          	or     $0x8e00,%ax
  101611:	66 89 83 b0 a1 08 00 	mov    %ax,0x8a1b0(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_LPT2],         0, CPU_GDT_KCODE, &Xirq_lpt,        0);
  101618:	c7 c0 16 22 10 00    	mov    $0x102216,%eax
  10161e:	66 89 83 b4 a1 08 00 	mov    %ax,0x8a1b4(%ebx)
  101625:	c1 e8 10             	shr    $0x10,%eax
  101628:	66 89 83 ba a1 08 00 	mov    %ax,0x8a1ba(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_FLOPPY],       0, CPU_GDT_KCODE, &Xirq_floppy,     0);
  10162f:	c7 c0 1c 22 10 00    	mov    $0x10221c,%eax
  101635:	66 89 83 bc a1 08 00 	mov    %ax,0x8a1bc(%ebx)
  10163c:	c1 e8 10             	shr    $0x10,%eax
    SETGATE(idt[T_IRQ0 + 11],               0, CPU_GDT_KCODE, &Xirq11,          0);
  10163f:	c7 c1 3a 22 10 00    	mov    $0x10223a,%ecx
    SETGATE(idt[T_IRQ0 + IRQ_FLOPPY],       0, CPU_GDT_KCODE, &Xirq_floppy,     0);
  101645:	66 89 83 c2 a1 08 00 	mov    %ax,0x8a1c2(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_SPURIOUS],     0, CPU_GDT_KCODE, &Xirq_spurious,   0);
  10164c:	c7 c0 22 22 10 00    	mov    $0x102222,%eax
    SETGATE(idt[T_IRQ0 + 11],               0, CPU_GDT_KCODE, &Xirq11,          0);
  101652:	66 89 8b e4 a1 08 00 	mov    %cx,0x8a1e4(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_SPURIOUS],     0, CPU_GDT_KCODE, &Xirq_spurious,   0);
  101659:	66 89 83 c4 a1 08 00 	mov    %ax,0x8a1c4(%ebx)
  101660:	c1 e8 10             	shr    $0x10,%eax
  101663:	66 89 83 ca a1 08 00 	mov    %ax,0x8a1ca(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_RTC],          0, CPU_GDT_KCODE, &Xirq_rtc,        0);
  10166a:	c7 c0 28 22 10 00    	mov    $0x102228,%eax
    SETGATE(idt[T_IRQ0 + IRQ_FLOPPY],       0, CPU_GDT_KCODE, &Xirq_floppy,     0);
  101670:	c7 83 be a1 08 00 08 	movl   $0x8e000008,0x8a1be(%ebx)
  101677:	00 00 8e 
    SETGATE(idt[T_IRQ0 + IRQ_RTC],          0, CPU_GDT_KCODE, &Xirq_rtc,        0);
  10167a:	66 89 83 cc a1 08 00 	mov    %ax,0x8a1cc(%ebx)
  101681:	c1 e8 10             	shr    $0x10,%eax
  101684:	66 89 83 d2 a1 08 00 	mov    %ax,0x8a1d2(%ebx)
    SETGATE(idt[T_IRQ0 + 9],                0, CPU_GDT_KCODE, &Xirq9,           0);
  10168b:	c7 c0 2e 22 10 00    	mov    $0x10222e,%eax
    SETGATE(idt[T_IRQ0 + IRQ_SPURIOUS],     0, CPU_GDT_KCODE, &Xirq_spurious,   0);
  101691:	c7 83 c6 a1 08 00 08 	movl   $0x8e000008,0x8a1c6(%ebx)
  101698:	00 00 8e 
    SETGATE(idt[T_IRQ0 + 9],                0, CPU_GDT_KCODE, &Xirq9,           0);
  10169b:	66 89 83 d4 a1 08 00 	mov    %ax,0x8a1d4(%ebx)
  1016a2:	c1 e8 10             	shr    $0x10,%eax
  1016a5:	66 89 83 da a1 08 00 	mov    %ax,0x8a1da(%ebx)
    SETGATE(idt[T_IRQ0 + 10],               0, CPU_GDT_KCODE, &Xirq10,          0);
  1016ac:	c7 c0 34 22 10 00    	mov    $0x102234,%eax
    SETGATE(idt[T_IRQ0 + IRQ_RTC],          0, CPU_GDT_KCODE, &Xirq_rtc,        0);
  1016b2:	c7 83 ce a1 08 00 08 	movl   $0x8e000008,0x8a1ce(%ebx)
  1016b9:	00 00 8e 
    SETGATE(idt[T_IRQ0 + 10],               0, CPU_GDT_KCODE, &Xirq10,          0);
  1016bc:	66 89 83 dc a1 08 00 	mov    %ax,0x8a1dc(%ebx)
  1016c3:	c1 e8 10             	shr    $0x10,%eax
  1016c6:	66 89 83 e2 a1 08 00 	mov    %ax,0x8a1e2(%ebx)
    SETGATE(idt[T_IRQ0 + 11],               0, CPU_GDT_KCODE, &Xirq11,          0);
  1016cd:	8b 83 e6 a1 08 00    	mov    0x8a1e6(%ebx),%eax
    SETGATE(idt[T_IRQ0 + 9],                0, CPU_GDT_KCODE, &Xirq9,           0);
  1016d3:	c7 83 d6 a1 08 00 08 	movl   $0x8e000008,0x8a1d6(%ebx)
  1016da:	00 00 8e 
    SETGATE(idt[T_IRQ0 + 10],               0, CPU_GDT_KCODE, &Xirq10,          0);
  1016dd:	c7 83 de a1 08 00 08 	movl   $0x8e000008,0x8a1de(%ebx)
  1016e4:	00 00 8e 
    SETGATE(idt[T_IRQ0 + 11],               0, CPU_GDT_KCODE, &Xirq11,          0);
  1016e7:	25 00 00 00 ff       	and    $0xff000000,%eax
  1016ec:	c1 e9 10             	shr    $0x10,%ecx
  1016ef:	83 c8 08             	or     $0x8,%eax
  1016f2:	66 89 8b ea a1 08 00 	mov    %cx,0x8a1ea(%ebx)
  1016f9:	89 83 e6 a1 08 00    	mov    %eax,0x8a1e6(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_MOUSE],        0, CPU_GDT_KCODE, &Xirq_mouse,      0);
  1016ff:	c7 c0 40 22 10 00    	mov    $0x102240,%eax
    SETGATE(idt[T_IRQ0 + 11],               0, CPU_GDT_KCODE, &Xirq11,          0);
  101705:	c6 83 e9 a1 08 00 8e 	movb   $0x8e,0x8a1e9(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_MOUSE],        0, CPU_GDT_KCODE, &Xirq_mouse,      0);
  10170c:	66 89 83 ec a1 08 00 	mov    %ax,0x8a1ec(%ebx)
  101713:	c1 e8 10             	shr    $0x10,%eax
  101716:	66 89 83 f2 a1 08 00 	mov    %ax,0x8a1f2(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_COPROCESSOR],  0, CPU_GDT_KCODE, &Xirq_coproc,     0);
  10171d:	c7 c0 46 22 10 00    	mov    $0x102246,%eax
    SETGATE(idt[T_IRQ0 + IRQ_MOUSE],        0, CPU_GDT_KCODE, &Xirq_mouse,      0);
  101723:	c7 83 ee a1 08 00 08 	movl   $0x8e000008,0x8a1ee(%ebx)
  10172a:	00 00 8e 
    SETGATE(idt[T_IRQ0 + IRQ_COPROCESSOR],  0, CPU_GDT_KCODE, &Xirq_coproc,     0);
  10172d:	66 89 83 f4 a1 08 00 	mov    %ax,0x8a1f4(%ebx)
  101734:	c1 e8 10             	shr    $0x10,%eax
  101737:	c7 83 f6 a1 08 00 08 	movl   $0x8e000008,0x8a1f6(%ebx)
  10173e:	00 00 8e 
  101741:	66 89 83 fa a1 08 00 	mov    %ax,0x8a1fa(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_IDE1],         0, CPU_GDT_KCODE, &Xirq_ide1,       0);
  101748:	c7 c0 4c 22 10 00    	mov    $0x10224c,%eax
  10174e:	c7 83 fe a1 08 00 08 	movl   $0x8e000008,0x8a1fe(%ebx)
  101755:	00 00 8e 
  101758:	66 89 83 fc a1 08 00 	mov    %ax,0x8a1fc(%ebx)
  10175f:	c1 e8 10             	shr    $0x10,%eax
  101762:	66 89 83 02 a2 08 00 	mov    %ax,0x8a202(%ebx)
    SETGATE(idt[T_IRQ0 + IRQ_IDE2],         0, CPU_GDT_KCODE, &Xirq_ide2,       0);
  101769:	c7 c0 52 22 10 00    	mov    $0x102252,%eax
  10176f:	c7 83 06 a2 08 00 08 	movl   $0x8e000008,0x8a206(%ebx)
  101776:	00 00 8e 
  101779:	66 89 83 04 a2 08 00 	mov    %ax,0x8a204(%ebx)
  101780:	c1 e8 10             	shr    $0x10,%eax
  101783:	66 89 83 0a a2 08 00 	mov    %ax,0x8a20a(%ebx)
    SETGATE(idt[T_SYSCALL], 0, CPU_GDT_KCODE, &Xsyscall, 3);
  10178a:	c7 c0 58 22 10 00    	mov    $0x102258,%eax
  101790:	c7 83 0e a2 08 00 08 	movl   $0xee000008,0x8a20e(%ebx)
  101797:	00 00 ee 
  10179a:	66 89 83 0c a2 08 00 	mov    %ax,0x8a20c(%ebx)
  1017a1:	c1 e8 10             	shr    $0x10,%eax
  1017a4:	66 89 83 12 a2 08 00 	mov    %ax,0x8a212(%ebx)
    SETGATE(idt[T_DEFAULT], 0, CPU_GDT_KCODE, &Xdefault, 0);
  1017ab:	0f b7 44 24 08       	movzwl 0x8(%esp),%eax
  1017b0:	c7 83 7e a8 08 00 08 	movl   $0x8e000008,0x8a87e(%ebx)
  1017b7:	00 00 8e 
  1017ba:	66 89 83 7c a8 08 00 	mov    %ax,0x8a87c(%ebx)
    if (using_apic)
  1017c1:	0f b6 83 8c a8 08 00 	movzbl 0x8a88c(%ebx),%eax
    SETGATE(idt[T_DEFAULT], 0, CPU_GDT_KCODE, &Xdefault, 0);
  1017c8:	66 89 93 82 a8 08 00 	mov    %dx,0x8a882(%ebx)
    if (using_apic)
  1017cf:	84 c0                	test   %al,%al
  1017d1:	0f 84 b3 fa ff ff    	je     10128a <intr_init+0x7a>
  1017d7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1017de:	00 
  1017df:	90                   	nop
        lapic_init();
  1017e0:	e8 fb 0d 00 00       	call   1025e0 <lapic_init>
  1017e5:	e9 a0 fa ff ff       	jmp    10128a <intr_init+0x7a>
  1017ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001017f0 <intr_enable>:

void intr_enable(uint8_t irq, int cpunum)
{
  1017f0:	57                   	push   %edi
  1017f1:	56                   	push   %esi
  1017f2:	53                   	push   %ebx
  1017f3:	8b 7c 24 14          	mov    0x14(%esp),%edi
  1017f7:	e8 a6 eb ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1017fc:	81 c3 f8 57 01 00    	add    $0x157f8,%ebx
  101802:	8b 74 24 10          	mov    0x10(%esp),%esi
    KERN_ASSERT(cpunum == 0xff || (0 <= cpunum && cpunum < pcpu_ncpu()));
  101806:	81 ff ff 00 00 00    	cmp    $0xff,%edi
  10180c:	74 62                	je     101870 <intr_enable+0x80>
  10180e:	85 ff                	test   %edi,%edi
  101810:	78 0d                	js     10181f <intr_enable+0x2f>
  101812:	e8 b9 22 00 00       	call   103ad0 <pcpu_ncpu>
  101817:	39 c7                	cmp    %eax,%edi
  101819:	0f 82 81 00 00 00    	jb     1018a0 <intr_enable+0xb0>
  10181f:	8d 83 00 6d ff ff    	lea    -0x9300(%ebx),%eax
  101825:	50                   	push   %eax
  101826:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  10182c:	50                   	push   %eax
  10182d:	8d 83 83 61 ff ff    	lea    -0x9e7d(%ebx),%eax
  101833:	6a 7a                	push   $0x7a
  101835:	50                   	push   %eax
  101836:	e8 b5 2f 00 00       	call   1047f0 <debug_panic>

    if (irq >= 24)
  10183b:	89 f0                	mov    %esi,%eax
  10183d:	83 c4 10             	add    $0x10,%esp
  101840:	3c 17                	cmp    $0x17,%al
  101842:	77 22                	ja     101866 <intr_enable+0x76>
        return;

    if (using_apic == TRUE) {
  101844:	0f b6 83 8c a8 08 00 	movzbl 0x8a88c(%ebx),%eax
  10184b:	3c 01                	cmp    $0x1,%al
  10184d:	74 62                	je     1018b1 <intr_enable+0xc1>
        ioapic_enable(irq, (cpunum == 0xff) ?  0xff : pcpu_cpu_lapicid(cpunum), 0, 0);
    } else {
        KERN_ASSERT(irq < 16);
  10184f:	89 f0                	mov    %esi,%eax
  101851:	3c 0f                	cmp    $0xf,%al
  101853:	77 73                	ja     1018c8 <intr_enable+0xd8>
        pic_enable(irq);
  101855:	89 f0                	mov    %esi,%eax
  101857:	83 ec 0c             	sub    $0xc,%esp
  10185a:	0f b6 f0             	movzbl %al,%esi
  10185d:	56                   	push   %esi
  10185e:	e8 dd 02 00 00       	call   101b40 <pic_enable>
  101863:	83 c4 10             	add    $0x10,%esp
    }
}
  101866:	5b                   	pop    %ebx
  101867:	5e                   	pop    %esi
  101868:	5f                   	pop    %edi
  101869:	c3                   	ret
  10186a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    if (irq >= 24)
  101870:	89 f0                	mov    %esi,%eax
  101872:	3c 17                	cmp    $0x17,%al
  101874:	77 f0                	ja     101866 <intr_enable+0x76>
    if (using_apic == TRUE) {
  101876:	0f b6 83 8c a8 08 00 	movzbl 0x8a88c(%ebx),%eax
  10187d:	3c 01                	cmp    $0x1,%al
  10187f:	75 ce                	jne    10184f <intr_enable+0x5f>
        ioapic_enable(irq, (cpunum == 0xff) ?  0xff : pcpu_cpu_lapicid(cpunum), 0, 0);
  101881:	89 f0                	mov    %esi,%eax
  101883:	6a 00                	push   $0x0
  101885:	0f b6 f0             	movzbl %al,%esi
  101888:	6a 00                	push   $0x0
  10188a:	57                   	push   %edi
  10188b:	56                   	push   %esi
  10188c:	e8 ff 13 00 00       	call   102c90 <ioapic_enable>
  101891:	83 c4 10             	add    $0x10,%esp
}
  101894:	5b                   	pop    %ebx
  101895:	5e                   	pop    %esi
  101896:	5f                   	pop    %edi
  101897:	c3                   	ret
  101898:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10189f:	00 
    if (irq >= 24)
  1018a0:	89 f0                	mov    %esi,%eax
  1018a2:	3c 17                	cmp    $0x17,%al
  1018a4:	77 c0                	ja     101866 <intr_enable+0x76>
    if (using_apic == TRUE) {
  1018a6:	0f b6 83 8c a8 08 00 	movzbl 0x8a88c(%ebx),%eax
  1018ad:	3c 01                	cmp    $0x1,%al
  1018af:	75 9e                	jne    10184f <intr_enable+0x5f>
        ioapic_enable(irq, (cpunum == 0xff) ?  0xff : pcpu_cpu_lapicid(cpunum), 0, 0);
  1018b1:	83 ec 0c             	sub    $0xc,%esp
  1018b4:	57                   	push   %edi
  1018b5:	e8 a6 22 00 00       	call   103b60 <pcpu_cpu_lapicid>
  1018ba:	83 c4 10             	add    $0x10,%esp
  1018bd:	0f b6 f8             	movzbl %al,%edi
  1018c0:	eb bf                	jmp    101881 <intr_enable+0x91>
  1018c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        KERN_ASSERT(irq < 16);
  1018c8:	8d 83 93 61 ff ff    	lea    -0x9e6d(%ebx),%eax
  1018ce:	50                   	push   %eax
  1018cf:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  1018d5:	50                   	push   %eax
  1018d6:	8d 83 83 61 ff ff    	lea    -0x9e7d(%ebx),%eax
  1018dc:	68 82 00 00 00       	push   $0x82
  1018e1:	50                   	push   %eax
  1018e2:	e8 09 2f 00 00       	call   1047f0 <debug_panic>
  1018e7:	83 c4 10             	add    $0x10,%esp
  1018ea:	e9 66 ff ff ff       	jmp    101855 <intr_enable+0x65>
  1018ef:	90                   	nop

001018f0 <intr_enable_lapicid>:

void intr_enable_lapicid(uint8_t irq, int lapic_id)
{
  1018f0:	56                   	push   %esi
  1018f1:	53                   	push   %ebx
  1018f2:	e8 ab ea ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1018f7:	81 c3 fd 56 01 00    	add    $0x156fd,%ebx
  1018fd:	83 ec 04             	sub    $0x4,%esp
  101900:	8b 44 24 10          	mov    0x10(%esp),%eax
    if (irq > 24)
  101904:	3c 18                	cmp    $0x18,%al
  101906:	77 1f                	ja     101927 <intr_enable_lapicid+0x37>
        return;

    if (using_apic == TRUE) {
  101908:	0f b6 93 8c a8 08 00 	movzbl 0x8a88c(%ebx),%edx
        ioapic_enable(irq, (lapic_id == 0xff) ?  0xff : lapic_id, 0, 0);
  10190f:	0f b6 f0             	movzbl %al,%esi
    if (using_apic == TRUE) {
  101912:	80 fa 01             	cmp    $0x1,%dl
  101915:	74 41                	je     101958 <intr_enable_lapicid+0x68>
    } else {
        KERN_ASSERT(irq < 16);
  101917:	3c 0f                	cmp    $0xf,%al
  101919:	77 15                	ja     101930 <intr_enable_lapicid+0x40>
        pic_enable(irq);
  10191b:	83 ec 0c             	sub    $0xc,%esp
  10191e:	56                   	push   %esi
  10191f:	e8 1c 02 00 00       	call   101b40 <pic_enable>
  101924:	83 c4 10             	add    $0x10,%esp
    }
}
  101927:	83 c4 04             	add    $0x4,%esp
  10192a:	5b                   	pop    %ebx
  10192b:	5e                   	pop    %esi
  10192c:	c3                   	ret
  10192d:	8d 76 00             	lea    0x0(%esi),%esi
        KERN_ASSERT(irq < 16);
  101930:	8d 83 93 61 ff ff    	lea    -0x9e6d(%ebx),%eax
  101936:	50                   	push   %eax
  101937:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  10193d:	50                   	push   %eax
  10193e:	8d 83 83 61 ff ff    	lea    -0x9e7d(%ebx),%eax
  101944:	68 8f 00 00 00       	push   $0x8f
  101949:	50                   	push   %eax
  10194a:	e8 a1 2e 00 00       	call   1047f0 <debug_panic>
  10194f:	83 c4 10             	add    $0x10,%esp
  101952:	eb c7                	jmp    10191b <intr_enable_lapicid+0x2b>
  101954:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        ioapic_enable(irq, (lapic_id == 0xff) ?  0xff : lapic_id, 0, 0);
  101958:	6a 00                	push   $0x0
  10195a:	6a 00                	push   $0x0
  10195c:	0f b6 44 24 1c       	movzbl 0x1c(%esp),%eax
  101961:	50                   	push   %eax
  101962:	56                   	push   %esi
  101963:	e8 28 13 00 00       	call   102c90 <ioapic_enable>
  101968:	83 c4 10             	add    $0x10,%esp
}
  10196b:	83 c4 04             	add    $0x4,%esp
  10196e:	5b                   	pop    %ebx
  10196f:	5e                   	pop    %esi
  101970:	c3                   	ret
  101971:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  101978:	00 
  101979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00101980 <intr_eoi>:

void intr_eoi(void)
{
  101980:	53                   	push   %ebx
  101981:	e8 1c ea ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  101986:	81 c3 6e 56 01 00    	add    $0x1566e,%ebx
  10198c:	83 ec 08             	sub    $0x8,%esp
    if (using_apic == TRUE)
  10198f:	0f b6 83 8c a8 08 00 	movzbl 0x8a88c(%ebx),%eax
  101996:	3c 01                	cmp    $0x1,%al
  101998:	74 0e                	je     1019a8 <intr_eoi+0x28>
        lapic_eoi();
    else
        pic_eoi();
  10199a:	e8 f1 01 00 00       	call   101b90 <pic_eoi>
}
  10199f:	83 c4 08             	add    $0x8,%esp
  1019a2:	5b                   	pop    %ebx
  1019a3:	c3                   	ret
  1019a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        lapic_eoi();
  1019a8:	e8 23 0f 00 00       	call   1028d0 <lapic_eoi>
}
  1019ad:	83 c4 08             	add    $0x8,%esp
  1019b0:	5b                   	pop    %ebx
  1019b1:	c3                   	ret
  1019b2:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1019b9:	00 
  1019ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001019c0 <intr_local_enable>:

void intr_local_enable(void)
{
  1019c0:	53                   	push   %ebx
  1019c1:	e8 dc e9 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1019c6:	81 c3 2e 56 01 00    	add    $0x1562e,%ebx
  1019cc:	83 ec 08             	sub    $0x8,%esp
    sti();
  1019cf:	e8 2c 3a 00 00       	call   105400 <sti>
}
  1019d4:	83 c4 08             	add    $0x8,%esp
  1019d7:	5b                   	pop    %ebx
  1019d8:	c3                   	ret
  1019d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001019e0 <intr_local_disable>:

void intr_local_disable(void)
{
  1019e0:	53                   	push   %ebx
  1019e1:	e8 bc e9 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1019e6:	81 c3 0e 56 01 00    	add    $0x1560e,%ebx
  1019ec:	83 ec 08             	sub    $0x8,%esp
    cli();
  1019ef:	e8 fc 39 00 00       	call   1053f0 <cli>
}
  1019f4:	83 c4 08             	add    $0x8,%esp
  1019f7:	5b                   	pop    %ebx
  1019f8:	c3                   	ret
  1019f9:	66 90                	xchg   %ax,%ax
  1019fb:	66 90                	xchg   %ax,%ax
  1019fd:	66 90                	xchg   %ax,%ax
  1019ff:	90                   	nop

00101a00 <pic_init>:
static uint16_t irqmask = 0xFFFF & ~(1 << IRQ_SLAVE);
static bool pic_inited = FALSE;

/* Initialize the 8259A interrupt controllers. */
void pic_init(void)
{
  101a00:	53                   	push   %ebx
  101a01:	e8 9c e9 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  101a06:	81 c3 ee 55 01 00    	add    $0x155ee,%ebx
  101a0c:	83 ec 08             	sub    $0x8,%esp
    if (pic_inited == TRUE)  // only do once on bootstrap CPU
  101a0f:	80 bb 8d a8 08 00 01 	cmpb   $0x1,0x8a88d(%ebx)
  101a16:	0f 84 df 00 00 00    	je     101afb <pic_init+0xfb>
        return;
    pic_inited = TRUE;

    /* mask all interrupts */
    outb(IO_PIC1 + 1, 0xff);
  101a1c:	83 ec 08             	sub    $0x8,%esp
    pic_inited = TRUE;
  101a1f:	c6 83 8d a8 08 00 01 	movb   $0x1,0x8a88d(%ebx)
    outb(IO_PIC1 + 1, 0xff);
  101a26:	68 ff 00 00 00       	push   $0xff
  101a2b:	6a 21                	push   $0x21
  101a2d:	e8 ee 3b 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, 0xff);
  101a32:	58                   	pop    %eax
  101a33:	5a                   	pop    %edx
  101a34:	68 ff 00 00 00       	push   $0xff
  101a39:	68 a1 00 00 00       	push   $0xa1
  101a3e:	e8 dd 3b 00 00       	call   105620 <outb>

    // ICW1:  0001g0hi
    //    g:  0 = edge triggering, 1 = level triggering
    //    h:  0 = cascaded PICs, 1 = master only
    //    i:  0 = no ICW4, 1 = ICW4 required
    outb(IO_PIC1, 0x11);
  101a43:	59                   	pop    %ecx
  101a44:	58                   	pop    %eax
  101a45:	6a 11                	push   $0x11
  101a47:	6a 20                	push   $0x20
  101a49:	e8 d2 3b 00 00       	call   105620 <outb>

    // ICW2:  Vector offset
    outb(IO_PIC1 + 1, T_IRQ0);
  101a4e:	58                   	pop    %eax
  101a4f:	5a                   	pop    %edx
  101a50:	6a 20                	push   $0x20
  101a52:	6a 21                	push   $0x21
  101a54:	e8 c7 3b 00 00       	call   105620 <outb>

    // ICW3:  bit mask of IR lines connected to slave PICs (master PIC),
    //        3-bit No of IR line at which slave connects to master (slave PIC).
    outb(IO_PIC1 + 1, 1 << IRQ_SLAVE);
  101a59:	59                   	pop    %ecx
  101a5a:	58                   	pop    %eax
  101a5b:	6a 04                	push   $0x4
  101a5d:	6a 21                	push   $0x21
  101a5f:	e8 bc 3b 00 00       	call   105620 <outb>
    //    m:  0 = slave PIC, 1 = master PIC
    //        (ignored when b is 0, as the master/slave role
    //        can be hardwired).
    //    a:  1 = Automatic EOI mode
    //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
    outb(IO_PIC1 + 1, 0x1);
  101a64:	58                   	pop    %eax
  101a65:	5a                   	pop    %edx
  101a66:	6a 01                	push   $0x1
  101a68:	6a 21                	push   $0x21
  101a6a:	e8 b1 3b 00 00       	call   105620 <outb>

    // Set up slave (8259A-2)
    outb(IO_PIC2, 0x11);            // ICW1
  101a6f:	59                   	pop    %ecx
  101a70:	58                   	pop    %eax
  101a71:	6a 11                	push   $0x11
  101a73:	68 a0 00 00 00       	push   $0xa0
  101a78:	e8 a3 3b 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, T_IRQ0 + 8);  // ICW2
  101a7d:	58                   	pop    %eax
  101a7e:	5a                   	pop    %edx
  101a7f:	6a 28                	push   $0x28
  101a81:	68 a1 00 00 00       	push   $0xa1
  101a86:	e8 95 3b 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, IRQ_SLAVE);   // ICW3
  101a8b:	59                   	pop    %ecx
  101a8c:	58                   	pop    %eax
  101a8d:	6a 02                	push   $0x2
  101a8f:	68 a1 00 00 00       	push   $0xa1
  101a94:	e8 87 3b 00 00       	call   105620 <outb>
    // NB Automatic EOI mode doesn't tend to work on the slave.
    // Linux source code says it's "to be investigated".
    outb(IO_PIC2 + 1, 0x01);        // ICW4
  101a99:	58                   	pop    %eax
  101a9a:	5a                   	pop    %edx
  101a9b:	6a 01                	push   $0x1
  101a9d:	68 a1 00 00 00       	push   $0xa1
  101aa2:	e8 79 3b 00 00       	call   105620 <outb>

    // OCW3:  0ef01prs
    //   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
    //    p:  0 = no polling, 1 = polling mode
    //   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
    outb(IO_PIC1, 0x68);  /* clear specific mask */
  101aa7:	59                   	pop    %ecx
  101aa8:	58                   	pop    %eax
  101aa9:	6a 68                	push   $0x68
  101aab:	6a 20                	push   $0x20
  101aad:	e8 6e 3b 00 00       	call   105620 <outb>
    outb(IO_PIC1, 0x0a);  /* read IRR by default */
  101ab2:	58                   	pop    %eax
  101ab3:	5a                   	pop    %edx
  101ab4:	6a 0a                	push   $0xa
  101ab6:	6a 20                	push   $0x20
  101ab8:	e8 63 3b 00 00       	call   105620 <outb>

    outb(IO_PIC2, 0x68);  /* OCW3 */
  101abd:	59                   	pop    %ecx
  101abe:	58                   	pop    %eax
  101abf:	6a 68                	push   $0x68
  101ac1:	68 a0 00 00 00       	push   $0xa0
  101ac6:	e8 55 3b 00 00       	call   105620 <outb>
    outb(IO_PIC2, 0x0a);  /* OCW3 */
  101acb:	58                   	pop    %eax
  101acc:	5a                   	pop    %edx
  101acd:	6a 0a                	push   $0xa
  101acf:	68 a0 00 00 00       	push   $0xa0
  101ad4:	e8 47 3b 00 00       	call   105620 <outb>

    // mask all interrupts
    outb(IO_PIC1 + 1, 0xFF);
  101ad9:	59                   	pop    %ecx
  101ada:	58                   	pop    %eax
  101adb:	68 ff 00 00 00       	push   $0xff
  101ae0:	6a 21                	push   $0x21
  101ae2:	e8 39 3b 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, 0xFF);
  101ae7:	58                   	pop    %eax
  101ae8:	5a                   	pop    %edx
  101ae9:	68 ff 00 00 00       	push   $0xff
  101aee:	68 a1 00 00 00       	push   $0xa1
  101af3:	e8 28 3b 00 00       	call   105620 <outb>
  101af8:	83 c4 10             	add    $0x10,%esp
}
  101afb:	83 c4 08             	add    $0x8,%esp
  101afe:	5b                   	pop    %ebx
  101aff:	c3                   	ret

00101b00 <pic_setmask>:

void pic_setmask(uint16_t mask)
{
  101b00:	56                   	push   %esi
  101b01:	53                   	push   %ebx
  101b02:	e8 9b e8 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  101b07:	81 c3 ed 54 01 00    	add    $0x154ed,%ebx
  101b0d:	83 ec 0c             	sub    $0xc,%esp
  101b10:	8b 74 24 18          	mov    0x18(%esp),%esi
    irqmask = mask;
    outb(IO_PIC1 + 1, (char) mask);
  101b14:	89 f0                	mov    %esi,%eax
  101b16:	0f b6 c0             	movzbl %al,%eax
    irqmask = mask;
  101b19:	66 89 b3 12 03 00 00 	mov    %si,0x312(%ebx)
    outb(IO_PIC1 + 1, (char) mask);
  101b20:	50                   	push   %eax
  101b21:	6a 21                	push   $0x21
  101b23:	e8 f8 3a 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, (char) (mask >> 8));
  101b28:	58                   	pop    %eax
  101b29:	89 f0                	mov    %esi,%eax
  101b2b:	5a                   	pop    %edx
  101b2c:	0f b6 f4             	movzbl %ah,%esi
  101b2f:	56                   	push   %esi
  101b30:	68 a1 00 00 00       	push   $0xa1
  101b35:	e8 e6 3a 00 00       	call   105620 <outb>
}
  101b3a:	83 c4 14             	add    $0x14,%esp
  101b3d:	5b                   	pop    %ebx
  101b3e:	5e                   	pop    %esi
  101b3f:	c3                   	ret

00101b40 <pic_enable>:

void pic_enable(int irq)
{
  101b40:	56                   	push   %esi
  101b41:	53                   	push   %ebx
  101b42:	e8 5b e8 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  101b47:	81 c3 ad 54 01 00    	add    $0x154ad,%ebx
  101b4d:	83 ec 0c             	sub    $0xc,%esp
    pic_setmask(irqmask & ~(1 << irq));
  101b50:	8b 44 24 18          	mov    0x18(%esp),%eax
  101b54:	0f b7 b3 12 03 00 00 	movzwl 0x312(%ebx),%esi
  101b5b:	0f b3 c6             	btr    %eax,%esi
    outb(IO_PIC1 + 1, (char) mask);
  101b5e:	89 f0                	mov    %esi,%eax
    irqmask = mask;
  101b60:	66 89 b3 12 03 00 00 	mov    %si,0x312(%ebx)
    outb(IO_PIC1 + 1, (char) mask);
  101b67:	0f b6 c0             	movzbl %al,%eax
  101b6a:	50                   	push   %eax
  101b6b:	6a 21                	push   $0x21
  101b6d:	e8 ae 3a 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, (char) (mask >> 8));
  101b72:	58                   	pop    %eax
  101b73:	89 f0                	mov    %esi,%eax
  101b75:	5a                   	pop    %edx
  101b76:	0f b6 f4             	movzbl %ah,%esi
  101b79:	56                   	push   %esi
  101b7a:	68 a1 00 00 00       	push   $0xa1
  101b7f:	e8 9c 3a 00 00       	call   105620 <outb>
}
  101b84:	83 c4 14             	add    $0x14,%esp
  101b87:	5b                   	pop    %ebx
  101b88:	5e                   	pop    %esi
  101b89:	c3                   	ret
  101b8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00101b90 <pic_eoi>:

void pic_eoi(void)
{
  101b90:	53                   	push   %ebx
  101b91:	e8 0c e8 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  101b96:	81 c3 5e 54 01 00    	add    $0x1545e,%ebx
  101b9c:	83 ec 10             	sub    $0x10,%esp
    // OCW2: rse00xxx
    //   r: rotate
    //   s: specific
    //   e: end-of-interrupt
    // xxx: specific interrupt line
    outb(IO_PIC1, 0x20);
  101b9f:	6a 20                	push   $0x20
  101ba1:	6a 20                	push   $0x20
  101ba3:	e8 78 3a 00 00       	call   105620 <outb>
    outb(IO_PIC2, 0x20);
  101ba8:	58                   	pop    %eax
  101ba9:	5a                   	pop    %edx
  101baa:	6a 20                	push   $0x20
  101bac:	68 a0 00 00 00       	push   $0xa0
  101bb1:	e8 6a 3a 00 00       	call   105620 <outb>
}
  101bb6:	83 c4 18             	add    $0x18,%esp
  101bb9:	5b                   	pop    %ebx
  101bba:	c3                   	ret
  101bbb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00101bc0 <pic_reset>:

void pic_reset(void)
{
  101bc0:	53                   	push   %ebx
  101bc1:	e8 dc e7 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  101bc6:	81 c3 2e 54 01 00    	add    $0x1542e,%ebx
  101bcc:	83 ec 10             	sub    $0x10,%esp
    // mask all interrupts
    outb(IO_PIC1 + 1, 0x00);
  101bcf:	6a 00                	push   $0x0
  101bd1:	6a 21                	push   $0x21
  101bd3:	e8 48 3a 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, 0x00);
  101bd8:	58                   	pop    %eax
  101bd9:	5a                   	pop    %edx
  101bda:	6a 00                	push   $0x0
  101bdc:	68 a1 00 00 00       	push   $0xa1
  101be1:	e8 3a 3a 00 00       	call   105620 <outb>

    // ICW1:  0001g0hi
    //    g:  0 = edge triggering, 1 = level triggering
    //    h:  0 = cascaded PICs, 1 = master only
    //    i:  0 = no ICW4, 1 = ICW4 required
    outb(IO_PIC1, 0x11);
  101be6:	59                   	pop    %ecx
  101be7:	58                   	pop    %eax
  101be8:	6a 11                	push   $0x11
  101bea:	6a 20                	push   $0x20
  101bec:	e8 2f 3a 00 00       	call   105620 <outb>

    // ICW2:  Vector offset
    outb(IO_PIC1 + 1, T_IRQ0);
  101bf1:	58                   	pop    %eax
  101bf2:	5a                   	pop    %edx
  101bf3:	6a 20                	push   $0x20
  101bf5:	6a 21                	push   $0x21
  101bf7:	e8 24 3a 00 00       	call   105620 <outb>

    // ICW3:  bit mask of IR lines connected to slave PICs (master PIC),
    //        3-bit No of IR line at which slave connects to master(slave PIC).
    outb(IO_PIC1 + 1, 1 << IRQ_SLAVE);
  101bfc:	59                   	pop    %ecx
  101bfd:	58                   	pop    %eax
  101bfe:	6a 04                	push   $0x4
  101c00:	6a 21                	push   $0x21
  101c02:	e8 19 3a 00 00       	call   105620 <outb>
    //    m:  0 = slave PIC, 1 = master PIC
    //        (ignored when b is 0, as the master/slave role
    //        can be hardwired).
    //    a:  1 = Automatic EOI mode
    //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
    outb(IO_PIC1 + 1, 0x3);
  101c07:	58                   	pop    %eax
  101c08:	5a                   	pop    %edx
  101c09:	6a 03                	push   $0x3
  101c0b:	6a 21                	push   $0x21
  101c0d:	e8 0e 3a 00 00       	call   105620 <outb>

    // Set up slave (8259A-2)
    outb(IO_PIC2, 0x11);            // ICW1
  101c12:	59                   	pop    %ecx
  101c13:	58                   	pop    %eax
  101c14:	6a 11                	push   $0x11
  101c16:	68 a0 00 00 00       	push   $0xa0
  101c1b:	e8 00 3a 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, T_IRQ0 + 8);  // ICW2
  101c20:	58                   	pop    %eax
  101c21:	5a                   	pop    %edx
  101c22:	6a 28                	push   $0x28
  101c24:	68 a1 00 00 00       	push   $0xa1
  101c29:	e8 f2 39 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, IRQ_SLAVE);   // ICW3
  101c2e:	59                   	pop    %ecx
  101c2f:	58                   	pop    %eax
  101c30:	6a 02                	push   $0x2
  101c32:	68 a1 00 00 00       	push   $0xa1
  101c37:	e8 e4 39 00 00       	call   105620 <outb>
    // NB Automatic EOI mode doesn't tend to work on the slave.
    // Linux source code says it's "to be investigated".
    outb(IO_PIC2 + 1, 0x01);        // ICW4
  101c3c:	58                   	pop    %eax
  101c3d:	5a                   	pop    %edx
  101c3e:	6a 01                	push   $0x1
  101c40:	68 a1 00 00 00       	push   $0xa1
  101c45:	e8 d6 39 00 00       	call   105620 <outb>

    // OCW3:  0ef01prs
    //   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
    //    p:  0 = no polling, 1 = polling mode
    //   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
    outb(IO_PIC1, 0x68);  /* clear specific mask */
  101c4a:	59                   	pop    %ecx
  101c4b:	58                   	pop    %eax
  101c4c:	6a 68                	push   $0x68
  101c4e:	6a 20                	push   $0x20
  101c50:	e8 cb 39 00 00       	call   105620 <outb>
    outb(IO_PIC1, 0x0a);  /* read IRR by default */
  101c55:	58                   	pop    %eax
  101c56:	5a                   	pop    %edx
  101c57:	6a 0a                	push   $0xa
  101c59:	6a 20                	push   $0x20
  101c5b:	e8 c0 39 00 00       	call   105620 <outb>

    outb(IO_PIC2, 0x68);  /* OCW3 */
  101c60:	59                   	pop    %ecx
  101c61:	58                   	pop    %eax
  101c62:	6a 68                	push   $0x68
  101c64:	68 a0 00 00 00       	push   $0xa0
  101c69:	e8 b2 39 00 00       	call   105620 <outb>
    outb(IO_PIC2, 0x0a);  /* OCW3 */
  101c6e:	58                   	pop    %eax
  101c6f:	5a                   	pop    %edx
  101c70:	6a 0a                	push   $0xa
  101c72:	68 a0 00 00 00       	push   $0xa0
  101c77:	e8 a4 39 00 00       	call   105620 <outb>
}
  101c7c:	83 c4 18             	add    $0x18,%esp
  101c7f:	5b                   	pop    %ebx
  101c80:	c3                   	ret
  101c81:	66 90                	xchg   %ax,%ax
  101c83:	66 90                	xchg   %ax,%ax
  101c85:	66 90                	xchg   %ax,%ax
  101c87:	66 90                	xchg   %ax,%ax
  101c89:	66 90                	xchg   %ax,%ax
  101c8b:	66 90                	xchg   %ax,%ax
  101c8d:	66 90                	xchg   %ax,%ax
  101c8f:	90                   	nop

00101c90 <timer_hw_init>:
#define TIMER_16BIT   0x30  /* r/w counter 16 bits, LSB first */

// Initialize the programmable interval timer.

void timer_hw_init(void)
{
  101c90:	53                   	push   %ebx
  101c91:	e8 0c e7 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  101c96:	81 c3 5e 53 01 00    	add    $0x1535e,%ebx
  101c9c:	83 ec 10             	sub    $0x10,%esp
    outb(PIT_CONTROL, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
  101c9f:	6a 34                	push   $0x34
  101ca1:	6a 43                	push   $0x43
  101ca3:	e8 78 39 00 00       	call   105620 <outb>
    outb(PIT_CHANNEL0, LOW8(LATCH));
  101ca8:	58                   	pop    %eax
  101ca9:	5a                   	pop    %edx
  101caa:	68 9c 00 00 00       	push   $0x9c
  101caf:	6a 40                	push   $0x40
  101cb1:	e8 6a 39 00 00       	call   105620 <outb>
    outb(PIT_CHANNEL0, HIGH8(LATCH));
  101cb6:	59                   	pop    %ecx
  101cb7:	58                   	pop    %eax
  101cb8:	6a 2e                	push   $0x2e
  101cba:	6a 40                	push   $0x40
  101cbc:	e8 5f 39 00 00       	call   105620 <outb>
}
  101cc1:	83 c4 18             	add    $0x18,%esp
  101cc4:	5b                   	pop    %ebx
  101cc5:	c3                   	ret
  101cc6:	66 90                	xchg   %ax,%ax
  101cc8:	66 90                	xchg   %ax,%ax
  101cca:	66 90                	xchg   %ax,%ax
  101ccc:	66 90                	xchg   %ax,%ax
  101cce:	66 90                	xchg   %ax,%ax

00101cd0 <tsc_init>:
    delta = t2 - t1;
    return delta / ms;
}

int tsc_init(void)
{
  101cd0:	55                   	push   %ebp
  101cd1:	57                   	push   %edi
  101cd2:	56                   	push   %esi
  101cd3:	53                   	push   %ebx
  101cd4:	e8 c9 e6 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  101cd9:	81 c3 1b 53 01 00    	add    $0x1531b,%ebx
  101cdf:	83 ec 4c             	sub    $0x4c,%esp
    uint64_t ret;
    int i;

    timer_hw_init();
  101ce2:	e8 a9 ff ff ff       	call   101c90 <timer_hw_init>

    tsc_per_ms = 0;
  101ce7:	c7 83 94 a8 08 00 00 	movl   $0x0,0x8a894(%ebx)
  101cee:	00 00 00 
  101cf1:	c7 83 98 a8 08 00 00 	movl   $0x0,0x8a898(%ebx)
  101cf8:	00 00 00 

    if (detect_kvm())
  101cfb:	e8 e0 24 00 00       	call   1041e0 <detect_kvm>
  101d00:	85 c0                	test   %eax,%eax
  101d02:	0f 85 c6 02 00 00    	jne    101fce <tsc_init+0x2fe>
  101d08:	8d 83 5c 6d ff ff    	lea    -0x92a4(%ebx),%eax

    /*
     * XXX: If TSC calibration fails frequently, try to increase the
     *      upper bound of loop condition, e.g. alternating 3 to 10.
     */
    for (i = 0; i < 10; i++) {
  101d0e:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
  101d15:	00 
  101d16:	89 44 24 38          	mov    %eax,0x38(%esp)
  101d1a:	8d 83 9c 61 ff ff    	lea    -0x9e64(%ebx),%eax
  101d20:	89 44 24 2c          	mov    %eax,0x2c(%esp)
        ret = tsc_calibrate(CAL_LATCH, CAL_MS, CAL_PIT_LOOPS);
        if (ret != ~(uint64_t) 0x0)
            break;
        KERN_DEBUG("[%d] Retry to calibrate TSC.\n", i + 1);
  101d24:	8d 83 c4 61 ff ff    	lea    -0x9e3c(%ebx),%eax
  101d2a:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  101d2e:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  101d32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    outb(0x61, (inb(0x61) & ~0x02) | 0x01);
  101d38:	83 ec 0c             	sub    $0xc,%esp
  101d3b:	6a 61                	push   $0x61
  101d3d:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  101d41:	e8 aa 38 00 00       	call   1055f0 <inb>
  101d46:	5e                   	pop    %esi
  101d47:	5f                   	pop    %edi
    tscmin = ~(uint64_t) 0x0;
  101d48:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    outb(0x61, (inb(0x61) & ~0x02) | 0x01);
  101d4d:	25 fc 00 00 00       	and    $0xfc,%eax
  101d52:	83 c8 01             	or     $0x1,%eax
  101d55:	50                   	push   %eax
  101d56:	6a 61                	push   $0x61
  101d58:	e8 c3 38 00 00       	call   105620 <outb>
    outb(0x43, 0xb0);
  101d5d:	5d                   	pop    %ebp
  101d5e:	58                   	pop    %eax
  101d5f:	68 b0 00 00 00       	push   $0xb0
  101d64:	6a 43                	push   $0x43
    pitcnt = 0;
  101d66:	31 ed                	xor    %ebp,%ebp
    outb(0x43, 0xb0);
  101d68:	e8 b3 38 00 00       	call   105620 <outb>
    outb(0x42, latch & 0xff);
  101d6d:	58                   	pop    %eax
  101d6e:	5a                   	pop    %edx
  101d6f:	68 9b 00 00 00       	push   $0x9b
  101d74:	6a 42                	push   $0x42
  101d76:	e8 a5 38 00 00       	call   105620 <outb>
    outb(0x42, latch >> 8);
  101d7b:	59                   	pop    %ecx
  101d7c:	5e                   	pop    %esi
  101d7d:	6a 2e                	push   $0x2e
  101d7f:	6a 42                	push   $0x42
    tscmin = ~(uint64_t) 0x0;
  101d81:	be ff ff ff ff       	mov    $0xffffffff,%esi
    outb(0x42, latch >> 8);
  101d86:	e8 95 38 00 00       	call   105620 <outb>
    tsc = t1 = t2 = rdtsc();
  101d8b:	e8 f0 36 00 00       	call   105480 <rdtsc>
  101d90:	89 44 24 40          	mov    %eax,0x40(%esp)
  101d94:	89 54 24 44          	mov    %edx,0x44(%esp)
    while ((inb(0x61) & 0x20) == 0) {
  101d98:	83 c4 10             	add    $0x10,%esp
    tsc = t1 = t2 = rdtsc();
  101d9b:	89 44 24 18          	mov    %eax,0x18(%esp)
  101d9f:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    tscmax = 0;
  101da3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101daa:	00 
  101dab:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  101db2:	00 
    while ((inb(0x61) & 0x20) == 0) {
  101db3:	eb 63                	jmp    101e18 <tsc_init+0x148>
  101db5:	8d 76 00             	lea    0x0(%esi),%esi
        t2 = rdtsc();
  101db8:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  101dbc:	e8 bf 36 00 00       	call   105480 <rdtsc>
        delta = t2 - tsc;
  101dc1:	89 c1                	mov    %eax,%ecx
  101dc3:	89 d3                	mov    %edx,%ebx
  101dc5:	2b 4c 24 18          	sub    0x18(%esp),%ecx
  101dc9:	1b 5c 24 1c          	sbb    0x1c(%esp),%ebx
  101dcd:	89 44 24 20          	mov    %eax,0x20(%esp)
        if (delta < tscmin)
  101dd1:	39 f1                	cmp    %esi,%ecx
  101dd3:	89 d8                	mov    %ebx,%eax
  101dd5:	19 f8                	sbb    %edi,%eax
        delta = t2 - tsc;
  101dd7:	89 54 24 24          	mov    %edx,0x24(%esp)
        if (delta > tscmax)
  101ddb:	8b 44 24 08          	mov    0x8(%esp),%eax
  101ddf:	8b 54 24 0c          	mov    0xc(%esp),%edx
        if (delta < tscmin)
  101de3:	0f 42 f1             	cmovb  %ecx,%esi
  101de6:	0f 42 fb             	cmovb  %ebx,%edi
        if (delta > tscmax)
  101de9:	39 c8                	cmp    %ecx,%eax
  101deb:	89 d0                	mov    %edx,%eax
        tsc = t2;
  101ded:	8b 54 24 24          	mov    0x24(%esp),%edx
        if (delta > tscmax)
  101df1:	19 d8                	sbb    %ebx,%eax
  101df3:	8b 44 24 08          	mov    0x8(%esp),%eax
        tsc = t2;
  101df7:	89 54 24 1c          	mov    %edx,0x1c(%esp)
        if (delta > tscmax)
  101dfb:	0f 42 c1             	cmovb  %ecx,%eax
  101dfe:	89 44 24 08          	mov    %eax,0x8(%esp)
  101e02:	89 d8                	mov    %ebx,%eax
  101e04:	0f 43 44 24 0c       	cmovae 0xc(%esp),%eax
        pitcnt++;
  101e09:	83 c5 01             	add    $0x1,%ebp
        if (delta > tscmax)
  101e0c:	89 44 24 0c          	mov    %eax,0xc(%esp)
        tsc = t2;
  101e10:	8b 44 24 20          	mov    0x20(%esp),%eax
  101e14:	89 44 24 18          	mov    %eax,0x18(%esp)
    while ((inb(0x61) & 0x20) == 0) {
  101e18:	83 ec 0c             	sub    $0xc,%esp
  101e1b:	6a 61                	push   $0x61
  101e1d:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  101e21:	e8 ca 37 00 00       	call   1055f0 <inb>
  101e26:	83 c4 10             	add    $0x10,%esp
  101e29:	a8 20                	test   $0x20,%al
  101e2b:	74 8b                	je     101db8 <tsc_init+0xe8>
    KERN_DEBUG("pitcnt=%u, tscmin=%llu, tscmax=%llu\n",
  101e2d:	ff 74 24 0c          	push   0xc(%esp)
  101e31:	ff 74 24 0c          	push   0xc(%esp)
  101e35:	57                   	push   %edi
  101e36:	56                   	push   %esi
  101e37:	55                   	push   %ebp
  101e38:	ff 74 24 4c          	push   0x4c(%esp)
  101e3c:	6a 39                	push   $0x39
  101e3e:	ff 74 24 48          	push   0x48(%esp)
  101e42:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  101e46:	e8 45 29 00 00       	call   104790 <debug_normal>
    if (pitcnt < loopmin || tscmax > 10 * tscmin)
  101e4b:	83 c4 20             	add    $0x20,%esp
  101e4e:	81 fd e7 03 00 00    	cmp    $0x3e7,%ebp
  101e54:	0f 8e f6 00 00 00    	jle    101f50 <tsc_init+0x280>
  101e5a:	89 f0                	mov    %esi,%eax
  101e5c:	89 fa                	mov    %edi,%edx
  101e5e:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  101e62:	c1 e0 02             	shl    $0x2,%eax
  101e65:	0f a4 f2 02          	shld   $0x2,%esi,%edx
  101e69:	01 f0                	add    %esi,%eax
  101e6b:	11 fa                	adc    %edi,%edx
  101e6d:	8b 7c 24 08          	mov    0x8(%esp),%edi
  101e71:	0f a4 c2 01          	shld   $0x1,%eax,%edx
  101e75:	01 c0                	add    %eax,%eax
  101e77:	39 f8                	cmp    %edi,%eax
  101e79:	89 d0                	mov    %edx,%eax
  101e7b:	19 e8                	sbb    %ebp,%eax
  101e7d:	0f 82 cd 00 00 00    	jb     101f50 <tsc_init+0x280>
    delta = t2 - t1;
  101e83:	8b 74 24 18          	mov    0x18(%esp),%esi
  101e87:	2b 74 24 30          	sub    0x30(%esp),%esi
    return delta / ms;
  101e8b:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
    delta = t2 - t1;
  101e90:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
    return delta / ms;
  101e94:	89 f5                	mov    %esi,%ebp
    delta = t2 - t1;
  101e96:	1b 7c 24 34          	sbb    0x34(%esp),%edi
    return delta / ms;
  101e9a:	01 fd                	add    %edi,%ebp
  101e9c:	83 d5 00             	adc    $0x0,%ebp
  101e9f:	89 e8                	mov    %ebp,%eax
  101ea1:	f7 e1                	mul    %ecx
  101ea3:	89 d0                	mov    %edx,%eax
  101ea5:	83 e2 fc             	and    $0xfffffffc,%edx
  101ea8:	c1 e8 02             	shr    $0x2,%eax
  101eab:	01 c2                	add    %eax,%edx
  101ead:	29 d5                	sub    %edx,%ebp
  101eaf:	29 ee                	sub    %ebp,%esi
  101eb1:	83 df 00             	sbb    $0x0,%edi
  101eb4:	89 74 24 08          	mov    %esi,0x8(%esp)
  101eb8:	69 44 24 08 cc cc cc 	imul   $0xcccccccc,0x8(%esp),%eax
  101ebf:	cc 

        timer_hw_init();
        return 1;
    } else {
        tsc_per_ms = ret;
        KERN_DEBUG("TSC freq = %u.%03u MHz.\n",tsc_per_ms / 1000, tsc_per_ms % 1000);
  101ec0:	83 ec 10             	sub    $0x10,%esp
    return delta / ms;
  101ec3:	89 fa                	mov    %edi,%edx
  101ec5:	69 ff cd cc cc cc    	imul   $0xcccccccd,%edi,%edi
  101ecb:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  101ecf:	01 c7                	add    %eax,%edi
  101ed1:	8b 44 24 18          	mov    0x18(%esp),%eax
        KERN_DEBUG("TSC freq = %u.%03u MHz.\n",tsc_per_ms / 1000, tsc_per_ms % 1000);
  101ed5:	6a 00                	push   $0x0
  101ed7:	68 e8 03 00 00       	push   $0x3e8
    return delta / ms;
  101edc:	f7 e1                	mul    %ecx
  101ede:	01 fa                	add    %edi,%edx
  101ee0:	0f ac d0 01          	shrd   $0x1,%edx,%eax
  101ee4:	d1 ea                	shr    $1,%edx
        tsc_per_ms = ret;
  101ee6:	89 83 94 a8 08 00    	mov    %eax,0x8a894(%ebx)
  101eec:	89 93 98 a8 08 00    	mov    %edx,0x8a898(%ebx)
        KERN_DEBUG("TSC freq = %u.%03u MHz.\n",tsc_per_ms / 1000, tsc_per_ms % 1000);
  101ef2:	8b 83 94 a8 08 00    	mov    0x8a894(%ebx),%eax
  101ef8:	8b 93 98 a8 08 00    	mov    0x8a898(%ebx),%edx
  101efe:	8b b3 94 a8 08 00    	mov    0x8a894(%ebx),%esi
  101f04:	8b bb 98 a8 08 00    	mov    0x8a898(%ebx),%edi
  101f0a:	52                   	push   %edx
  101f0b:	50                   	push   %eax
  101f0c:	e8 8f a5 00 00       	call   10c4a0 <__umoddi3>
  101f11:	83 c4 1c             	add    $0x1c,%esp
  101f14:	52                   	push   %edx
  101f15:	50                   	push   %eax
  101f16:	83 ec 04             	sub    $0x4,%esp
  101f19:	6a 00                	push   $0x0
  101f1b:	68 e8 03 00 00       	push   $0x3e8
  101f20:	57                   	push   %edi
  101f21:	56                   	push   %esi
  101f22:	e8 59 a4 00 00       	call   10c380 <__udivdi3>
  101f27:	83 c4 14             	add    $0x14,%esp
  101f2a:	52                   	push   %edx
  101f2b:	50                   	push   %eax
  101f2c:	8d 83 ab 61 ff ff    	lea    -0x9e55(%ebx),%eax
  101f32:	50                   	push   %eax
  101f33:	6a 68                	push   $0x68
  101f35:	ff 74 24 48          	push   0x48(%esp)
  101f39:	e8 52 28 00 00       	call   104790 <debug_normal>

        timer_hw_init();
  101f3e:	83 c4 20             	add    $0x20,%esp
  101f41:	e8 4a fd ff ff       	call   101c90 <timer_hw_init>
        return 0;
    }
}
  101f46:	83 c4 4c             	add    $0x4c,%esp
		return (0);
  101f49:	31 c0                	xor    %eax,%eax
}
  101f4b:	5b                   	pop    %ebx
  101f4c:	5e                   	pop    %esi
  101f4d:	5f                   	pop    %edi
  101f4e:	5d                   	pop    %ebp
  101f4f:	c3                   	ret
        KERN_DEBUG("[%d] Retry to calibrate TSC.\n", i + 1);
  101f50:	83 44 24 28 01       	addl   $0x1,0x28(%esp)
  101f55:	8b 7c 24 28          	mov    0x28(%esp),%edi
  101f59:	57                   	push   %edi
  101f5a:	ff 74 24 40          	push   0x40(%esp)
  101f5e:	6a 5c                	push   $0x5c
  101f60:	ff 74 24 38          	push   0x38(%esp)
  101f64:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  101f68:	e8 23 28 00 00       	call   104790 <debug_normal>
    for (i = 0; i < 10; i++) {
  101f6d:	83 c4 10             	add    $0x10,%esp
  101f70:	83 ff 0a             	cmp    $0xa,%edi
  101f73:	0f 85 bf fd ff ff    	jne    101d38 <tsc_init+0x68>
        KERN_DEBUG("TSC calibration failed.\n");
  101f79:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  101f7d:	83 ec 04             	sub    $0x4,%esp
  101f80:	8d 83 e2 61 ff ff    	lea    -0x9e1e(%ebx),%eax
  101f86:	50                   	push   %eax
  101f87:	6a 60                	push   $0x60
  101f89:	8b 7c 24 38          	mov    0x38(%esp),%edi
  101f8d:	57                   	push   %edi
  101f8e:	e8 fd 27 00 00       	call   104790 <debug_normal>
        KERN_DEBUG("Assume TSC freq = 1 GHz.\n");
  101f93:	83 c4 0c             	add    $0xc,%esp
  101f96:	8d 83 fb 61 ff ff    	lea    -0x9e05(%ebx),%eax
  101f9c:	50                   	push   %eax
  101f9d:	6a 61                	push   $0x61
  101f9f:	57                   	push   %edi
  101fa0:	e8 eb 27 00 00       	call   104790 <debug_normal>
        tsc_per_ms = 1000000;
  101fa5:	c7 83 94 a8 08 00 40 	movl   $0xf4240,0x8a894(%ebx)
  101fac:	42 0f 00 
  101faf:	c7 83 98 a8 08 00 00 	movl   $0x0,0x8a898(%ebx)
  101fb6:	00 00 00 
        timer_hw_init();
  101fb9:	e8 d2 fc ff ff       	call   101c90 <timer_hw_init>
        return 1;
  101fbe:	83 c4 10             	add    $0x10,%esp
  101fc1:	b8 01 00 00 00       	mov    $0x1,%eax
}
  101fc6:	83 c4 4c             	add    $0x4c,%esp
  101fc9:	5b                   	pop    %ebx
  101fca:	5e                   	pop    %esi
  101fcb:	5f                   	pop    %edi
  101fcc:	5d                   	pop    %ebp
  101fcd:	c3                   	ret
		tsc_per_ms = kvm_get_tsc_hz() / 1000llu;
  101fce:	e8 4d 23 00 00       	call   104320 <kvm_get_tsc_hz>
  101fd3:	6a 00                	push   $0x0
  101fd5:	68 e8 03 00 00       	push   $0x3e8
  101fda:	52                   	push   %edx
  101fdb:	50                   	push   %eax
  101fdc:	e8 9f a3 00 00       	call   10c380 <__udivdi3>
		KERN_INFO ("TSC read from KVM: %u.%03u MHz.\n",
  101fe1:	6a 00                	push   $0x0
		tsc_per_ms = kvm_get_tsc_hz() / 1000llu;
  101fe3:	89 83 94 a8 08 00    	mov    %eax,0x8a894(%ebx)
  101fe9:	89 93 98 a8 08 00    	mov    %edx,0x8a898(%ebx)
		KERN_INFO ("TSC read from KVM: %u.%03u MHz.\n",
  101fef:	8b 83 94 a8 08 00    	mov    0x8a894(%ebx),%eax
  101ff5:	8b 93 98 a8 08 00    	mov    0x8a898(%ebx),%edx
  101ffb:	68 e8 03 00 00       	push   $0x3e8
  102000:	8b b3 94 a8 08 00    	mov    0x8a894(%ebx),%esi
  102006:	8b bb 98 a8 08 00    	mov    0x8a898(%ebx),%edi
  10200c:	52                   	push   %edx
  10200d:	50                   	push   %eax
  10200e:	e8 8d a4 00 00       	call   10c4a0 <__umoddi3>
  102013:	83 c4 14             	add    $0x14,%esp
  102016:	52                   	push   %edx
  102017:	50                   	push   %eax
  102018:	83 ec 0c             	sub    $0xc,%esp
  10201b:	6a 00                	push   $0x0
  10201d:	68 e8 03 00 00       	push   $0x3e8
  102022:	57                   	push   %edi
  102023:	56                   	push   %esi
  102024:	e8 57 a3 00 00       	call   10c380 <__udivdi3>
  102029:	83 c4 1c             	add    $0x1c,%esp
  10202c:	52                   	push   %edx
  10202d:	50                   	push   %eax
  10202e:	8d 83 38 6d ff ff    	lea    -0x92c8(%ebx),%eax
  102034:	50                   	push   %eax
  102035:	e8 16 27 00 00       	call   104750 <debug_info>
		return (0);
  10203a:	83 c4 20             	add    $0x20,%esp
  10203d:	e9 04 ff ff ff       	jmp    101f46 <tsc_init+0x276>
  102042:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  102049:	00 
  10204a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00102050 <delay>:

/*
 * Wait for ms millisecond.
 */
void delay(uint32_t ms)
{
  102050:	55                   	push   %ebp
  102051:	e8 b3 f1 ff ff       	call   101209 <__x86.get_pc_thunk.bp>
  102056:	81 c5 9e 4f 01 00    	add    $0x14f9e,%ebp
  10205c:	57                   	push   %edi
  10205d:	56                   	push   %esi
  10205e:	53                   	push   %ebx
  10205f:	83 ec 1c             	sub    $0x1c,%esp
  102062:	8b 44 24 30          	mov    0x30(%esp),%eax
    volatile uint64_t ticks = tsc_per_ms * ms;
  102066:	8b b5 94 a8 08 00    	mov    0x8a894(%ebp),%esi
    volatile uint64_t start = rdtsc();
  10206c:	89 eb                	mov    %ebp,%ebx
    volatile uint64_t ticks = tsc_per_ms * ms;
  10206e:	8b 8d 98 a8 08 00    	mov    0x8a898(%ebp),%ecx
  102074:	0f af c8             	imul   %eax,%ecx
  102077:	f7 e6                	mul    %esi
  102079:	01 ca                	add    %ecx,%edx
  10207b:	89 04 24             	mov    %eax,(%esp)
  10207e:	89 54 24 04          	mov    %edx,0x4(%esp)
    volatile uint64_t start = rdtsc();
  102082:	e8 f9 33 00 00       	call   105480 <rdtsc>
  102087:	89 44 24 08          	mov    %eax,0x8(%esp)
  10208b:	89 54 24 0c          	mov    %edx,0xc(%esp)
    while (rdtsc() < start + ticks);
  10208f:	90                   	nop
  102090:	89 eb                	mov    %ebp,%ebx
  102092:	e8 e9 33 00 00       	call   105480 <rdtsc>
  102097:	89 c3                	mov    %eax,%ebx
  102099:	89 d1                	mov    %edx,%ecx
  10209b:	8b 44 24 08          	mov    0x8(%esp),%eax
  10209f:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1020a3:	8b 34 24             	mov    (%esp),%esi
  1020a6:	8b 7c 24 04          	mov    0x4(%esp),%edi
  1020aa:	01 f0                	add    %esi,%eax
  1020ac:	11 fa                	adc    %edi,%edx
  1020ae:	39 c3                	cmp    %eax,%ebx
  1020b0:	19 d1                	sbb    %edx,%ecx
  1020b2:	72 dc                	jb     102090 <delay+0x40>
}
  1020b4:	83 c4 1c             	add    $0x1c,%esp
  1020b7:	5b                   	pop    %ebx
  1020b8:	5e                   	pop    %esi
  1020b9:	5f                   	pop    %edi
  1020ba:	5d                   	pop    %ebp
  1020bb:	c3                   	ret
  1020bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001020c0 <udelay>:

/*
 * Wait for us microsecond.
 */
void udelay(uint32_t us)
{
  1020c0:	55                   	push   %ebp
  1020c1:	e8 43 f1 ff ff       	call   101209 <__x86.get_pc_thunk.bp>
  1020c6:	81 c5 2e 4f 01 00    	add    $0x14f2e,%ebp
  1020cc:	57                   	push   %edi
  1020cd:	56                   	push   %esi
  1020ce:	53                   	push   %ebx
  1020cf:	83 ec 1c             	sub    $0x1c,%esp
    volatile uint64_t ticks = tsc_per_ms / 1000 * us;
  1020d2:	8b 85 94 a8 08 00    	mov    0x8a894(%ebp),%eax
  1020d8:	8b 95 98 a8 08 00    	mov    0x8a898(%ebp),%edx
  1020de:	89 eb                	mov    %ebp,%ebx
{
  1020e0:	8b 74 24 30          	mov    0x30(%esp),%esi
    volatile uint64_t ticks = tsc_per_ms / 1000 * us;
  1020e4:	6a 00                	push   $0x0
  1020e6:	68 e8 03 00 00       	push   $0x3e8
  1020eb:	52                   	push   %edx
  1020ec:	50                   	push   %eax
  1020ed:	e8 8e a2 00 00       	call   10c380 <__udivdi3>
  1020f2:	83 c4 10             	add    $0x10,%esp
  1020f5:	89 d1                	mov    %edx,%ecx
  1020f7:	f7 e6                	mul    %esi
  1020f9:	0f af ce             	imul   %esi,%ecx
  1020fc:	89 04 24             	mov    %eax,(%esp)
  1020ff:	01 ca                	add    %ecx,%edx
  102101:	89 54 24 04          	mov    %edx,0x4(%esp)
    volatile uint64_t start = rdtsc();
  102105:	e8 76 33 00 00       	call   105480 <rdtsc>
  10210a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10210e:	89 54 24 0c          	mov    %edx,0xc(%esp)
    while (rdtsc() < start + ticks);
  102112:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  102118:	89 eb                	mov    %ebp,%ebx
  10211a:	e8 61 33 00 00       	call   105480 <rdtsc>
  10211f:	89 c3                	mov    %eax,%ebx
  102121:	89 d1                	mov    %edx,%ecx
  102123:	8b 44 24 08          	mov    0x8(%esp),%eax
  102127:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10212b:	8b 34 24             	mov    (%esp),%esi
  10212e:	8b 7c 24 04          	mov    0x4(%esp),%edi
  102132:	01 f0                	add    %esi,%eax
  102134:	11 fa                	adc    %edi,%edx
  102136:	39 c3                	cmp    %eax,%ebx
  102138:	19 d1                	sbb    %edx,%ecx
  10213a:	72 dc                	jb     102118 <udelay+0x58>
}
  10213c:	83 c4 1c             	add    $0x1c,%esp
  10213f:	5b                   	pop    %ebx
  102140:	5e                   	pop    %esi
  102141:	5f                   	pop    %edi
  102142:	5d                   	pop    %ebp
  102143:	c3                   	ret
  102144:	66 90                	xchg   %ax,%ax
  102146:	66 90                	xchg   %ax,%ax
  102148:	66 90                	xchg   %ax,%ax
  10214a:	66 90                	xchg   %ax,%ax
  10214c:	66 90                	xchg   %ax,%ax
  10214e:	66 90                	xchg   %ax,%ax

00102150 <Xdivide>:
	jmp	_alltraps

.text

/* exceptions  */
TRAPHANDLER_NOEC(Xdivide,	T_DIVIDE)
  102150:	6a 00                	push   $0x0
  102152:	6a 00                	push   $0x0
  102154:	e9 17 01 00 00       	jmp    102270 <_alltraps>
  102159:	90                   	nop

0010215a <Xdebug>:
TRAPHANDLER_NOEC(Xdebug,	T_DEBUG)
  10215a:	6a 00                	push   $0x0
  10215c:	6a 01                	push   $0x1
  10215e:	e9 0d 01 00 00       	jmp    102270 <_alltraps>
  102163:	90                   	nop

00102164 <Xnmi>:
TRAPHANDLER_NOEC(Xnmi,		T_NMI)
  102164:	6a 00                	push   $0x0
  102166:	6a 02                	push   $0x2
  102168:	e9 03 01 00 00       	jmp    102270 <_alltraps>
  10216d:	90                   	nop

0010216e <Xbrkpt>:
TRAPHANDLER_NOEC(Xbrkpt,	T_BRKPT)
  10216e:	6a 00                	push   $0x0
  102170:	6a 03                	push   $0x3
  102172:	e9 f9 00 00 00       	jmp    102270 <_alltraps>
  102177:	90                   	nop

00102178 <Xoflow>:
TRAPHANDLER_NOEC(Xoflow,	T_OFLOW)
  102178:	6a 00                	push   $0x0
  10217a:	6a 04                	push   $0x4
  10217c:	e9 ef 00 00 00       	jmp    102270 <_alltraps>
  102181:	90                   	nop

00102182 <Xbound>:
TRAPHANDLER_NOEC(Xbound,	T_BOUND)
  102182:	6a 00                	push   $0x0
  102184:	6a 05                	push   $0x5
  102186:	e9 e5 00 00 00       	jmp    102270 <_alltraps>
  10218b:	90                   	nop

0010218c <Xillop>:
TRAPHANDLER_NOEC(Xillop,	T_ILLOP)
  10218c:	6a 00                	push   $0x0
  10218e:	6a 06                	push   $0x6
  102190:	e9 db 00 00 00       	jmp    102270 <_alltraps>
  102195:	90                   	nop

00102196 <Xdevice>:
TRAPHANDLER_NOEC(Xdevice,	T_DEVICE)
  102196:	6a 00                	push   $0x0
  102198:	6a 07                	push   $0x7
  10219a:	e9 d1 00 00 00       	jmp    102270 <_alltraps>
  10219f:	90                   	nop

001021a0 <Xdblflt>:
TRAPHANDLER     (Xdblflt,	T_DBLFLT)
  1021a0:	6a 08                	push   $0x8
  1021a2:	e9 c9 00 00 00       	jmp    102270 <_alltraps>
  1021a7:	90                   	nop

001021a8 <Xcoproc>:
TRAPHANDLER_NOEC(Xcoproc,	T_COPROC)
  1021a8:	6a 00                	push   $0x0
  1021aa:	6a 09                	push   $0x9
  1021ac:	e9 bf 00 00 00       	jmp    102270 <_alltraps>
  1021b1:	90                   	nop

001021b2 <Xtss>:
TRAPHANDLER     (Xtss,		T_TSS)
  1021b2:	6a 0a                	push   $0xa
  1021b4:	e9 b7 00 00 00       	jmp    102270 <_alltraps>
  1021b9:	90                   	nop

001021ba <Xsegnp>:
TRAPHANDLER     (Xsegnp,	T_SEGNP)
  1021ba:	6a 0b                	push   $0xb
  1021bc:	e9 af 00 00 00       	jmp    102270 <_alltraps>
  1021c1:	90                   	nop

001021c2 <Xstack>:
TRAPHANDLER     (Xstack,	T_STACK)
  1021c2:	6a 0c                	push   $0xc
  1021c4:	e9 a7 00 00 00       	jmp    102270 <_alltraps>
  1021c9:	90                   	nop

001021ca <Xgpflt>:
TRAPHANDLER     (Xgpflt,	T_GPFLT)
  1021ca:	6a 0d                	push   $0xd
  1021cc:	e9 9f 00 00 00       	jmp    102270 <_alltraps>
  1021d1:	90                   	nop

001021d2 <Xpgflt>:
TRAPHANDLER     (Xpgflt,	T_PGFLT)
  1021d2:	6a 0e                	push   $0xe
  1021d4:	e9 97 00 00 00       	jmp    102270 <_alltraps>
  1021d9:	90                   	nop

001021da <Xres>:
TRAPHANDLER_NOEC(Xres,		T_RES)
  1021da:	6a 00                	push   $0x0
  1021dc:	6a 0f                	push   $0xf
  1021de:	e9 8d 00 00 00       	jmp    102270 <_alltraps>
  1021e3:	90                   	nop

001021e4 <Xfperr>:
TRAPHANDLER_NOEC(Xfperr,	T_FPERR)
  1021e4:	6a 00                	push   $0x0
  1021e6:	6a 10                	push   $0x10
  1021e8:	e9 83 00 00 00       	jmp    102270 <_alltraps>
  1021ed:	90                   	nop

001021ee <Xalign>:
TRAPHANDLER     (Xalign,	T_ALIGN)
  1021ee:	6a 11                	push   $0x11
  1021f0:	eb 7e                	jmp    102270 <_alltraps>

001021f2 <Xmchk>:
TRAPHANDLER_NOEC(Xmchk,		T_MCHK)
  1021f2:	6a 00                	push   $0x0
  1021f4:	6a 12                	push   $0x12
  1021f6:	eb 78                	jmp    102270 <_alltraps>

001021f8 <Xirq_timer>:

/* ISA interrupts  */
TRAPHANDLER_NOEC(Xirq_timer,	T_IRQ0 + IRQ_TIMER)
  1021f8:	6a 00                	push   $0x0
  1021fa:	6a 20                	push   $0x20
  1021fc:	eb 72                	jmp    102270 <_alltraps>

001021fe <Xirq_kbd>:
TRAPHANDLER_NOEC(Xirq_kbd,	T_IRQ0 + IRQ_KBD)
  1021fe:	6a 00                	push   $0x0
  102200:	6a 21                	push   $0x21
  102202:	eb 6c                	jmp    102270 <_alltraps>

00102204 <Xirq_slave>:
TRAPHANDLER_NOEC(Xirq_slave,	T_IRQ0 + IRQ_SLAVE)
  102204:	6a 00                	push   $0x0
  102206:	6a 22                	push   $0x22
  102208:	eb 66                	jmp    102270 <_alltraps>

0010220a <Xirq_serial2>:
TRAPHANDLER_NOEC(Xirq_serial2,	T_IRQ0 + IRQ_SERIAL24)
  10220a:	6a 00                	push   $0x0
  10220c:	6a 23                	push   $0x23
  10220e:	eb 60                	jmp    102270 <_alltraps>

00102210 <Xirq_serial1>:
TRAPHANDLER_NOEC(Xirq_serial1,	T_IRQ0 + IRQ_SERIAL13)
  102210:	6a 00                	push   $0x0
  102212:	6a 24                	push   $0x24
  102214:	eb 5a                	jmp    102270 <_alltraps>

00102216 <Xirq_lpt>:
TRAPHANDLER_NOEC(Xirq_lpt,	T_IRQ0 + IRQ_LPT2)
  102216:	6a 00                	push   $0x0
  102218:	6a 25                	push   $0x25
  10221a:	eb 54                	jmp    102270 <_alltraps>

0010221c <Xirq_floppy>:
TRAPHANDLER_NOEC(Xirq_floppy,	T_IRQ0 + IRQ_FLOPPY)
  10221c:	6a 00                	push   $0x0
  10221e:	6a 26                	push   $0x26
  102220:	eb 4e                	jmp    102270 <_alltraps>

00102222 <Xirq_spurious>:
TRAPHANDLER_NOEC(Xirq_spurious,	T_IRQ0 + IRQ_SPURIOUS)
  102222:	6a 00                	push   $0x0
  102224:	6a 27                	push   $0x27
  102226:	eb 48                	jmp    102270 <_alltraps>

00102228 <Xirq_rtc>:
TRAPHANDLER_NOEC(Xirq_rtc,	T_IRQ0 + IRQ_RTC)
  102228:	6a 00                	push   $0x0
  10222a:	6a 28                	push   $0x28
  10222c:	eb 42                	jmp    102270 <_alltraps>

0010222e <Xirq9>:
TRAPHANDLER_NOEC(Xirq9,		T_IRQ0 + 9)
  10222e:	6a 00                	push   $0x0
  102230:	6a 29                	push   $0x29
  102232:	eb 3c                	jmp    102270 <_alltraps>

00102234 <Xirq10>:
TRAPHANDLER_NOEC(Xirq10,	T_IRQ0 + 10)
  102234:	6a 00                	push   $0x0
  102236:	6a 2a                	push   $0x2a
  102238:	eb 36                	jmp    102270 <_alltraps>

0010223a <Xirq11>:
TRAPHANDLER_NOEC(Xirq11,	T_IRQ0 + 11)
  10223a:	6a 00                	push   $0x0
  10223c:	6a 2b                	push   $0x2b
  10223e:	eb 30                	jmp    102270 <_alltraps>

00102240 <Xirq_mouse>:
TRAPHANDLER_NOEC(Xirq_mouse,	T_IRQ0 + IRQ_MOUSE)
  102240:	6a 00                	push   $0x0
  102242:	6a 2c                	push   $0x2c
  102244:	eb 2a                	jmp    102270 <_alltraps>

00102246 <Xirq_coproc>:
TRAPHANDLER_NOEC(Xirq_coproc,	T_IRQ0 + IRQ_COPROCESSOR)
  102246:	6a 00                	push   $0x0
  102248:	6a 2d                	push   $0x2d
  10224a:	eb 24                	jmp    102270 <_alltraps>

0010224c <Xirq_ide1>:
TRAPHANDLER_NOEC(Xirq_ide1,	T_IRQ0 + IRQ_IDE1)
  10224c:	6a 00                	push   $0x0
  10224e:	6a 2e                	push   $0x2e
  102250:	eb 1e                	jmp    102270 <_alltraps>

00102252 <Xirq_ide2>:
TRAPHANDLER_NOEC(Xirq_ide2,	T_IRQ0 + IRQ_IDE2)
  102252:	6a 00                	push   $0x0
  102254:	6a 2f                	push   $0x2f
  102256:	eb 18                	jmp    102270 <_alltraps>

00102258 <Xsyscall>:

/* syscall */
TRAPHANDLER_NOEC(Xsyscall,	T_SYSCALL)
  102258:	6a 00                	push   $0x0
  10225a:	6a 30                	push   $0x30
  10225c:	eb 12                	jmp    102270 <_alltraps>

0010225e <Xdefault>:

/* default ? */
TRAPHANDLER     (Xdefault,	T_DEFAULT)
  10225e:	68 fe 00 00 00       	push   $0xfe
  102263:	eb 0b                	jmp    102270 <_alltraps>
  102265:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10226c:	00 
  10226d:	8d 76 00             	lea    0x0(%esi),%esi

00102270 <_alltraps>:

	.globl _alltraps
	.type _alltraps, @function
	.p2align 4, 0x90	/* 16-byte alignment, nop filled */
_alltraps:
	cli			# make sure there is no nested trap
  102270:	fa                   	cli
	cld
  102271:	fc                   	cld

	pushl	%ds		# build context
  102272:	1e                   	push   %ds
	pushl	%es
  102273:	06                   	push   %es
	pushal
  102274:	60                   	pusha

	movl	$CPU_GDT_KDATA, %eax	# load kernel's data segment
  102275:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax, %ds
  10227a:	8e d8                	mov    %eax,%ds
	movw	%ax, %es
  10227c:	8e c0                	mov    %eax,%es

	pushl	%esp		# pass pointer to this trapframe
  10227e:	54                   	push   %esp

	call	trap		# and call trap (does not return)
  10227f:	e8 5c 68 00 00       	call   108ae0 <trap>

1:	hlt			# should never get here; just spin...
  102284:	f4                   	hlt
  102285:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10228c:	00 
  10228d:	8d 76 00             	lea    0x0(%esi),%esi

00102290 <trap_return>:
//
	.globl trap_return
	.type trap_return, @function
	.p2align 4, 0x90	/* 16-byte alignment, nop filled */
trap_return:
	movl	4(%esp), %esp	// reset stack pointer to point to trap frame
  102290:	8b 64 24 04          	mov    0x4(%esp),%esp
	popal			// restore general-purpose registers except esp
  102294:	61                   	popa
	popl	%es		// restore data segment registers
  102295:	07                   	pop    %es
	popl	%ds
  102296:	1f                   	pop    %ds
	addl	$8, %esp	// skip tf_trapno and tf_errcode
  102297:	83 c4 08             	add    $0x8,%esp
	iret			// return from trap handler
  10229a:	cf                   	iret
  10229b:	66 90                	xchg   %ax,%ax
  10229d:	66 90                	xchg   %ax,%ax
  10229f:	90                   	nop

001022a0 <acpi_probe_rsdp>:

    return NULL;
}

acpi_rsdp_t *acpi_probe_rsdp(void)
{
  1022a0:	57                   	push   %edi
  1022a1:	56                   	push   %esi
  1022a2:	53                   	push   %ebx
    uint8_t *bda;
    uint32_t p;
    acpi_rsdp_t *rsdp;

    bda = (uint8_t *) 0x400;
    if ((p = ((bda[0x0F] << 8) | bda[0x0E]) << 4)) {
  1022a3:	0f b6 05 0f 04 00 00 	movzbl 0x40f,%eax
  1022aa:	0f b6 15 0e 04 00 00 	movzbl 0x40e,%edx
  1022b1:	c1 e0 08             	shl    $0x8,%eax
  1022b4:	09 d0                	or     %edx,%eax
  1022b6:	c1 e0 04             	shl    $0x4,%eax
  1022b9:	74 4d                	je     102308 <acpi_probe_rsdp+0x68>
        if (*(uint32_t *) p == ACPI_RSDP_SIG1 &&
  1022bb:	81 38 52 53 44 20    	cmpl   $0x20445352,(%eax)
    e = addr + length;
  1022c1:	8d 88 00 04 00 00    	lea    0x400(%eax),%ecx
        if (*(uint32_t *) p == ACPI_RSDP_SIG1 &&
  1022c7:	74 16                	je     1022df <acpi_probe_rsdp+0x3f>
  1022c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    for (p = addr; p < e; p += 16) {
  1022d0:	83 c0 10             	add    $0x10,%eax
  1022d3:	39 c8                	cmp    %ecx,%eax
  1022d5:	73 31                	jae    102308 <acpi_probe_rsdp+0x68>
        if (*(uint32_t *) p == ACPI_RSDP_SIG1 &&
  1022d7:	81 38 52 53 44 20    	cmpl   $0x20445352,(%eax)
  1022dd:	75 f1                	jne    1022d0 <acpi_probe_rsdp+0x30>
  1022df:	81 78 04 50 54 52 20 	cmpl   $0x20525450,0x4(%eax)
  1022e6:	75 e8                	jne    1022d0 <acpi_probe_rsdp+0x30>
  1022e8:	89 c2                	mov    %eax,%edx
    sum = 0;
  1022ea:	31 db                	xor    %ebx,%ebx
  1022ec:	8d 70 24             	lea    0x24(%eax),%esi
  1022ef:	90                   	nop
        sum += addr[i];
  1022f0:	0f b6 3a             	movzbl (%edx),%edi
    for (i = 0; i < len; i++) {
  1022f3:	83 c2 01             	add    $0x1,%edx
        sum += addr[i];
  1022f6:	01 fb                	add    %edi,%ebx
    for (i = 0; i < len; i++) {
  1022f8:	39 f2                	cmp    %esi,%edx
  1022fa:	75 f4                	jne    1022f0 <acpi_probe_rsdp+0x50>
            *(uint32_t *) (p + 4) == ACPI_RSDP_SIG2 &&
  1022fc:	84 db                	test   %bl,%bl
  1022fe:	75 d0                	jne    1022d0 <acpi_probe_rsdp+0x30>
        if ((rsdp = acpi_probe_rsdp_aux((uint8_t *) p, 1024)))
            return rsdp;
    }

    return acpi_probe_rsdp_aux((uint8_t *) 0xE0000, 0x1FFFF);
}
  102300:	5b                   	pop    %ebx
  102301:	5e                   	pop    %esi
  102302:	5f                   	pop    %edi
  102303:	c3                   	ret
  102304:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  102308:	b8 00 00 0e 00       	mov    $0xe0000,%eax
  10230d:	eb 0b                	jmp    10231a <acpi_probe_rsdp+0x7a>
  10230f:	90                   	nop
    for (p = addr; p < e; p += 16) {
  102310:	83 c0 10             	add    $0x10,%eax
  102313:	3d 00 00 10 00       	cmp    $0x100000,%eax
  102318:	74 38                	je     102352 <acpi_probe_rsdp+0xb2>
        if (*(uint32_t *) p == ACPI_RSDP_SIG1 &&
  10231a:	81 38 52 53 44 20    	cmpl   $0x20445352,(%eax)
  102320:	75 ee                	jne    102310 <acpi_probe_rsdp+0x70>
  102322:	81 78 04 50 54 52 20 	cmpl   $0x20525450,0x4(%eax)
  102329:	75 e5                	jne    102310 <acpi_probe_rsdp+0x70>
  10232b:	89 c2                	mov    %eax,%edx
    sum = 0;
  10232d:	31 c9                	xor    %ecx,%ecx
  10232f:	8d 70 24             	lea    0x24(%eax),%esi
  102332:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        sum += addr[i];
  102338:	0f b6 1a             	movzbl (%edx),%ebx
    for (i = 0; i < len; i++) {
  10233b:	83 c2 01             	add    $0x1,%edx
        sum += addr[i];
  10233e:	01 d9                	add    %ebx,%ecx
    for (i = 0; i < len; i++) {
  102340:	39 d6                	cmp    %edx,%esi
  102342:	75 f4                	jne    102338 <acpi_probe_rsdp+0x98>
            *(uint32_t *) (p + 4) == ACPI_RSDP_SIG2 &&
  102344:	84 c9                	test   %cl,%cl
  102346:	74 b8                	je     102300 <acpi_probe_rsdp+0x60>
    for (p = addr; p < e; p += 16) {
  102348:	83 c0 10             	add    $0x10,%eax
  10234b:	3d 00 00 10 00       	cmp    $0x100000,%eax
  102350:	75 c8                	jne    10231a <acpi_probe_rsdp+0x7a>
}
  102352:	5b                   	pop    %ebx
    return NULL;
  102353:	31 c0                	xor    %eax,%eax
}
  102355:	5e                   	pop    %esi
  102356:	5f                   	pop    %edi
  102357:	c3                   	ret
  102358:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10235f:	00 

00102360 <acpi_probe_rsdt>:

acpi_rsdt_t *acpi_probe_rsdt(acpi_rsdp_t *rsdp)
{
  102360:	56                   	push   %esi
  102361:	53                   	push   %ebx
  102362:	e8 3b e0 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  102367:	81 c3 8d 4c 01 00    	add    $0x14c8d,%ebx
  10236d:	83 ec 04             	sub    $0x4,%esp
  102370:	8b 74 24 10          	mov    0x10(%esp),%esi
    KERN_ASSERT(rsdp != NULL);
  102374:	85 f6                	test   %esi,%esi
  102376:	74 50                	je     1023c8 <acpi_probe_rsdt+0x68>

    acpi_rsdt_t *rsdt = (acpi_rsdt_t *) (rsdp->rsdt_addr);
  102378:	8b 5e 10             	mov    0x10(%esi),%ebx
  10237b:	89 d8                	mov    %ebx,%eax
    if (rsdt == NULL)
  10237d:	85 db                	test   %ebx,%ebx
  10237f:	74 2a                	je     1023ab <acpi_probe_rsdt+0x4b>
        return NULL;
    if (rsdt->sig == ACPI_RSDT_SIG && sum((uint8_t *) rsdt, rsdt->length) == 0) {
  102381:	81 3b 52 53 44 54    	cmpl   $0x54445352,(%ebx)
  102387:	75 2f                	jne    1023b8 <acpi_probe_rsdt+0x58>
  102389:	8b 73 04             	mov    0x4(%ebx),%esi
    for (i = 0; i < len; i++) {
  10238c:	85 f6                	test   %esi,%esi
  10238e:	7e 1b                	jle    1023ab <acpi_probe_rsdt+0x4b>
  102390:	01 de                	add    %ebx,%esi
    sum = 0;
  102392:	31 d2                	xor    %edx,%edx
  102394:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        sum += addr[i];
  102398:	0f b6 08             	movzbl (%eax),%ecx
    for (i = 0; i < len; i++) {
  10239b:	83 c0 01             	add    $0x1,%eax
        sum += addr[i];
  10239e:	01 ca                	add    %ecx,%edx
    for (i = 0; i < len; i++) {
  1023a0:	39 c6                	cmp    %eax,%esi
  1023a2:	75 f4                	jne    102398 <acpi_probe_rsdt+0x38>
        return NULL;
  1023a4:	31 c0                	xor    %eax,%eax
  1023a6:	84 d2                	test   %dl,%dl
  1023a8:	0f 45 d8             	cmovne %eax,%ebx
        return rsdt;
    }

    return NULL;
}
  1023ab:	83 c4 04             	add    $0x4,%esp
  1023ae:	89 d8                	mov    %ebx,%eax
  1023b0:	5b                   	pop    %ebx
  1023b1:	5e                   	pop    %esi
  1023b2:	c3                   	ret
  1023b3:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        return NULL;
  1023b8:	31 db                	xor    %ebx,%ebx
}
  1023ba:	83 c4 04             	add    $0x4,%esp
  1023bd:	89 d8                	mov    %ebx,%eax
  1023bf:	5b                   	pop    %ebx
  1023c0:	5e                   	pop    %esi
  1023c1:	c3                   	ret
  1023c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    KERN_ASSERT(rsdp != NULL);
  1023c8:	8d 83 15 62 ff ff    	lea    -0x9deb(%ebx),%eax
  1023ce:	50                   	push   %eax
  1023cf:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  1023d5:	50                   	push   %eax
  1023d6:	8d 83 22 62 ff ff    	lea    -0x9dde(%ebx),%eax
  1023dc:	6a 33                	push   $0x33
  1023de:	50                   	push   %eax
  1023df:	e8 0c 24 00 00       	call   1047f0 <debug_panic>
  1023e4:	83 c4 10             	add    $0x10,%esp
  1023e7:	eb 8f                	jmp    102378 <acpi_probe_rsdt+0x18>
  1023e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001023f0 <acpi_probe_rsdt_ent>:

acpi_sdt_hdr_t *acpi_probe_rsdt_ent(acpi_rsdt_t *rsdt, const uint32_t sig)
{
  1023f0:	55                   	push   %ebp
  1023f1:	57                   	push   %edi
  1023f2:	56                   	push   %esi
  1023f3:	53                   	push   %ebx
  1023f4:	e8 a9 df ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1023f9:	81 c3 fb 4b 01 00    	add    $0x14bfb,%ebx
  1023ff:	83 ec 1c             	sub    $0x1c,%esp
  102402:	8b 7c 24 30          	mov    0x30(%esp),%edi
    KERN_ASSERT(rsdt != NULL);
  102406:	85 ff                	test   %edi,%edi
  102408:	74 62                	je     10246c <acpi_probe_rsdt_ent+0x7c>

    uint8_t *p = (uint8_t *) &rsdt->ent[0];
  10240a:	8d 57 24             	lea    0x24(%edi),%edx
    uint8_t *e = (uint8_t *) rsdt + rsdt->length;
  10240d:	03 7f 04             	add    0x4(%edi),%edi

    int i;
    for (i = 0; p < e; i++) {
  102410:	39 fa                	cmp    %edi,%edx
  102412:	73 4c                	jae    102460 <acpi_probe_rsdt_ent+0x70>
  102414:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  102418:	eb 0d                	jmp    102427 <acpi_probe_rsdt_ent+0x37>
  10241a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  102420:	83 c2 04             	add    $0x4,%edx
  102423:	39 fa                	cmp    %edi,%edx
  102425:	73 39                	jae    102460 <acpi_probe_rsdt_ent+0x70>
        acpi_sdt_hdr_t *hdr = (acpi_sdt_hdr_t *) (rsdt->ent[i]);
  102427:	8b 02                	mov    (%edx),%eax
  102429:	89 c5                	mov    %eax,%ebp
        if (hdr->sig == sig && sum((uint8_t *) hdr, hdr->length) == 0) {
  10242b:	39 18                	cmp    %ebx,(%eax)
  10242d:	75 f1                	jne    102420 <acpi_probe_rsdt_ent+0x30>
  10242f:	8b 70 04             	mov    0x4(%eax),%esi
    for (i = 0; i < len; i++) {
  102432:	85 f6                	test   %esi,%esi
  102434:	7e 1e                	jle    102454 <acpi_probe_rsdt_ent+0x64>
    sum = 0;
  102436:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  10243a:	01 c6                	add    %eax,%esi
  10243c:	31 c9                	xor    %ecx,%ecx
  10243e:	66 90                	xchg   %ax,%ax
        sum += addr[i];
  102440:	0f b6 38             	movzbl (%eax),%edi
    for (i = 0; i < len; i++) {
  102443:	83 c0 01             	add    $0x1,%eax
        sum += addr[i];
  102446:	01 f9                	add    %edi,%ecx
    for (i = 0; i < len; i++) {
  102448:	39 c6                	cmp    %eax,%esi
  10244a:	75 f4                	jne    102440 <acpi_probe_rsdt_ent+0x50>
        if (hdr->sig == sig && sum((uint8_t *) hdr, hdr->length) == 0) {
  10244c:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  102450:	84 c9                	test   %cl,%cl
  102452:	75 cc                	jne    102420 <acpi_probe_rsdt_ent+0x30>
        }
        p = (uint8_t *) &rsdt->ent[i + 1];
    }

    return NULL;
}
  102454:	83 c4 1c             	add    $0x1c,%esp
  102457:	89 e8                	mov    %ebp,%eax
  102459:	5b                   	pop    %ebx
  10245a:	5e                   	pop    %esi
  10245b:	5f                   	pop    %edi
  10245c:	5d                   	pop    %ebp
  10245d:	c3                   	ret
  10245e:	66 90                	xchg   %ax,%ax
  102460:	83 c4 1c             	add    $0x1c,%esp
    return NULL;
  102463:	31 ed                	xor    %ebp,%ebp
}
  102465:	5b                   	pop    %ebx
  102466:	89 e8                	mov    %ebp,%eax
  102468:	5e                   	pop    %esi
  102469:	5f                   	pop    %edi
  10246a:	5d                   	pop    %ebp
  10246b:	c3                   	ret
    KERN_ASSERT(rsdt != NULL);
  10246c:	8d 83 32 62 ff ff    	lea    -0x9dce(%ebx),%eax
  102472:	50                   	push   %eax
  102473:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  102479:	50                   	push   %eax
  10247a:	8d 83 22 62 ff ff    	lea    -0x9dde(%ebx),%eax
  102480:	6a 41                	push   $0x41
  102482:	50                   	push   %eax
  102483:	e8 68 23 00 00       	call   1047f0 <debug_panic>
  102488:	83 c4 10             	add    $0x10,%esp
  10248b:	e9 7a ff ff ff       	jmp    10240a <acpi_probe_rsdt_ent+0x1a>

00102490 <acpi_probe_xsdt>:

acpi_xsdt_t *acpi_probe_xsdt(acpi_rsdp_t *rsdp)
{
  102490:	56                   	push   %esi
  102491:	53                   	push   %ebx
  102492:	e8 0b df ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  102497:	81 c3 5d 4b 01 00    	add    $0x14b5d,%ebx
  10249d:	83 ec 04             	sub    $0x4,%esp
  1024a0:	8b 74 24 10          	mov    0x10(%esp),%esi
    KERN_ASSERT(rsdp != NULL);
  1024a4:	85 f6                	test   %esi,%esi
  1024a6:	74 50                	je     1024f8 <acpi_probe_xsdt+0x68>

    acpi_xsdt_t *xsdt = (acpi_xsdt_t *) (uintptr_t) rsdp->xsdt_addr;
  1024a8:	8b 5e 18             	mov    0x18(%esi),%ebx
  1024ab:	89 d8                	mov    %ebx,%eax
    if (xsdt == NULL)
  1024ad:	85 db                	test   %ebx,%ebx
  1024af:	74 2a                	je     1024db <acpi_probe_xsdt+0x4b>
        return NULL;
    if (xsdt->sig == ACPI_XSDT_SIG && sum((uint8_t *) xsdt, xsdt->length) == 0) {
  1024b1:	81 3b 58 53 44 54    	cmpl   $0x54445358,(%ebx)
  1024b7:	75 2f                	jne    1024e8 <acpi_probe_xsdt+0x58>
  1024b9:	8b 73 04             	mov    0x4(%ebx),%esi
    for (i = 0; i < len; i++) {
  1024bc:	85 f6                	test   %esi,%esi
  1024be:	7e 1b                	jle    1024db <acpi_probe_xsdt+0x4b>
  1024c0:	01 de                	add    %ebx,%esi
    sum = 0;
  1024c2:	31 d2                	xor    %edx,%edx
  1024c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        sum += addr[i];
  1024c8:	0f b6 08             	movzbl (%eax),%ecx
    for (i = 0; i < len; i++) {
  1024cb:	83 c0 01             	add    $0x1,%eax
        sum += addr[i];
  1024ce:	01 ca                	add    %ecx,%edx
    for (i = 0; i < len; i++) {
  1024d0:	39 c6                	cmp    %eax,%esi
  1024d2:	75 f4                	jne    1024c8 <acpi_probe_xsdt+0x38>
        return NULL;
  1024d4:	31 c0                	xor    %eax,%eax
  1024d6:	84 d2                	test   %dl,%dl
  1024d8:	0f 45 d8             	cmovne %eax,%ebx
        return xsdt;
    }

    return NULL;
}
  1024db:	83 c4 04             	add    $0x4,%esp
  1024de:	89 d8                	mov    %ebx,%eax
  1024e0:	5b                   	pop    %ebx
  1024e1:	5e                   	pop    %esi
  1024e2:	c3                   	ret
  1024e3:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        return NULL;
  1024e8:	31 db                	xor    %ebx,%ebx
}
  1024ea:	83 c4 04             	add    $0x4,%esp
  1024ed:	89 d8                	mov    %ebx,%eax
  1024ef:	5b                   	pop    %ebx
  1024f0:	5e                   	pop    %esi
  1024f1:	c3                   	ret
  1024f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    KERN_ASSERT(rsdp != NULL);
  1024f8:	8d 83 15 62 ff ff    	lea    -0x9deb(%ebx),%eax
  1024fe:	50                   	push   %eax
  1024ff:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  102505:	50                   	push   %eax
  102506:	8d 83 22 62 ff ff    	lea    -0x9dde(%ebx),%eax
  10250c:	6a 54                	push   $0x54
  10250e:	50                   	push   %eax
  10250f:	e8 dc 22 00 00       	call   1047f0 <debug_panic>
  102514:	83 c4 10             	add    $0x10,%esp
  102517:	eb 8f                	jmp    1024a8 <acpi_probe_xsdt+0x18>
  102519:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00102520 <acpi_probe_xsdt_ent>:

acpi_sdt_hdr_t *acpi_probe_xsdt_ent(acpi_xsdt_t *xsdt, const uint32_t sig)
{
  102520:	55                   	push   %ebp
  102521:	57                   	push   %edi
  102522:	56                   	push   %esi
  102523:	53                   	push   %ebx
  102524:	e8 79 de ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  102529:	81 c3 cb 4a 01 00    	add    $0x14acb,%ebx
  10252f:	83 ec 1c             	sub    $0x1c,%esp
  102532:	8b 7c 24 30          	mov    0x30(%esp),%edi
    KERN_ASSERT(xsdt != NULL);
  102536:	85 ff                	test   %edi,%edi
  102538:	74 62                	je     10259c <acpi_probe_xsdt_ent+0x7c>

    uint8_t *p = (uint8_t *) &xsdt->ent[0];
  10253a:	8d 57 24             	lea    0x24(%edi),%edx
    uint8_t *e = (uint8_t *) xsdt + xsdt->length;
  10253d:	03 7f 04             	add    0x4(%edi),%edi

    int i;
    for (i = 0; p < e; i++) {
  102540:	39 fa                	cmp    %edi,%edx
  102542:	73 4c                	jae    102590 <acpi_probe_xsdt_ent+0x70>
  102544:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  102548:	eb 0d                	jmp    102557 <acpi_probe_xsdt_ent+0x37>
  10254a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  102550:	83 c2 08             	add    $0x8,%edx
  102553:	39 fa                	cmp    %edi,%edx
  102555:	73 39                	jae    102590 <acpi_probe_xsdt_ent+0x70>
        acpi_sdt_hdr_t *hdr = (acpi_sdt_hdr_t *) (uintptr_t) xsdt->ent[i];
  102557:	8b 02                	mov    (%edx),%eax
  102559:	89 c5                	mov    %eax,%ebp
        if (hdr->sig == sig && sum((uint8_t *) hdr, hdr->length) == 0) {
  10255b:	39 18                	cmp    %ebx,(%eax)
  10255d:	75 f1                	jne    102550 <acpi_probe_xsdt_ent+0x30>
  10255f:	8b 70 04             	mov    0x4(%eax),%esi
    for (i = 0; i < len; i++) {
  102562:	85 f6                	test   %esi,%esi
  102564:	7e 1e                	jle    102584 <acpi_probe_xsdt_ent+0x64>
    sum = 0;
  102566:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  10256a:	01 c6                	add    %eax,%esi
  10256c:	31 c9                	xor    %ecx,%ecx
  10256e:	66 90                	xchg   %ax,%ax
        sum += addr[i];
  102570:	0f b6 38             	movzbl (%eax),%edi
    for (i = 0; i < len; i++) {
  102573:	83 c0 01             	add    $0x1,%eax
        sum += addr[i];
  102576:	01 f9                	add    %edi,%ecx
    for (i = 0; i < len; i++) {
  102578:	39 c6                	cmp    %eax,%esi
  10257a:	75 f4                	jne    102570 <acpi_probe_xsdt_ent+0x50>
        if (hdr->sig == sig && sum((uint8_t *) hdr, hdr->length) == 0) {
  10257c:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  102580:	84 c9                	test   %cl,%cl
  102582:	75 cc                	jne    102550 <acpi_probe_xsdt_ent+0x30>
        }
        p = (uint8_t *) &xsdt->ent[i + 1];
    }

    return NULL;
}
  102584:	83 c4 1c             	add    $0x1c,%esp
  102587:	89 e8                	mov    %ebp,%eax
  102589:	5b                   	pop    %ebx
  10258a:	5e                   	pop    %esi
  10258b:	5f                   	pop    %edi
  10258c:	5d                   	pop    %ebp
  10258d:	c3                   	ret
  10258e:	66 90                	xchg   %ax,%ax
  102590:	83 c4 1c             	add    $0x1c,%esp
    return NULL;
  102593:	31 ed                	xor    %ebp,%ebp
}
  102595:	5b                   	pop    %ebx
  102596:	89 e8                	mov    %ebp,%eax
  102598:	5e                   	pop    %esi
  102599:	5f                   	pop    %edi
  10259a:	5d                   	pop    %ebp
  10259b:	c3                   	ret
    KERN_ASSERT(xsdt != NULL);
  10259c:	8d 83 3f 62 ff ff    	lea    -0x9dc1(%ebx),%eax
  1025a2:	50                   	push   %eax
  1025a3:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  1025a9:	50                   	push   %eax
  1025aa:	8d 83 22 62 ff ff    	lea    -0x9dde(%ebx),%eax
  1025b0:	6a 62                	push   $0x62
  1025b2:	50                   	push   %eax
  1025b3:	e8 38 22 00 00       	call   1047f0 <debug_panic>
  1025b8:	83 c4 10             	add    $0x10,%esp
  1025bb:	e9 7a ff ff ff       	jmp    10253a <acpi_probe_xsdt_ent+0x1a>

001025c0 <lapic_register>:
{
}

void lapic_register(uintptr_t lapic_addr)
{
    lapic = (lapic_t *) lapic_addr;
  1025c0:	e8 d5 dd ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  1025c5:	05 2f 4a 01 00       	add    $0x14a2f,%eax
  1025ca:	8b 54 24 04          	mov    0x4(%esp),%edx
  1025ce:	89 90 9c a8 08 00    	mov    %edx,0x8a89c(%eax)
}
  1025d4:	c3                   	ret
  1025d5:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1025dc:	00 
  1025dd:	8d 76 00             	lea    0x0(%esi),%esi

001025e0 <lapic_init>:

/*
 * Initialize local APIC.
 */
void lapic_init()
{
  1025e0:	55                   	push   %ebp
  1025e1:	57                   	push   %edi
  1025e2:	56                   	push   %esi
  1025e3:	53                   	push   %ebx
  1025e4:	e8 b9 dd ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1025e9:	81 c3 0b 4a 01 00    	add    $0x14a0b,%ebx
  1025ef:	83 ec 2c             	sub    $0x2c,%esp
    if (!lapic)
  1025f2:	8b 83 9c a8 08 00    	mov    0x8a89c(%ebx),%eax
  1025f8:	8d 93 55 62 ff ff    	lea    -0x9dab(%ebx),%edx
  1025fe:	89 54 24 10          	mov    %edx,0x10(%esp)
  102602:	85 c0                	test   %eax,%eax
  102604:	0f 84 9b 02 00 00    	je     1028a5 <lapic_init+0x2c5>
    lapic[index] = value;
  10260a:	c7 80 f0 00 00 00 27 	movl   $0x127,0xf0(%eax)
  102611:	01 00 00 
    lapic[LAPIC_ID];
  102614:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  102617:	c7 80 e0 03 00 00 0b 	movl   $0xb,0x3e0(%eax)
  10261e:	00 00 00 
    lapic[LAPIC_ID];
  102621:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  102624:	c7 80 20 03 00 00 20 	movl   $0x20020,0x320(%eax)
  10262b:	00 02 00 
    lapic[LAPIC_ID];
  10262e:	8b 50 20             	mov    0x20(%eax),%edx
    int i;
    for (i = 0; i < 5; i++) {
        lapic_ticks_per_ms = lapic_calibrate_timer(CAL_LATCH, CAL_MS, CAL_PIT_LOOPS);
        if (lapic_ticks_per_ms != ~(uint32_t) 0x0)
            break;
        KERN_DEBUG("[%d] Retry to calibrate internal timer of LAPIC.\n", i);
  102631:	8d 93 84 6d ff ff    	lea    -0x927c(%ebx),%edx
    for (i = 0; i < 5; i++) {
  102637:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  10263e:	00 
        KERN_DEBUG("[%d] Retry to calibrate internal timer of LAPIC.\n", i);
  10263f:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    lapic[index] = value;
  102643:	c7 80 80 03 00 00 ff 	movl   $0xffffffff,0x380(%eax)
  10264a:	ff ff ff 
    outb(0x61, (inb(0x61) & ~0x02) | 0x01);
  10264d:	83 ec 0c             	sub    $0xc,%esp
    lapic[LAPIC_ID];
  102650:	8b 40 20             	mov    0x20(%eax),%eax
    outb(0x61, (inb(0x61) & ~0x02) | 0x01);
  102653:	6a 61                	push   $0x61
  102655:	e8 96 2f 00 00       	call   1055f0 <inb>
  10265a:	5a                   	pop    %edx
  10265b:	59                   	pop    %ecx
  10265c:	25 fc 00 00 00       	and    $0xfc,%eax
  102661:	83 c8 01             	or     $0x1,%eax
  102664:	50                   	push   %eax
  102665:	6a 61                	push   $0x61
  102667:	e8 b4 2f 00 00       	call   105620 <outb>
    outb(0x43, 0xb0);
  10266c:	5e                   	pop    %esi
  10266d:	5f                   	pop    %edi
  10266e:	68 b0 00 00 00       	push   $0xb0
  102673:	6a 43                	push   $0x43
    timermin = ~(uint32_t) 0x0;
  102675:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    outb(0x43, 0xb0);
  10267a:	e8 a1 2f 00 00       	call   105620 <outb>
    outb(0x42, latch & 0xff);
  10267f:	5d                   	pop    %ebp
  102680:	58                   	pop    %eax
  102681:	68 9b 00 00 00       	push   $0x9b
  102686:	6a 42                	push   $0x42
    timermax = 0;
  102688:	31 ed                	xor    %ebp,%ebp
    outb(0x42, latch & 0xff);
  10268a:	e8 91 2f 00 00       	call   105620 <outb>
    outb(0x42, latch >> 8);
  10268f:	58                   	pop    %eax
  102690:	5a                   	pop    %edx
  102691:	6a 2e                	push   $0x2e
  102693:	6a 42                	push   $0x42
  102695:	e8 86 2f 00 00       	call   105620 <outb>
    return lapic[index];
  10269a:	8b 83 9c a8 08 00    	mov    0x8a89c(%ebx),%eax
    while ((inb(0x61) & 0x20) == 0) {
  1026a0:	83 c4 10             	add    $0x10,%esp
    pitcnt = 0;
  1026a3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1026aa:	00 
    return lapic[index];
  1026ab:	8b 80 90 03 00 00    	mov    0x390(%eax),%eax
    while ((inb(0x61) & 0x20) == 0) {
  1026b1:	89 44 24 18          	mov    %eax,0x18(%esp)
    timer = timer1 = timer2 = lapic_read(LAPIC_TCCR);
  1026b5:	89 c6                	mov    %eax,%esi
  1026b7:	89 e8                	mov    %ebp,%eax
  1026b9:	89 fd                	mov    %edi,%ebp
  1026bb:	89 c7                	mov    %eax,%edi
    while ((inb(0x61) & 0x20) == 0) {
  1026bd:	eb 20                	jmp    1026df <lapic_init+0xff>
  1026bf:	90                   	nop
    return lapic[index];
  1026c0:	8b 83 9c a8 08 00    	mov    0x8a89c(%ebx),%eax
  1026c6:	8b 80 90 03 00 00    	mov    0x390(%eax),%eax
        delta = timer - timer2;
  1026cc:	29 c6                	sub    %eax,%esi
        if (delta < timermin)
  1026ce:	39 f5                	cmp    %esi,%ebp
  1026d0:	0f 47 ee             	cmova  %esi,%ebp
        if (delta > timermax)
  1026d3:	39 f7                	cmp    %esi,%edi
  1026d5:	0f 42 fe             	cmovb  %esi,%edi
        pitcnt++;
  1026d8:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
        timer = timer2;
  1026dd:	89 c6                	mov    %eax,%esi
    while ((inb(0x61) & 0x20) == 0) {
  1026df:	83 ec 0c             	sub    $0xc,%esp
  1026e2:	6a 61                	push   $0x61
  1026e4:	e8 07 2f 00 00       	call   1055f0 <inb>
  1026e9:	83 c4 10             	add    $0x10,%esp
  1026ec:	a8 20                	test   $0x20,%al
  1026ee:	74 d0                	je     1026c0 <lapic_init+0xe0>
    if (pitcnt < loopmin || timermax > 10 * timermin)
  1026f0:	81 7c 24 0c e7 03 00 	cmpl   $0x3e7,0xc(%esp)
  1026f7:	00 
  1026f8:	89 fa                	mov    %edi,%edx
  1026fa:	8b 44 24 18          	mov    0x18(%esp),%eax
  1026fe:	89 ef                	mov    %ebp,%edi
  102700:	0f 8e 3a 01 00 00    	jle    102840 <lapic_init+0x260>
  102706:	8d 0c bf             	lea    (%edi,%edi,4),%ecx
  102709:	01 c9                	add    %ecx,%ecx
  10270b:	39 d1                	cmp    %edx,%ecx
  10270d:	0f 82 2d 01 00 00    	jb     102840 <lapic_init+0x260>
    delta = timer1 - timer2;
  102713:	29 f0                	sub    %esi,%eax
    return delta / ms;
  102715:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
    if (lapic_ticks_per_ms == ~(uint32_t) 0x0) {
        KERN_WARN("Failed to calibrate internal timer of LAPIC.\n");
        KERN_DEBUG("Assume LAPIC timer freq = 0.5 GHz.\n");
        lapic_ticks_per_ms = 500000;
    } else
        KERN_DEBUG("LAPIC timer freq = %llu Hz.\n",
  10271a:	83 ec 0c             	sub    $0xc,%esp
    return delta / ms;
  10271d:	f7 e2                	mul    %edx
        KERN_DEBUG("LAPIC timer freq = %llu Hz.\n",
  10271f:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    return delta / ms;
  102724:	c1 ea 03             	shr    $0x3,%edx
  102727:	89 d6                	mov    %edx,%esi
        KERN_DEBUG("LAPIC timer freq = %llu Hz.\n",
  102729:	f7 e2                	mul    %edx
  10272b:	52                   	push   %edx
  10272c:	50                   	push   %eax
  10272d:	8d 83 66 62 ff ff    	lea    -0x9d9a(%ebx),%eax
  102733:	50                   	push   %eax
  102734:	6a 7d                	push   $0x7d
  102736:	ff 74 24 2c          	push   0x2c(%esp)
  10273a:	e8 51 20 00 00       	call   104790 <debug_normal>
                   (uint64_t) lapic_ticks_per_ms * 1000);

    uint32_t ticr = lapic_ticks_per_ms * 1000 / LAPIC_TIMER_INTR_FREQ;
  10273f:	69 d6 e8 03 00 00    	imul   $0x3e8,%esi,%edx
  102745:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  10274a:	83 c4 20             	add    $0x20,%esp
  10274d:	f7 e2                	mul    %edx
  10274f:	c1 ea 06             	shr    $0x6,%edx
  102752:	89 d6                	mov    %edx,%esi
    KERN_DEBUG("Set LAPIC TICR = %x.\n", ticr);
  102754:	8d 83 83 62 ff ff    	lea    -0x9d7d(%ebx),%eax
  10275a:	56                   	push   %esi
  10275b:	50                   	push   %eax
  10275c:	68 81 00 00 00       	push   $0x81
  102761:	ff 74 24 1c          	push   0x1c(%esp)
  102765:	e8 26 20 00 00       	call   104790 <debug_normal>
    lapic[index] = value;
  10276a:	8b 83 9c a8 08 00    	mov    0x8a89c(%ebx),%eax
    lapic_write(LAPIC_LINT0, LAPIC_LINT_MASKED);
    lapic_write(LAPIC_LINT1, LAPIC_LINT_MASKED);

    // Disable performance counter overflow interrupts
    // on machines that provide that interrupt entry.
    if (((lapic_read(LAPIC_VER) >> 16) & 0xFF) >= 4)
  102770:	83 c4 10             	add    $0x10,%esp
    lapic[index] = value;
  102773:	89 b0 80 03 00 00    	mov    %esi,0x380(%eax)
    lapic[LAPIC_ID];
  102779:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  10277c:	c7 80 50 03 00 00 00 	movl   $0x10000,0x350(%eax)
  102783:	00 01 00 
    lapic[LAPIC_ID];
  102786:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  102789:	c7 80 60 03 00 00 00 	movl   $0x10000,0x360(%eax)
  102790:	00 01 00 
    lapic[LAPIC_ID];
  102793:	8b 50 20             	mov    0x20(%eax),%edx
    return lapic[index];
  102796:	8b 50 30             	mov    0x30(%eax),%edx
    if (((lapic_read(LAPIC_VER) >> 16) & 0xFF) >= 4)
  102799:	81 e2 00 00 fc 00    	and    $0xfc0000,%edx
  10279f:	74 0d                	je     1027ae <lapic_init+0x1ce>
    lapic[index] = value;
  1027a1:	c7 80 40 03 00 00 00 	movl   $0x10000,0x340(%eax)
  1027a8:	00 01 00 
    lapic[LAPIC_ID];
  1027ab:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  1027ae:	c7 80 e0 00 00 00 00 	movl   $0xf0000000,0xe0(%eax)
  1027b5:	00 00 f0 
    lapic[LAPIC_ID];
  1027b8:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  1027bb:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%eax)
  1027c2:	00 00 00 
    lapic[LAPIC_ID];
  1027c5:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  1027c8:	c7 80 70 03 00 00 32 	movl   $0x32,0x370(%eax)
  1027cf:	00 00 00 
    lapic[LAPIC_ID];
  1027d2:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  1027d5:	c7 80 80 02 00 00 00 	movl   $0x0,0x280(%eax)
  1027dc:	00 00 00 
    lapic[LAPIC_ID];
  1027df:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  1027e2:	c7 80 80 02 00 00 00 	movl   $0x0,0x280(%eax)
  1027e9:	00 00 00 
    lapic[LAPIC_ID];
  1027ec:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  1027ef:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
  1027f6:	00 00 00 
    lapic[LAPIC_ID];
  1027f9:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  1027fc:	c7 80 10 03 00 00 00 	movl   $0x0,0x310(%eax)
  102803:	00 00 00 
    lapic[LAPIC_ID];
  102806:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  102809:	c7 80 00 03 00 00 00 	movl   $0x88500,0x300(%eax)
  102810:	85 08 00 
    lapic[LAPIC_ID];
  102813:	8b 50 20             	mov    0x20(%eax),%edx

    // Send an Init Level De-Assert to synchronise arbitration ID's.
    lapic_write(LAPIC_ICRHI, 0);
    lapic_write(LAPIC_ICRLO,
                LAPIC_ICRLO_BCAST | LAPIC_ICRLO_INIT | LAPIC_ICRLO_LEVEL);
    while (lapic_read(LAPIC_ICRLO) & LAPIC_ICRLO_DELIVS);
  102816:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10281d:	00 
  10281e:	66 90                	xchg   %ax,%ax
    return lapic[index];
  102820:	8b 90 00 03 00 00    	mov    0x300(%eax),%edx
    while (lapic_read(LAPIC_ICRLO) & LAPIC_ICRLO_DELIVS);
  102826:	80 e6 10             	and    $0x10,%dh
  102829:	75 f5                	jne    102820 <lapic_init+0x240>
    lapic[index] = value;
  10282b:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
  102832:	00 00 00 
    lapic[LAPIC_ID];
  102835:	8b 40 20             	mov    0x20(%eax),%eax

    // Enable interrupts on the APIC (but not on the processor).
    lapic_write(LAPIC_TPR, 0);
}
  102838:	83 c4 2c             	add    $0x2c,%esp
  10283b:	5b                   	pop    %ebx
  10283c:	5e                   	pop    %esi
  10283d:	5f                   	pop    %edi
  10283e:	5d                   	pop    %ebp
  10283f:	c3                   	ret
        KERN_DEBUG("[%d] Retry to calibrate internal timer of LAPIC.\n", i);
  102840:	8b 7c 24 14          	mov    0x14(%esp),%edi
  102844:	57                   	push   %edi
  102845:	ff 74 24 20          	push   0x20(%esp)
  102849:	6a 75                	push   $0x75
  10284b:	ff 74 24 1c          	push   0x1c(%esp)
  10284f:	e8 3c 1f 00 00       	call   104790 <debug_normal>
    for (i = 0; i < 5; i++) {
  102854:	89 f8                	mov    %edi,%eax
  102856:	83 c0 01             	add    $0x1,%eax
  102859:	89 44 24 24          	mov    %eax,0x24(%esp)
  10285d:	83 c4 10             	add    $0x10,%esp
  102860:	83 f8 05             	cmp    $0x5,%eax
  102863:	74 0b                	je     102870 <lapic_init+0x290>
    lapic[index] = value;
  102865:	8b 83 9c a8 08 00    	mov    0x8a89c(%ebx),%eax
  10286b:	e9 d3 fd ff ff       	jmp    102643 <lapic_init+0x63>
        KERN_WARN("Failed to calibrate internal timer of LAPIC.\n");
  102870:	83 ec 04             	sub    $0x4,%esp
  102873:	8d 83 b8 6d ff ff    	lea    -0x9248(%ebx),%eax
  102879:	be 20 a1 07 00       	mov    $0x7a120,%esi
  10287e:	50                   	push   %eax
  10287f:	6a 79                	push   $0x79
  102881:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  102885:	57                   	push   %edi
  102886:	e8 75 20 00 00       	call   104900 <debug_warn>
        KERN_DEBUG("Assume LAPIC timer freq = 0.5 GHz.\n");
  10288b:	83 c4 0c             	add    $0xc,%esp
  10288e:	8d 83 e8 6d ff ff    	lea    -0x9218(%ebx),%eax
  102894:	50                   	push   %eax
  102895:	6a 7a                	push   $0x7a
  102897:	57                   	push   %edi
  102898:	e8 f3 1e 00 00       	call   104790 <debug_normal>
        lapic_ticks_per_ms = 500000;
  10289d:	83 c4 10             	add    $0x10,%esp
  1028a0:	e9 af fe ff ff       	jmp    102754 <lapic_init+0x174>
        KERN_PANIC("NO LAPIC");
  1028a5:	83 ec 04             	sub    $0x4,%esp
  1028a8:	8d 83 4c 62 ff ff    	lea    -0x9db4(%ebx),%eax
  1028ae:	50                   	push   %eax
  1028af:	6a 62                	push   $0x62
  1028b1:	ff 74 24 1c          	push   0x1c(%esp)
  1028b5:	e8 36 1f 00 00       	call   1047f0 <debug_panic>
    lapic[index] = value;
  1028ba:	8b 83 9c a8 08 00    	mov    0x8a89c(%ebx),%eax
  1028c0:	83 c4 10             	add    $0x10,%esp
  1028c3:	e9 42 fd ff ff       	jmp    10260a <lapic_init+0x2a>
  1028c8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1028cf:	00 

001028d0 <lapic_eoi>:
/*
 * Acknowledge the end of interrupts.
 */
void lapic_eoi(void)
{
    if (lapic)
  1028d0:	e8 c5 da ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  1028d5:	05 1f 47 01 00       	add    $0x1471f,%eax
  1028da:	8b 80 9c a8 08 00    	mov    0x8a89c(%eax),%eax
  1028e0:	85 c0                	test   %eax,%eax
  1028e2:	74 0d                	je     1028f1 <lapic_eoi+0x21>
    lapic[index] = value;
  1028e4:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
  1028eb:	00 00 00 
    lapic[LAPIC_ID];
  1028ee:	8b 40 20             	mov    0x20(%eax),%eax
        lapic_write(LAPIC_EOI, 0);
}
  1028f1:	c3                   	ret
  1028f2:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1028f9:	00 
  1028fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00102900 <lapic_startcpu>:
/*
 * Start additional processor running bootstrap code at addr.
 * See Appendix B of MultiProcessor Specification.
 */
void lapic_startcpu(lapicid_t apicid, uintptr_t addr)
{
  102900:	57                   	push   %edi
  102901:	56                   	push   %esi
  102902:	53                   	push   %ebx
  102903:	8b 74 24 14          	mov    0x14(%esp),%esi
  102907:	e8 96 da ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10290c:	81 c3 e8 46 01 00    	add    $0x146e8,%ebx
  102912:	8b 7c 24 10          	mov    0x10(%esp),%edi
    uint16_t *wrv;

    // "The BSP must initialize CMOS shutdown code to 0AH
    // and the warm reset vector (DWORD based at 40:67) to point at
    // the AP startup code prior to the [universal startup algorithm]."
    outb(IO_RTC, 0xF);                      // offset 0xF is shutdown code
  102916:	83 ec 08             	sub    $0x8,%esp
    lapic[index] = value;
  102919:	c1 e7 18             	shl    $0x18,%edi
    outb(IO_RTC, 0xF);                      // offset 0xF is shutdown code
  10291c:	6a 0f                	push   $0xf
  10291e:	6a 70                	push   $0x70
  102920:	e8 fb 2c 00 00       	call   105620 <outb>
    outb(IO_RTC + 1, 0x0A);
  102925:	58                   	pop    %eax
  102926:	5a                   	pop    %edx
  102927:	6a 0a                	push   $0xa
  102929:	6a 71                	push   $0x71
  10292b:	e8 f0 2c 00 00       	call   105620 <outb>
    wrv = (uint16_t *) (0x40 << 4 | 0x67);  // Warm reset vector
    wrv[0] = 0;
    wrv[1] = addr >> 4;
  102930:	89 f0                	mov    %esi,%eax
    // when it is in the halted state due to an INIT. So the second
    // should be ignored, but it is part of the official Intel algorithm.
    // Bochs complains about the second one. Too bad for Bochs.
    for (i = 0; i < 2; i++) {
        lapic_write(LAPIC_ICRHI, apicid << 24);
        lapic_write(LAPIC_ICRLO, LAPIC_ICRLO_STARTUP | (addr >> 12));
  102932:	c1 ee 0c             	shr    $0xc,%esi
        microdelay(200);
    }
}
  102935:	83 c4 10             	add    $0x10,%esp
    wrv[1] = addr >> 4;
  102938:	c1 e8 04             	shr    $0x4,%eax
        lapic_write(LAPIC_ICRLO, LAPIC_ICRLO_STARTUP | (addr >> 12));
  10293b:	81 ce 00 06 00 00    	or     $0x600,%esi
    wrv[0] = 0;
  102941:	31 c9                	xor    %ecx,%ecx
    wrv[1] = addr >> 4;
  102943:	66 a3 69 04 00 00    	mov    %ax,0x469
    lapic[index] = value;
  102949:	8b 83 9c a8 08 00    	mov    0x8a89c(%ebx),%eax
    wrv[0] = 0;
  10294f:	66 89 0d 67 04 00 00 	mov    %cx,0x467
    lapic[index] = value;
  102956:	89 b8 10 03 00 00    	mov    %edi,0x310(%eax)
    lapic[LAPIC_ID];
  10295c:	8b 48 20             	mov    0x20(%eax),%ecx
    lapic[index] = value;
  10295f:	c7 80 00 03 00 00 00 	movl   $0xc500,0x300(%eax)
  102966:	c5 00 00 
    lapic[LAPIC_ID];
  102969:	8b 48 20             	mov    0x20(%eax),%ecx
    lapic[index] = value;
  10296c:	c7 80 00 03 00 00 00 	movl   $0x8500,0x300(%eax)
  102973:	85 00 00 
    lapic[LAPIC_ID];
  102976:	8b 48 20             	mov    0x20(%eax),%ecx
    lapic[index] = value;
  102979:	89 b8 10 03 00 00    	mov    %edi,0x310(%eax)
    lapic[LAPIC_ID];
  10297f:	8b 48 20             	mov    0x20(%eax),%ecx
    lapic[index] = value;
  102982:	89 b0 00 03 00 00    	mov    %esi,0x300(%eax)
    lapic[LAPIC_ID];
  102988:	8b 48 20             	mov    0x20(%eax),%ecx
    lapic[index] = value;
  10298b:	89 b8 10 03 00 00    	mov    %edi,0x310(%eax)
    lapic[LAPIC_ID];
  102991:	8b 50 20             	mov    0x20(%eax),%edx
    lapic[index] = value;
  102994:	89 b0 00 03 00 00    	mov    %esi,0x300(%eax)
}
  10299a:	5b                   	pop    %ebx
    lapic[LAPIC_ID];
  10299b:	8b 40 20             	mov    0x20(%eax),%eax
}
  10299e:	5e                   	pop    %esi
  10299f:	5f                   	pop    %edi
  1029a0:	c3                   	ret
  1029a1:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1029a8:	00 
  1029a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001029b0 <lapic_read_debug>:
    return lapic[index];
  1029b0:	e8 e5 d9 ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  1029b5:	05 3f 46 01 00       	add    $0x1463f,%eax
  1029ba:	8b 54 24 04          	mov    0x4(%esp),%edx
  1029be:	8b 80 9c a8 08 00    	mov    0x8a89c(%eax),%eax
  1029c4:	8d 04 90             	lea    (%eax,%edx,4),%eax
  1029c7:	8b 00                	mov    (%eax),%eax

uint32_t lapic_read_debug(int index)
{
    return lapic_read(index);
}
  1029c9:	c3                   	ret
  1029ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001029d0 <lapic_send_ipi>:
/*
 * Send an IPI.
 */
void lapic_send_ipi(lapicid_t apicid, uint8_t vector,
                    uint32_t deliver_mode, uint32_t shorthand_mode)
{
  1029d0:	55                   	push   %ebp
  1029d1:	57                   	push   %edi
  1029d2:	56                   	push   %esi
  1029d3:	53                   	push   %ebx
  1029d4:	e8 c9 d9 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1029d9:	81 c3 1b 46 01 00    	add    $0x1461b,%ebx
  1029df:	83 ec 0c             	sub    $0xc,%esp
    KERN_ASSERT(deliver_mode != LAPIC_ICRLO_INIT &&
  1029e2:	8b 44 24 28          	mov    0x28(%esp),%eax
{
  1029e6:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  1029ea:	8b 74 24 24          	mov    0x24(%esp),%esi
  1029ee:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    KERN_ASSERT(deliver_mode != LAPIC_ICRLO_INIT &&
  1029f2:	2d 00 05 00 00       	sub    $0x500,%eax
  1029f7:	a9 ff fe ff ff       	test   $0xfffffeff,%eax
  1029fc:	74 5a                	je     102a58 <lapic_send_ipi+0x88>
                deliver_mode != LAPIC_ICRLO_STARTUP);
    KERN_ASSERT(vector >= T_IPI0);
  1029fe:	89 f0                	mov    %esi,%eax
  102a00:	3c 3e                	cmp    $0x3e,%al
  102a02:	77 11                	ja     102a15 <lapic_send_ipi+0x45>
  102a04:	eb 7a                	jmp    102a80 <lapic_send_ipi+0xb0>
  102a06:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  102a0d:	00 
  102a0e:	66 90                	xchg   %ax,%ax

    while (lapic_read(LAPIC_ICRLO) & LAPIC_ICRLO_DELIVS)
        pause();
  102a10:	e8 2b 2a 00 00       	call   105440 <pause>
    return lapic[index];
  102a15:	8b 83 9c a8 08 00    	mov    0x8a89c(%ebx),%eax
  102a1b:	8b 90 00 03 00 00    	mov    0x300(%eax),%edx
    while (lapic_read(LAPIC_ICRLO) & LAPIC_ICRLO_DELIVS)
  102a21:	80 e6 10             	and    $0x10,%dh
  102a24:	75 ea                	jne    102a10 <lapic_send_ipi+0x40>

    if (shorthand_mode == LAPIC_ICRLO_NOBCAST)
  102a26:	85 ff                	test   %edi,%edi
  102a28:	75 0c                	jne    102a36 <lapic_send_ipi+0x66>
    lapic[index] = value;
  102a2a:	c1 e5 18             	shl    $0x18,%ebp
  102a2d:	89 a8 10 03 00 00    	mov    %ebp,0x310(%eax)
    lapic[LAPIC_ID];
  102a33:	8b 50 20             	mov    0x20(%eax),%edx
        lapic_write(LAPIC_ICRHI,
                    (apicid << LAPIC_ICRHI_DEST_SHIFT) & LAPIC_ICRHI_DEST_MASK);

    lapic_write(LAPIC_ICRLO,
                shorthand_mode |  /* LAPIC_ICRLO_LEVEL | */
                deliver_mode | (vector & LAPIC_ICRLO_VECTOR));
  102a36:	89 f1                	mov    %esi,%ecx
  102a38:	0f b6 f1             	movzbl %cl,%esi
  102a3b:	09 fe                	or     %edi,%esi
  102a3d:	0b 74 24 28          	or     0x28(%esp),%esi
    lapic[index] = value;
  102a41:	89 b0 00 03 00 00    	mov    %esi,0x300(%eax)
    lapic[LAPIC_ID];
  102a47:	8b 40 20             	mov    0x20(%eax),%eax
}
  102a4a:	83 c4 0c             	add    $0xc,%esp
  102a4d:	5b                   	pop    %ebx
  102a4e:	5e                   	pop    %esi
  102a4f:	5f                   	pop    %edi
  102a50:	5d                   	pop    %ebp
  102a51:	c3                   	ret
  102a52:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    KERN_ASSERT(deliver_mode != LAPIC_ICRLO_INIT &&
  102a58:	8d 83 0c 6e ff ff    	lea    -0x91f4(%ebx),%eax
  102a5e:	50                   	push   %eax
  102a5f:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  102a65:	50                   	push   %eax
  102a66:	8d 83 55 62 ff ff    	lea    -0x9dab(%ebx),%eax
  102a6c:	68 e4 00 00 00       	push   $0xe4
  102a71:	50                   	push   %eax
  102a72:	e8 79 1d 00 00       	call   1047f0 <debug_panic>
    KERN_ASSERT(vector >= T_IPI0);
  102a77:	89 f0                	mov    %esi,%eax
    KERN_ASSERT(deliver_mode != LAPIC_ICRLO_INIT &&
  102a79:	83 c4 10             	add    $0x10,%esp
    KERN_ASSERT(vector >= T_IPI0);
  102a7c:	3c 3e                	cmp    $0x3e,%al
  102a7e:	77 95                	ja     102a15 <lapic_send_ipi+0x45>
  102a80:	8d 83 99 62 ff ff    	lea    -0x9d67(%ebx),%eax
  102a86:	50                   	push   %eax
  102a87:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  102a8d:	50                   	push   %eax
  102a8e:	8d 83 55 62 ff ff    	lea    -0x9dab(%ebx),%eax
  102a94:	68 e6 00 00 00       	push   $0xe6
  102a99:	50                   	push   %eax
  102a9a:	e8 51 1d 00 00       	call   1047f0 <debug_panic>
  102a9f:	83 c4 10             	add    $0x10,%esp
    return lapic[index];
  102aa2:	e9 6e ff ff ff       	jmp    102a15 <lapic_send_ipi+0x45>
  102aa7:	66 90                	xchg   %ax,%ax
  102aa9:	66 90                	xchg   %ax,%ax
  102aab:	66 90                	xchg   %ax,%ax
  102aad:	66 90                	xchg   %ax,%ax
  102aaf:	90                   	nop

00102ab0 <ioapic_register>:
    base->reg = reg;
    base->data = data;
}

void ioapic_register(uintptr_t addr, lapicid_t id, int g)
{
  102ab0:	53                   	push   %ebx
  102ab1:	e8 ec d8 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  102ab6:	81 c3 3e 45 01 00    	add    $0x1453e,%ebx
  102abc:	83 ec 08             	sub    $0x8,%esp
  102abf:	8b 54 24 14          	mov    0x14(%esp),%edx
    if (ioapic_num >= MAX_IOAPIC) {
  102ac3:	8b 83 ac a8 08 00    	mov    0x8a8ac(%ebx),%eax
  102ac9:	83 f8 0f             	cmp    $0xf,%eax
  102acc:	7f 4a                	jg     102b18 <ioapic_register+0x68>
        KERN_WARN("CertiKOS cannot manipulate more than %d IOAPICs.\n", MAX_IOAPIC);
        return;
    }

    ioapics[ioapic_num] = (ioapic_t *) addr;
  102ace:	8b 83 ac a8 08 00    	mov    0x8a8ac(%ebx),%eax
  102ad4:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  102ad8:	89 8c 83 2c a9 08 00 	mov    %ecx,0x8a92c(%ebx,%eax,4)
    ioapicid[ioapic_num] = id;
  102adf:	8b 83 ac a8 08 00    	mov    0x8a8ac(%ebx),%eax
    gsi[ioapic_num] = g;
  102ae5:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    ioapicid[ioapic_num] = id;
  102ae9:	88 94 03 0c a9 08 00 	mov    %dl,0x8a90c(%ebx,%eax,1)
    gsi[ioapic_num] = g;
  102af0:	8b 93 ac a8 08 00    	mov    0x8a8ac(%ebx),%edx
  102af6:	8d 83 cc a8 08 00    	lea    0x8a8cc(%ebx),%eax
  102afc:	89 0c 90             	mov    %ecx,(%eax,%edx,4)

    ioapic_num++;
  102aff:	8b 83 ac a8 08 00    	mov    0x8a8ac(%ebx),%eax
  102b05:	83 c0 01             	add    $0x1,%eax
  102b08:	89 83 ac a8 08 00    	mov    %eax,0x8a8ac(%ebx)
}
  102b0e:	83 c4 08             	add    $0x8,%esp
  102b11:	5b                   	pop    %ebx
  102b12:	c3                   	ret
  102b13:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        KERN_WARN("CertiKOS cannot manipulate more than %d IOAPICs.\n", MAX_IOAPIC);
  102b18:	8d 83 54 6e ff ff    	lea    -0x91ac(%ebx),%eax
  102b1e:	6a 10                	push   $0x10
  102b20:	50                   	push   %eax
  102b21:	8d 83 aa 62 ff ff    	lea    -0x9d56(%ebx),%eax
  102b27:	6a 1f                	push   $0x1f
  102b29:	50                   	push   %eax
  102b2a:	e8 d1 1d 00 00       	call   104900 <debug_warn>
        return;
  102b2f:	83 c4 10             	add    $0x10,%esp
}
  102b32:	83 c4 08             	add    $0x8,%esp
  102b35:	5b                   	pop    %ebx
  102b36:	c3                   	ret
  102b37:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  102b3e:	00 
  102b3f:	90                   	nop

00102b40 <ioapic_init>:

void ioapic_init(void)
{
    int i;
    for (i = 0; i < ioapic_num; i++) {
  102b40:	e8 ae 02 00 00       	call   102df3 <__x86.get_pc_thunk.cx>
  102b45:	81 c1 af 44 01 00    	add    $0x144af,%ecx
{
  102b4b:	55                   	push   %ebp
  102b4c:	57                   	push   %edi
  102b4d:	56                   	push   %esi
  102b4e:	53                   	push   %ebx
  102b4f:	83 ec 1c             	sub    $0x1c,%esp
    for (i = 0; i < ioapic_num; i++) {
  102b52:	8b 81 ac a8 08 00    	mov    0x8a8ac(%ecx),%eax
  102b58:	89 0c 24             	mov    %ecx,(%esp)
  102b5b:	85 c0                	test   %eax,%eax
  102b5d:	0f 8e ec 00 00 00    	jle    102c4f <ioapic_init+0x10f>
  102b63:	89 c8                	mov    %ecx,%eax
  102b65:	31 ff                	xor    %edi,%edi
  102b67:	8d 89 0c a9 08 00    	lea    0x8a90c(%ecx),%ecx
        volatile ioapic_t *ioapic = ioapics[i];
        KERN_ASSERT(ioapic != NULL);
  102b6d:	8d 98 bc 62 ff ff    	lea    -0x9d44(%eax),%ebx
  102b73:	8d 80 b8 60 ff ff    	lea    -0x9f48(%eax),%eax
  102b79:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  102b7d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  102b81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        volatile ioapic_t *ioapic = ioapics[i];
  102b88:	8b 04 24             	mov    (%esp),%eax
  102b8b:	8b b4 b8 2c a9 08 00 	mov    0x8a92c(%eax,%edi,4),%esi
        KERN_ASSERT(ioapic != NULL);
  102b92:	85 f6                	test   %esi,%esi
  102b94:	0f 84 c6 00 00 00    	je     102c60 <ioapic_init+0x120>
    base->reg = reg;
  102b9a:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    return base->data;
  102ba0:	8b 46 10             	mov    0x10(%esi),%eax

        lapicid_t id = ioapic_read(ioapic, IOAPIC_ID) >> 24;
        if (id == 0) {
  102ba3:	c1 e8 18             	shr    $0x18,%eax
  102ba6:	75 14                	jne    102bbc <ioapic_init+0x7c>
            // I/O APIC ID not initialized yet - have to do it ourselves.
            ioapic_write(ioapic, IOAPIC_ID, ioapicid[i] << 24);
  102ba8:	0f b6 04 39          	movzbl (%ecx,%edi,1),%eax
    base->reg = reg;
  102bac:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
            ioapic_write(ioapic, IOAPIC_ID, ioapicid[i] << 24);
  102bb2:	c1 e0 18             	shl    $0x18,%eax
    base->data = data;
  102bb5:	89 46 10             	mov    %eax,0x10(%esi)
            id = ioapicid[i];
  102bb8:	0f b6 04 39          	movzbl (%ecx,%edi,1),%eax
        }

        if (id != ioapicid[i])
  102bbc:	0f b6 14 39          	movzbl (%ecx,%edi,1),%edx
  102bc0:	38 c2                	cmp    %al,%dl
  102bc2:	74 30                	je     102bf4 <ioapic_init+0xb4>
            KERN_WARN("ioapic_init: id %d != ioapicid %d\n", id, ioapicid[i]);
  102bc4:	0f b6 14 39          	movzbl (%ecx,%edi,1),%edx
  102bc8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102bcc:	0f b6 c0             	movzbl %al,%eax
  102bcf:	83 ec 0c             	sub    $0xc,%esp
  102bd2:	52                   	push   %edx
  102bd3:	50                   	push   %eax
  102bd4:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  102bd8:	8d 83 88 6e ff ff    	lea    -0x9178(%ebx),%eax
  102bde:	50                   	push   %eax
  102bdf:	8d 83 aa 62 ff ff    	lea    -0x9d56(%ebx),%eax
  102be5:	6a 39                	push   $0x39
  102be7:	50                   	push   %eax
  102be8:	e8 13 1d 00 00       	call   104900 <debug_warn>
  102bed:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  102bf1:	83 c4 20             	add    $0x20,%esp
    base->reg = reg;
  102bf4:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
    return base->data;
  102bfa:	8b 6e 10             	mov    0x10(%esi),%ebp
        int maxintr = (ioapic_read(ioapic, IOAPIC_VER) >> 16) & 0xFF;

        // Mark all interrupts edge-triggered, active high, disabled,
        // and not routed to any CPUs.
        int j;
        for (j = 0; j <= maxintr; j++) {
  102bfd:	89 7c 24 04          	mov    %edi,0x4(%esp)
        int maxintr = (ioapic_read(ioapic, IOAPIC_VER) >> 16) & 0xFF;
  102c01:	c1 ed 10             	shr    $0x10,%ebp
  102c04:	89 e8                	mov    %ebp,%eax
  102c06:	0f b6 e8             	movzbl %al,%ebp
        for (j = 0; j <= maxintr; j++) {
  102c09:	31 c0                	xor    %eax,%eax
  102c0b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
            ioapic_write(ioapic, IOAPIC_TABLE + 2 * j,
  102c10:	8d 14 00             	lea    (%eax,%eax,1),%edx
  102c13:	8d 58 20             	lea    0x20(%eax),%ebx
        for (j = 0; j <= maxintr; j++) {
  102c16:	83 c0 01             	add    $0x1,%eax
  102c19:	8d 7a 10             	lea    0x10(%edx),%edi
  102c1c:	81 cb 00 00 01 00    	or     $0x10000,%ebx
    base->reg = reg;
  102c22:	83 c2 11             	add    $0x11,%edx
  102c25:	89 3e                	mov    %edi,(%esi)
    base->data = data;
  102c27:	89 5e 10             	mov    %ebx,0x10(%esi)
    base->reg = reg;
  102c2a:	89 16                	mov    %edx,(%esi)
    base->data = data;
  102c2c:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
        for (j = 0; j <= maxintr; j++) {
  102c33:	39 c5                	cmp    %eax,%ebp
  102c35:	7d d9                	jge    102c10 <ioapic_init+0xd0>
    for (i = 0; i < ioapic_num; i++) {
  102c37:	8b 04 24             	mov    (%esp),%eax
  102c3a:	8b 7c 24 04          	mov    0x4(%esp),%edi
  102c3e:	8b 80 ac a8 08 00    	mov    0x8a8ac(%eax),%eax
  102c44:	83 c7 01             	add    $0x1,%edi
  102c47:	39 f8                	cmp    %edi,%eax
  102c49:	0f 8f 39 ff ff ff    	jg     102b88 <ioapic_init+0x48>
                         IOAPIC_INT_DISABLED | (T_IRQ0 + j));
            ioapic_write(ioapic, IOAPIC_TABLE + 2 * j + 1, 0);
        }
    }
}
  102c4f:	83 c4 1c             	add    $0x1c,%esp
  102c52:	5b                   	pop    %ebx
  102c53:	5e                   	pop    %esi
  102c54:	5f                   	pop    %edi
  102c55:	5d                   	pop    %ebp
  102c56:	c3                   	ret
  102c57:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  102c5e:	00 
  102c5f:	90                   	nop
  102c60:	89 4c 24 04          	mov    %ecx,0x4(%esp)
        KERN_ASSERT(ioapic != NULL);
  102c64:	ff 74 24 08          	push   0x8(%esp)
  102c68:	ff 74 24 10          	push   0x10(%esp)
  102c6c:	6a 2f                	push   $0x2f
  102c6e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  102c72:	8d 83 aa 62 ff ff    	lea    -0x9d56(%ebx),%eax
  102c78:	50                   	push   %eax
  102c79:	e8 72 1b 00 00       	call   1047f0 <debug_panic>
  102c7e:	83 c4 10             	add    $0x10,%esp
  102c81:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  102c85:	e9 10 ff ff ff       	jmp    102b9a <ioapic_init+0x5a>
  102c8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00102c90 <ioapic_enable>:

void ioapic_enable(uint8_t irq, lapicid_t apicid, bool trigger_mode, bool polarity)
{
  102c90:	55                   	push   %ebp
  102c91:	57                   	push   %edi
  102c92:	56                   	push   %esi
  102c93:	53                   	push   %ebx
  102c94:	e8 09 d7 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  102c99:	81 c3 5b 43 01 00    	add    $0x1435b,%ebx
  102c9f:	83 ec 2c             	sub    $0x2c,%esp
  102ca2:	8b 44 24 44          	mov    0x44(%esp),%eax
  102ca6:	8b 4c 24 40          	mov    0x40(%esp),%ecx
  102caa:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
  102cae:	89 44 24 10          	mov    %eax,0x10(%esp)
  102cb2:	8b 44 24 48          	mov    0x48(%esp),%eax
  102cb6:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  102cba:	89 44 24 14          	mov    %eax,0x14(%esp)
    // Mark interrupt edge-triggered, active high,
    // enabled, and routed to the given APIC ID,
    int i;
    for (i = 0; i < ioapic_num; i++) {
  102cbe:	8b 83 ac a8 08 00    	mov    0x8a8ac(%ebx),%eax
  102cc4:	85 c0                	test   %eax,%eax
  102cc6:	0f 8e dc 00 00 00    	jle    102da8 <ioapic_enable+0x118>
            break;
        }
    }

    if (i == ioapic_num)
        KERN_PANIC("Cannot enable IRQ %d on IOAPIC.\n", irq);
  102ccc:	0f b6 c9             	movzbl %cl,%ecx
  102ccf:	89 7c 24 18          	mov    %edi,0x18(%esp)
    for (i = 0; i < ioapic_num; i++) {
  102cd3:	31 c0                	xor    %eax,%eax
  102cd5:	8d b3 cc a8 08 00    	lea    0x8a8cc(%ebx),%esi
  102cdb:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  102cdf:	90                   	nop
        ioapic_t *ioapic = ioapics[i];
  102ce0:	8b 94 83 2c a9 08 00 	mov    0x8a92c(%ebx,%eax,4),%edx
        if (irq >= gsi[i] && irq <= gsi[i] + maxintr) {
  102ce7:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    base->reg = reg;
  102ceb:	c7 02 01 00 00 00    	movl   $0x1,(%edx)
    return base->data;
  102cf1:	8b 7a 10             	mov    0x10(%edx),%edi
        if (irq >= gsi[i] && irq <= gsi[i] + maxintr) {
  102cf4:	8b 2c 86             	mov    (%esi,%eax,4),%ebp
  102cf7:	39 cd                	cmp    %ecx,%ebp
  102cf9:	7f 15                	jg     102d10 <ioapic_enable+0x80>
        int maxintr = (ioapic_read(ioapic, IOAPIC_VER) >> 16) & 0xFF;
  102cfb:	c1 ef 10             	shr    $0x10,%edi
        if (irq >= gsi[i] && irq <= gsi[i] + maxintr) {
  102cfe:	8b 2c 86             	mov    (%esi,%eax,4),%ebp
        int maxintr = (ioapic_read(ioapic, IOAPIC_VER) >> 16) & 0xFF;
  102d01:	89 f9                	mov    %edi,%ecx
  102d03:	0f b6 f9             	movzbl %cl,%edi
        if (irq >= gsi[i] && irq <= gsi[i] + maxintr) {
  102d06:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  102d0a:	01 ef                	add    %ebp,%edi
  102d0c:	39 cf                	cmp    %ecx,%edi
  102d0e:	7d 20                	jge    102d30 <ioapic_enable+0xa0>
    for (i = 0; i < ioapic_num; i++) {
  102d10:	8b 93 ac a8 08 00    	mov    0x8a8ac(%ebx),%edx
  102d16:	83 c0 01             	add    $0x1,%eax
  102d19:	39 c2                	cmp    %eax,%edx
  102d1b:	7f c3                	jg     102ce0 <ioapic_enable+0x50>
    if (i == ioapic_num)
  102d1d:	8b 93 ac a8 08 00    	mov    0x8a8ac(%ebx),%edx
  102d23:	39 c2                	cmp    %eax,%edx
  102d25:	74 5b                	je     102d82 <ioapic_enable+0xf2>
}
  102d27:	83 c4 2c             	add    $0x2c,%esp
  102d2a:	5b                   	pop    %ebx
  102d2b:	5e                   	pop    %esi
  102d2c:	5f                   	pop    %edi
  102d2d:	5d                   	pop    %ebp
  102d2e:	c3                   	ret
  102d2f:	90                   	nop
                         ((trigger_mode << 15) | (polarity << 13) | (T_IRQ0 + irq)));
  102d30:	8b 7c 24 18          	mov    0x18(%esp),%edi
  102d34:	0f b6 6c 24 14       	movzbl 0x14(%esp),%ebp
  102d39:	89 54 24 0c          	mov    %edx,0xc(%esp)
  102d3d:	89 fa                	mov    %edi,%edx
  102d3f:	c1 e5 0f             	shl    $0xf,%ebp
  102d42:	0f b6 fa             	movzbl %dl,%edi
                         IOAPIC_TABLE + 2 * (irq - gsi[i]),
  102d45:	89 ca                	mov    %ecx,%edx
                         ((trigger_mode << 15) | (polarity << 13) | (T_IRQ0 + irq)));
  102d47:	c1 e7 0d             	shl    $0xd,%edi
  102d4a:	09 ef                	or     %ebp,%edi
  102d4c:	8d 69 20             	lea    0x20(%ecx),%ebp
  102d4f:	09 fd                	or     %edi,%ebp
                         IOAPIC_TABLE + 2 * (irq - gsi[i]),
  102d51:	8b 3c 86             	mov    (%esi,%eax,4),%edi
  102d54:	29 fa                	sub    %edi,%edx
            ioapic_write(ioapic,
  102d56:	8d 7c 12 10          	lea    0x10(%edx,%edx,1),%edi
    base->reg = reg;
  102d5a:	8b 54 24 0c          	mov    0xc(%esp),%edx
  102d5e:	89 3a                	mov    %edi,(%edx)
            ioapic_write(ioapic,
  102d60:	8b 7c 24 10          	mov    0x10(%esp),%edi
    base->data = data;
  102d64:	89 6a 10             	mov    %ebp,0x10(%edx)
                         IOAPIC_TABLE + 2 * (irq - gsi[i]) + 1,
  102d67:	8b 34 86             	mov    (%esi,%eax,4),%esi
            ioapic_write(ioapic,
  102d6a:	c1 e7 18             	shl    $0x18,%edi
                         IOAPIC_TABLE + 2 * (irq - gsi[i]) + 1,
  102d6d:	29 f1                	sub    %esi,%ecx
            ioapic_write(ioapic,
  102d6f:	8d 4c 09 11          	lea    0x11(%ecx,%ecx,1),%ecx
    base->reg = reg;
  102d73:	89 0a                	mov    %ecx,(%edx)
    base->data = data;
  102d75:	89 7a 10             	mov    %edi,0x10(%edx)
    if (i == ioapic_num)
  102d78:	8b 93 ac a8 08 00    	mov    0x8a8ac(%ebx),%edx
  102d7e:	39 c2                	cmp    %eax,%edx
  102d80:	75 a5                	jne    102d27 <ioapic_enable+0x97>
        KERN_PANIC("Cannot enable IRQ %d on IOAPIC.\n", irq);
  102d82:	0f b6 44 24 1c       	movzbl 0x1c(%esp),%eax
  102d87:	50                   	push   %eax
  102d88:	8d 83 ac 6e ff ff    	lea    -0x9154(%ebx),%eax
  102d8e:	50                   	push   %eax
  102d8f:	8d 83 aa 62 ff ff    	lea    -0x9d56(%ebx),%eax
  102d95:	6a 5d                	push   $0x5d
  102d97:	50                   	push   %eax
  102d98:	e8 53 1a 00 00       	call   1047f0 <debug_panic>
  102d9d:	83 c4 10             	add    $0x10,%esp
}
  102da0:	83 c4 2c             	add    $0x2c,%esp
  102da3:	5b                   	pop    %ebx
  102da4:	5e                   	pop    %esi
  102da5:	5f                   	pop    %edi
  102da6:	5d                   	pop    %ebp
  102da7:	c3                   	ret
    for (i = 0; i < ioapic_num; i++) {
  102da8:	31 c0                	xor    %eax,%eax
  102daa:	e9 6e ff ff ff       	jmp    102d1d <ioapic_enable+0x8d>
  102daf:	90                   	nop

00102db0 <ioapic_number>:

int ioapic_number(void)
{
    return ioapic_num;
  102db0:	e8 e5 d5 ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  102db5:	05 3f 42 01 00       	add    $0x1423f,%eax
  102dba:	8b 80 ac a8 08 00    	mov    0x8a8ac(%eax),%eax
}
  102dc0:	c3                   	ret
  102dc1:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  102dc8:	00 
  102dc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00102dd0 <ioapic_get>:

ioapic_t *ioapic_get(uint32_t idx)
{
    if (idx >= ioapic_num)
  102dd0:	e8 c5 d5 ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  102dd5:	05 1f 42 01 00       	add    $0x1421f,%eax
{
  102dda:	8b 54 24 04          	mov    0x4(%esp),%edx
    if (idx >= ioapic_num)
  102dde:	8b 88 ac a8 08 00    	mov    0x8a8ac(%eax),%ecx
  102de4:	39 ca                	cmp    %ecx,%edx
  102de6:	73 08                	jae    102df0 <ioapic_get+0x20>
        return NULL;
    return ioapics[idx];
  102de8:	8b 84 90 2c a9 08 00 	mov    0x8a92c(%eax,%edx,4),%eax
  102def:	c3                   	ret
        return NULL;
  102df0:	31 c0                	xor    %eax,%eax
}
  102df2:	c3                   	ret

00102df3 <__x86.get_pc_thunk.cx>:
  102df3:	8b 0c 24             	mov    (%esp),%ecx
  102df6:	c3                   	ret
  102df7:	66 90                	xchg   %ax,%ax
  102df9:	66 90                	xchg   %ax,%ax
  102dfb:	66 90                	xchg   %ax,%ax
  102dfd:	66 90                	xchg   %ax,%ax
  102dff:	90                   	nop

00102e00 <mpsearch1>:
    return sum;
}

/* Look for an MP structure in the len bytes at addr. */
static struct mp *mpsearch1(uint8_t *addr, int len)
{
  102e00:	55                   	push   %ebp
    uint8_t *e, *p;

    e = addr + len;
  102e01:	8d 2c 10             	lea    (%eax,%edx,1),%ebp
{
  102e04:	57                   	push   %edi
  102e05:	56                   	push   %esi
  102e06:	e8 aa 0d 00 00       	call   103bb5 <__x86.get_pc_thunk.si>
  102e0b:	81 c6 e9 41 01 00    	add    $0x141e9,%esi
  102e11:	53                   	push   %ebx
  102e12:	83 ec 1c             	sub    $0x1c,%esp
  102e15:	89 74 24 0c          	mov    %esi,0xc(%esp)
    for (p = addr; p < e; p += sizeof(struct mp))
  102e19:	39 e8                	cmp    %ebp,%eax
  102e1b:	73 5b                	jae    102e78 <mpsearch1+0x78>
  102e1d:	89 c7                	mov    %eax,%edi
  102e1f:	8d b6 cb 62 ff ff    	lea    -0x9d35(%esi),%esi
  102e25:	eb 0f                	jmp    102e36 <mpsearch1+0x36>
  102e27:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  102e2e:	00 
  102e2f:	90                   	nop
  102e30:	89 df                	mov    %ebx,%edi
  102e32:	39 eb                	cmp    %ebp,%ebx
  102e34:	73 42                	jae    102e78 <mpsearch1+0x78>
        if (memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
  102e36:	83 ec 04             	sub    $0x4,%esp
  102e39:	6a 04                	push   $0x4
  102e3b:	56                   	push   %esi
  102e3c:	57                   	push   %edi
  102e3d:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  102e41:	e8 ea 17 00 00       	call   104630 <memcmp>
  102e46:	83 c4 10             	add    $0x10,%esp
  102e49:	8d 5f 10             	lea    0x10(%edi),%ebx
  102e4c:	85 c0                	test   %eax,%eax
  102e4e:	75 e0                	jne    102e30 <mpsearch1+0x30>
  102e50:	89 fa                	mov    %edi,%edx
  102e52:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        sum += addr[i];
  102e58:	0f b6 0a             	movzbl (%edx),%ecx
    for (i = 0; i < len; i++)
  102e5b:	83 c2 01             	add    $0x1,%edx
        sum += addr[i];
  102e5e:	01 c8                	add    %ecx,%eax
    for (i = 0; i < len; i++)
  102e60:	39 da                	cmp    %ebx,%edx
  102e62:	75 f4                	jne    102e58 <mpsearch1+0x58>
        if (memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
  102e64:	84 c0                	test   %al,%al
  102e66:	75 c8                	jne    102e30 <mpsearch1+0x30>
            return (struct mp *) p;
    return 0;
}
  102e68:	83 c4 1c             	add    $0x1c,%esp
            return (struct mp *) p;
  102e6b:	89 f8                	mov    %edi,%eax
}
  102e6d:	5b                   	pop    %ebx
  102e6e:	5e                   	pop    %esi
  102e6f:	5f                   	pop    %edi
  102e70:	5d                   	pop    %ebp
  102e71:	c3                   	ret
  102e72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  102e78:	83 c4 1c             	add    $0x1c,%esp
    return 0;
  102e7b:	31 c0                	xor    %eax,%eax
}
  102e7d:	5b                   	pop    %ebx
  102e7e:	5e                   	pop    %esi
  102e7f:	5f                   	pop    %edi
  102e80:	5d                   	pop    %ebp
  102e81:	c3                   	ret
  102e82:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  102e89:	00 
  102e8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00102e90 <pcpu_mp_init>:

/*
 * Multiple processors initialization method using ACPI
 */
bool pcpu_mp_init(void)
{
  102e90:	55                   	push   %ebp
  102e91:	57                   	push   %edi
  102e92:	56                   	push   %esi
  102e93:	53                   	push   %ebx
  102e94:	e8 09 d5 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  102e99:	81 c3 5b 41 01 00    	add    $0x1415b,%ebx
  102e9f:	83 ec 2c             	sub    $0x2c,%esp
    acpi_xsdt_t *xsdt;
    acpi_madt_t *madt;
    uint32_t ap_idx = 1;
    bool found_bsp = FALSE;

    if (mp_inited == TRUE)
  102ea2:	80 bb 6d a9 08 00 01 	cmpb   $0x1,0x8a96d(%ebx)
  102ea9:	0f 84 92 01 00 00    	je     103041 <pcpu_mp_init+0x1b1>
        return TRUE;

    KERN_INFO("\n");
  102eaf:	83 ec 0c             	sub    $0xc,%esp
  102eb2:	8d 83 90 65 ff ff    	lea    -0x9a70(%ebx),%eax
  102eb8:	50                   	push   %eax
  102eb9:	e8 92 18 00 00       	call   104750 <debug_info>

    if ((rsdp = acpi_probe_rsdp()) == NULL) {
  102ebe:	e8 dd f3 ff ff       	call   1022a0 <acpi_probe_rsdp>
  102ec3:	83 c4 10             	add    $0x10,%esp
  102ec6:	89 c6                	mov    %eax,%esi
  102ec8:	85 c0                	test   %eax,%eax
  102eca:	0f 84 50 02 00 00    	je     103120 <pcpu_mp_init+0x290>
        KERN_DEBUG("Not found RSDP.\n");
        goto fallback;
    }

    xsdt = NULL;
    if ((xsdt = acpi_probe_xsdt(rsdp)) == NULL &&
  102ed0:	83 ec 0c             	sub    $0xc,%esp
  102ed3:	50                   	push   %eax
  102ed4:	e8 b7 f5 ff ff       	call   102490 <acpi_probe_xsdt>
  102ed9:	83 c4 10             	add    $0x10,%esp
  102edc:	85 c0                	test   %eax,%eax
  102ede:	0f 84 dc 01 00 00    	je     1030c0 <pcpu_mp_init+0x230>
        goto fallback;
    }

    if ((madt =
         (xsdt != NULL) ?
         (acpi_madt_t *) acpi_probe_xsdt_ent(xsdt, ACPI_MADT_SIG) :
  102ee4:	83 ec 08             	sub    $0x8,%esp
  102ee7:	68 41 50 49 43       	push   $0x43495041
  102eec:	50                   	push   %eax
  102eed:	e8 2e f6 ff ff       	call   102520 <acpi_probe_xsdt_ent>
  102ef2:	83 c4 10             	add    $0x10,%esp
  102ef5:	89 c7                	mov    %eax,%edi
    if ((madt =
  102ef7:	85 ff                	test   %edi,%edi
  102ef9:	0f 84 61 04 00 00    	je     103360 <pcpu_mp_init+0x4d0>
        KERN_DEBUG("Not found MADT.\n");
        goto fallback;
    }

    ismp = TRUE;
    lapic_register(madt->lapic_addr);
  102eff:	83 ec 0c             	sub    $0xc,%esp
  102f02:	ff 77 24             	push   0x24(%edi)
    ncpu = 0;

    p = (uint8_t *) madt->ent;
  102f05:	8d 6f 2c             	lea    0x2c(%edi),%ebp
    ismp = TRUE;
  102f08:	c6 83 6c a9 08 00 01 	movb   $0x1,0x8a96c(%ebx)
    lapic_register(madt->lapic_addr);
  102f0f:	e8 ac f6 ff ff       	call   1025c0 <lapic_register>
    e = (uint8_t *) madt + madt->length;
  102f14:	8b 77 04             	mov    0x4(%edi),%esi

    while (p < e) {
  102f17:	83 c4 10             	add    $0x10,%esp
    ncpu = 0;
  102f1a:	c7 83 70 a9 08 00 00 	movl   $0x0,0x8a970(%ebx)
  102f21:	00 00 00 
    e = (uint8_t *) madt + madt->length;
  102f24:	01 fe                	add    %edi,%esi
    while (p < e) {
  102f26:	39 f5                	cmp    %esi,%ebp
  102f28:	0f 83 e6 00 00 00    	jae    103014 <pcpu_mp_init+0x184>

            if (!(lapic_ent->flags & ACPI_APIC_ENABLED)) {
                break;
            }

            KERN_INFO("\tCPU%d: APIC id = %x, ", ncpu, lapic_ent->lapic_id);
  102f2e:	8d 83 05 63 ff ff    	lea    -0x9cfb(%ebx),%eax
    bool found_bsp = FALSE;
  102f34:	31 c9                	xor    %ecx,%ecx

            ioapic_register(ioapic_ent->ioapic_addr, ioapic_ent->ioapic_id,
                            ioapic_ent->gsi);
            break;
        default:
            KERN_INFO("\tUnhandled ACPI entry (type=%x)\n", hdr->type);
  102f36:	89 7c 24 18          	mov    %edi,0x18(%esp)
  102f3a:	89 ef                	mov    %ebp,%edi
            KERN_INFO("\tCPU%d: APIC id = %x, ", ncpu, lapic_ent->lapic_id);
  102f3c:	89 44 24 14          	mov    %eax,0x14(%esp)
            KERN_INFO("\tUnhandled ACPI entry (type=%x)\n", hdr->type);
  102f40:	8d 83 14 6f ff ff    	lea    -0x90ec(%ebx),%eax
  102f46:	89 cd                	mov    %ecx,%ebp
    uint32_t ap_idx = 1;
  102f48:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  102f4f:	00 
            KERN_INFO("\tUnhandled ACPI entry (type=%x)\n", hdr->type);
  102f50:	89 44 24 0c          	mov    %eax,0xc(%esp)
  102f54:	eb 30                	jmp    102f86 <pcpu_mp_init+0xf6>
  102f56:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  102f5d:	00 
  102f5e:	66 90                	xchg   %ax,%ax
        switch (hdr->type) {
  102f60:	3c 01                	cmp    $0x1,%al
  102f62:	0f 84 e8 00 00 00    	je     103050 <pcpu_mp_init+0x1c0>
            KERN_INFO("\tUnhandled ACPI entry (type=%x)\n", hdr->type);
  102f68:	83 ec 08             	sub    $0x8,%esp
  102f6b:	50                   	push   %eax
  102f6c:	ff 74 24 18          	push   0x18(%esp)
  102f70:	e8 db 17 00 00       	call   104750 <debug_info>
            break;
  102f75:	83 c4 10             	add    $0x10,%esp
        }

        p += hdr->length;
  102f78:	0f b6 47 01          	movzbl 0x1(%edi),%eax
  102f7c:	01 c7                	add    %eax,%edi
    while (p < e) {
  102f7e:	39 f7                	cmp    %esi,%edi
  102f80:	0f 83 8a 00 00 00    	jae    103010 <pcpu_mp_init+0x180>
        switch (hdr->type) {
  102f86:	0f b6 07             	movzbl (%edi),%eax
  102f89:	84 c0                	test   %al,%al
  102f8b:	75 d3                	jne    102f60 <pcpu_mp_init+0xd0>
            if (!(lapic_ent->flags & ACPI_APIC_ENABLED)) {
  102f8d:	f6 47 04 01          	testb  $0x1,0x4(%edi)
  102f91:	74 e5                	je     102f78 <pcpu_mp_init+0xe8>
            KERN_INFO("\tCPU%d: APIC id = %x, ", ncpu, lapic_ent->lapic_id);
  102f93:	0f b6 47 03          	movzbl 0x3(%edi),%eax
  102f97:	83 ec 04             	sub    $0x4,%esp
  102f9a:	50                   	push   %eax
  102f9b:	ff b3 70 a9 08 00    	push   0x8a970(%ebx)
  102fa1:	ff 74 24 20          	push   0x20(%esp)
  102fa5:	e8 a6 17 00 00       	call   104750 <debug_info>
            if (!found_bsp) {
  102faa:	89 e8                	mov    %ebp,%eax
  102fac:	83 c4 10             	add    $0x10,%esp
  102faf:	84 c0                	test   %al,%al
  102fb1:	0f 84 d1 00 00 00    	je     103088 <pcpu_mp_init+0x1f8>
                KERN_INFO("AP\n");
  102fb7:	83 ec 0c             	sub    $0xc,%esp
  102fba:	8d 83 21 63 ff ff    	lea    -0x9cdf(%ebx),%eax
  102fc0:	50                   	push   %eax
  102fc1:	e8 8a 17 00 00       	call   104750 <debug_info>
    if (idx >= NUM_CPUS)
  102fc6:	8b 44 24 20          	mov    0x20(%esp),%eax
  102fca:	83 c4 10             	add    $0x10,%esp
  102fcd:	83 f8 07             	cmp    $0x7,%eax
  102fd0:	77 1b                	ja     102fed <pcpu_mp_init+0x15d>
    struct pcpuinfo *info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(idx);
  102fd2:	83 ec 0c             	sub    $0xc,%esp
                pcpu_mp_init_cpu(ap_idx, lapic_ent->lapic_id, FALSE);
  102fd5:	0f b6 6f 03          	movzbl 0x3(%edi),%ebp
    struct pcpuinfo *info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(idx);
  102fd9:	50                   	push   %eax
  102fda:	e8 c1 33 00 00       	call   1063a0 <get_pcpu_arch_info_pointer>
    info->lapicid = lapic_id;
  102fdf:	89 e9                	mov    %ebp,%ecx
    info->bsp = is_bsp;
  102fe1:	83 c4 10             	add    $0x10,%esp
    info->lapicid = lapic_id;
  102fe4:	0f b6 e9             	movzbl %cl,%ebp
    info->bsp = is_bsp;
  102fe7:	c6 40 04 00          	movb   $0x0,0x4(%eax)
    info->lapicid = lapic_id;
  102feb:	89 28                	mov    %ebp,(%eax)
                ap_idx++;
  102fed:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
        p += hdr->length;
  102ff2:	0f b6 47 01          	movzbl 0x1(%edi),%eax
            ncpu++;
  102ff6:	83 83 70 a9 08 00 01 	addl   $0x1,0x8a970(%ebx)
            break;
  102ffd:	bd 01 00 00 00       	mov    $0x1,%ebp
        p += hdr->length;
  103002:	01 c7                	add    %eax,%edi
    while (p < e) {
  103004:	39 f7                	cmp    %esi,%edi
  103006:	0f 82 7a ff ff ff    	jb     102f86 <pcpu_mp_init+0xf6>
  10300c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  103010:	8b 7c 24 18          	mov    0x18(%esp),%edi
    /*
     * Force NMI and 8259 signals to APIC when PIC mode
     * is not implemented.
     *
     */
    if ((madt->flags & APIC_MADT_PCAT_COMPAT) == 0) {
  103014:	f6 47 28 01          	testb  $0x1,0x28(%edi)
  103018:	0f 84 d2 00 00 00    	je     1030f0 <pcpu_mp_init+0x260>
    }

    /*
     * Copy AP boot code to 0x8000.
     */
    memmove((uint8_t *) 0x8000,
  10301e:	83 ec 04             	sub    $0x4,%esp
  103021:	ff b3 e8 ff ff ff    	push   -0x18(%ebx)
  103027:	ff b3 fc ff ff ff    	push   -0x4(%ebx)
  10302d:	68 00 80 00 00       	push   $0x8000
  103032:	e8 39 14 00 00       	call   104470 <memmove>
            _binary___obj_kern_init_boot_ap_start,
            (size_t) _binary___obj_kern_init_boot_ap_size);

    mp_inited = TRUE;
  103037:	c6 83 6d a9 08 00 01 	movb   $0x1,0x8a96d(%ebx)
    return TRUE;
  10303e:	83 c4 10             	add    $0x10,%esp
        ismp = 0;
        ncpu = 1;
        return FALSE;
    } else
        return TRUE;
}
  103041:	83 c4 2c             	add    $0x2c,%esp
        return TRUE;
  103044:	b8 01 00 00 00       	mov    $0x1,%eax
}
  103049:	5b                   	pop    %ebx
  10304a:	5e                   	pop    %esi
  10304b:	5f                   	pop    %edi
  10304c:	5d                   	pop    %ebp
  10304d:	c3                   	ret
  10304e:	66 90                	xchg   %ax,%ax
            KERN_INFO("\tIOAPIC: APIC id = %x, base = %x\n",
  103050:	83 ec 04             	sub    $0x4,%esp
  103053:	ff 77 04             	push   0x4(%edi)
  103056:	0f b6 47 02          	movzbl 0x2(%edi),%eax
  10305a:	50                   	push   %eax
  10305b:	8d 83 f0 6e ff ff    	lea    -0x9110(%ebx),%eax
  103061:	50                   	push   %eax
  103062:	e8 e9 16 00 00       	call   104750 <debug_info>
            ioapic_register(ioapic_ent->ioapic_addr, ioapic_ent->ioapic_id,
  103067:	83 c4 0c             	add    $0xc,%esp
  10306a:	ff 77 08             	push   0x8(%edi)
  10306d:	0f b6 47 02          	movzbl 0x2(%edi),%eax
  103071:	50                   	push   %eax
  103072:	ff 77 04             	push   0x4(%edi)
  103075:	e8 36 fa ff ff       	call   102ab0 <ioapic_register>
            break;
  10307a:	83 c4 10             	add    $0x10,%esp
  10307d:	e9 f6 fe ff ff       	jmp    102f78 <pcpu_mp_init+0xe8>
  103082:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                KERN_INFO("BSP\n");
  103088:	83 ec 0c             	sub    $0xc,%esp
  10308b:	8d 83 1c 63 ff ff    	lea    -0x9ce4(%ebx),%eax
  103091:	50                   	push   %eax
  103092:	e8 b9 16 00 00       	call   104750 <debug_info>
                pcpu_mp_init_cpu(0, lapic_ent->lapic_id, TRUE);
  103097:	0f b6 6f 03          	movzbl 0x3(%edi),%ebp
    struct pcpuinfo *info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(idx);
  10309b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1030a2:	e8 f9 32 00 00       	call   1063a0 <get_pcpu_arch_info_pointer>
    info->bsp = is_bsp;
  1030a7:	83 c4 10             	add    $0x10,%esp
    info->lapicid = lapic_id;
  1030aa:	89 e9                	mov    %ebp,%ecx
    info->bsp = is_bsp;
  1030ac:	c6 40 04 01          	movb   $0x1,0x4(%eax)
    info->lapicid = lapic_id;
  1030b0:	0f b6 e9             	movzbl %cl,%ebp
  1030b3:	89 28                	mov    %ebp,(%eax)
    info->bsp = is_bsp;
  1030b5:	e9 38 ff ff ff       	jmp    102ff2 <pcpu_mp_init+0x162>
  1030ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        (rsdt = acpi_probe_rsdt(rsdp)) == NULL) {
  1030c0:	83 ec 0c             	sub    $0xc,%esp
  1030c3:	56                   	push   %esi
  1030c4:	e8 97 f2 ff ff       	call   102360 <acpi_probe_rsdt>
    if ((xsdt = acpi_probe_xsdt(rsdp)) == NULL &&
  1030c9:	83 c4 10             	add    $0x10,%esp
  1030cc:	85 c0                	test   %eax,%eax
  1030ce:	0f 84 d3 03 00 00    	je     1034a7 <pcpu_mp_init+0x617>
         (acpi_madt_t *) acpi_probe_rsdt_ent(rsdt, ACPI_MADT_SIG)) == NULL) {
  1030d4:	83 ec 08             	sub    $0x8,%esp
  1030d7:	68 41 50 49 43       	push   $0x43495041
  1030dc:	50                   	push   %eax
  1030dd:	e8 0e f3 ff ff       	call   1023f0 <acpi_probe_rsdt_ent>
  1030e2:	83 c4 10             	add    $0x10,%esp
  1030e5:	89 c7                	mov    %eax,%edi
  1030e7:	e9 0b fe ff ff       	jmp    102ef7 <pcpu_mp_init+0x67>
  1030ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        outb(0x22, 0x70);
  1030f0:	83 ec 08             	sub    $0x8,%esp
  1030f3:	6a 70                	push   $0x70
  1030f5:	6a 22                	push   $0x22
  1030f7:	e8 24 25 00 00       	call   105620 <outb>
        outb(0x23, inb(0x23) | 1);
  1030fc:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  103103:	e8 e8 24 00 00       	call   1055f0 <inb>
  103108:	5e                   	pop    %esi
  103109:	5f                   	pop    %edi
  10310a:	83 c8 01             	or     $0x1,%eax
  10310d:	0f b6 c0             	movzbl %al,%eax
  103110:	50                   	push   %eax
  103111:	6a 23                	push   $0x23
  103113:	e8 08 25 00 00       	call   105620 <outb>
  103118:	83 c4 10             	add    $0x10,%esp
  10311b:	e9 fe fe ff ff       	jmp    10301e <pcpu_mp_init+0x18e>
        KERN_DEBUG("Not found RSDP.\n");
  103120:	83 ec 04             	sub    $0x4,%esp
  103123:	8d 83 d0 62 ff ff    	lea    -0x9d30(%ebx),%eax
  103129:	50                   	push   %eax
  10312a:	68 4f 01 00 00       	push   $0x14f
        KERN_DEBUG("Not found MADT.\n");
  10312f:	8d 83 e1 62 ff ff    	lea    -0x9d1f(%ebx),%eax
  103135:	89 44 24 18          	mov    %eax,0x18(%esp)
  103139:	50                   	push   %eax
  10313a:	e8 51 16 00 00       	call   104790 <debug_normal>
        goto fallback;
  10313f:	83 c4 10             	add    $0x10,%esp
    KERN_DEBUG("Use the fallback multiprocessor initialization.\n");
  103142:	8d 83 38 6f ff ff    	lea    -0x90c8(%ebx),%eax
  103148:	83 ec 04             	sub    $0x4,%esp
  10314b:	50                   	push   %eax
  10314c:	68 ac 01 00 00       	push   $0x1ac
  103151:	ff 74 24 18          	push   0x18(%esp)
  103155:	e8 36 16 00 00       	call   104790 <debug_normal>
    if (mp_inited == TRUE)
  10315a:	83 c4 10             	add    $0x10,%esp
  10315d:	80 bb 6d a9 08 00 01 	cmpb   $0x1,0x8a96d(%ebx)
  103164:	0f 84 d7 fe ff ff    	je     103041 <pcpu_mp_init+0x1b1>
    if ((p = ((bda[0x0F] << 8) | bda[0x0E]) << 4)) {
  10316a:	0f b6 05 0f 04 00 00 	movzbl 0x40f,%eax
  103171:	0f b6 15 0e 04 00 00 	movzbl 0x40e,%edx
  103178:	c1 e0 08             	shl    $0x8,%eax
  10317b:	09 d0                	or     %edx,%eax
  10317d:	c1 e0 04             	shl    $0x4,%eax
  103180:	75 1b                	jne    10319d <pcpu_mp_init+0x30d>
        p = ((bda[0x14] << 8) | bda[0x13]) * 1024;
  103182:	0f b6 05 14 04 00 00 	movzbl 0x414,%eax
  103189:	0f b6 15 13 04 00 00 	movzbl 0x413,%edx
  103190:	c1 e0 08             	shl    $0x8,%eax
  103193:	09 d0                	or     %edx,%eax
  103195:	c1 e0 0a             	shl    $0xa,%eax
        if ((mp = mpsearch1((uint8_t *) p - 1024, 1024)))
  103198:	2d 00 04 00 00       	sub    $0x400,%eax
        if ((mp = mpsearch1((uint8_t *) p, 1024)))
  10319d:	ba 00 04 00 00       	mov    $0x400,%edx
  1031a2:	e8 59 fc ff ff       	call   102e00 <mpsearch1>
  1031a7:	89 c7                	mov    %eax,%edi
  1031a9:	85 c0                	test   %eax,%eax
  1031ab:	0f 84 3f 02 00 00    	je     1033f0 <pcpu_mp_init+0x560>
    if ((mp = mpsearch()) == 0 || mp->physaddr == 0)
  1031b1:	8b 77 04             	mov    0x4(%edi),%esi
  1031b4:	85 f6                	test   %esi,%esi
  1031b6:	0f 84 f4 00 00 00    	je     1032b0 <pcpu_mp_init+0x420>
    if (memcmp(conf, "PCMP", 4) != 0)
  1031bc:	83 ec 04             	sub    $0x4,%esp
  1031bf:	8d 83 25 63 ff ff    	lea    -0x9cdb(%ebx),%eax
  1031c5:	6a 04                	push   $0x4
  1031c7:	50                   	push   %eax
  1031c8:	56                   	push   %esi
  1031c9:	e8 62 14 00 00       	call   104630 <memcmp>
  1031ce:	83 c4 10             	add    $0x10,%esp
  1031d1:	89 c2                	mov    %eax,%edx
  1031d3:	85 c0                	test   %eax,%eax
  1031d5:	0f 85 d5 00 00 00    	jne    1032b0 <pcpu_mp_init+0x420>
    if (conf->version != 1 && conf->version != 4)
  1031db:	0f b6 46 06          	movzbl 0x6(%esi),%eax
  1031df:	3c 01                	cmp    $0x1,%al
  1031e1:	74 08                	je     1031eb <pcpu_mp_init+0x35b>
  1031e3:	3c 04                	cmp    $0x4,%al
  1031e5:	0f 85 c5 00 00 00    	jne    1032b0 <pcpu_mp_init+0x420>
    if (sum((uint8_t *) conf, conf->length) != 0)
  1031eb:	0f b7 6e 04          	movzwl 0x4(%esi),%ebp
    for (i = 0; i < len; i++)
  1031ef:	66 85 ed             	test   %bp,%bp
  1031f2:	74 20                	je     103214 <pcpu_mp_init+0x384>
  1031f4:	89 f0                	mov    %esi,%eax
  1031f6:	01 f5                	add    %esi,%ebp
  1031f8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1031ff:	00 
        sum += addr[i];
  103200:	0f b6 08             	movzbl (%eax),%ecx
    for (i = 0; i < len; i++)
  103203:	83 c0 01             	add    $0x1,%eax
        sum += addr[i];
  103206:	01 ca                	add    %ecx,%edx
    for (i = 0; i < len; i++)
  103208:	39 e8                	cmp    %ebp,%eax
  10320a:	75 f4                	jne    103200 <pcpu_mp_init+0x370>
    if (sum((uint8_t *) conf, conf->length) != 0)
  10320c:	84 d2                	test   %dl,%dl
  10320e:	0f 85 9c 00 00 00    	jne    1032b0 <pcpu_mp_init+0x420>
    lapic_register((uintptr_t) conf->lapicaddr);
  103214:	83 ec 0c             	sub    $0xc,%esp
  103217:	ff 76 24             	push   0x24(%esi)
    for (p = (uint8_t *) (conf + 1), e = (uint8_t *) conf + conf->length; p < e;) {
  10321a:	8d 6e 2c             	lea    0x2c(%esi),%ebp
    ismp = 1;
  10321d:	c6 83 6c a9 08 00 01 	movb   $0x1,0x8a96c(%ebx)
    ncpu = 0;
  103224:	c7 83 70 a9 08 00 00 	movl   $0x0,0x8a970(%ebx)
  10322b:	00 00 00 
    lapic_register((uintptr_t) conf->lapicaddr);
  10322e:	e8 8d f3 ff ff       	call   1025c0 <lapic_register>
    for (p = (uint8_t *) (conf + 1), e = (uint8_t *) conf + conf->length; p < e;) {
  103233:	0f b7 46 04          	movzwl 0x4(%esi),%eax
  103237:	83 c4 10             	add    $0x10,%esp
    uint32_t ap_idx = 1;
  10323a:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
  103241:	00 
    for (p = (uint8_t *) (conf + 1), e = (uint8_t *) conf + conf->length; p < e;) {
  103242:	8d 0c 06             	lea    (%esi,%eax,1),%ecx
            KERN_INFO("\tIOAPIC: APIC id = %x, base = %x\n",
  103245:	8d 83 f0 6e ff ff    	lea    -0x9110(%ebx),%eax
  10324b:	89 44 24 10          	mov    %eax,0x10(%esp)
            KERN_WARN("mpinit: unknown config type %x\n", *p);
  10324f:	8d 83 6c 6f ff ff    	lea    -0x9094(%ebx),%eax
    for (p = (uint8_t *) (conf + 1), e = (uint8_t *) conf + conf->length; p < e;) {
  103255:	39 cd                	cmp    %ecx,%ebp
  103257:	0f 83 c7 00 00 00    	jae    103324 <pcpu_mp_init+0x494>
  10325d:	89 7c 24 18          	mov    %edi,0x18(%esp)
  103261:	89 ce                	mov    %ecx,%esi
  103263:	89 44 24 14          	mov    %eax,0x14(%esp)
  103267:	eb 1a                	jmp    103283 <pcpu_mp_init+0x3f3>
  103269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        switch (*p) {
  103270:	84 d2                	test   %dl,%dl
  103272:	0f 84 90 00 00 00    	je     103308 <pcpu_mp_init+0x478>
            p += 8;
  103278:	83 c5 08             	add    $0x8,%ebp
    for (p = (uint8_t *) (conf + 1), e = (uint8_t *) conf + conf->length; p < e;) {
  10327b:	39 f5                	cmp    %esi,%ebp
  10327d:	0f 83 9d 00 00 00    	jae    103320 <pcpu_mp_init+0x490>
        switch (*p) {
  103283:	0f b6 55 00          	movzbl 0x0(%ebp),%edx
  103287:	80 fa 02             	cmp    $0x2,%dl
  10328a:	74 44                	je     1032d0 <pcpu_mp_init+0x440>
  10328c:	76 e2                	jbe    103270 <pcpu_mp_init+0x3e0>
  10328e:	8d 4a fd             	lea    -0x3(%edx),%ecx
  103291:	80 f9 01             	cmp    $0x1,%cl
  103294:	76 e2                	jbe    103278 <pcpu_mp_init+0x3e8>
            KERN_WARN("mpinit: unknown config type %x\n", *p);
  103296:	52                   	push   %edx
  103297:	ff 74 24 18          	push   0x18(%esp)
  10329b:	68 28 01 00 00       	push   $0x128
  1032a0:	ff 74 24 18          	push   0x18(%esp)
  1032a4:	e8 57 16 00 00       	call   104900 <debug_warn>
  1032a9:	83 c4 10             	add    $0x10,%esp
  1032ac:	eb cd                	jmp    10327b <pcpu_mp_init+0x3eb>
  1032ae:	66 90                	xchg   %ax,%ax
        ismp = 0;
  1032b0:	c6 83 6c a9 08 00 00 	movb   $0x0,0x8a96c(%ebx)
        return FALSE;
  1032b7:	31 c0                	xor    %eax,%eax
        ncpu = 1;
  1032b9:	c7 83 70 a9 08 00 01 	movl   $0x1,0x8a970(%ebx)
  1032c0:	00 00 00 
}
  1032c3:	83 c4 2c             	add    $0x2c,%esp
  1032c6:	5b                   	pop    %ebx
  1032c7:	5e                   	pop    %esi
  1032c8:	5f                   	pop    %edi
  1032c9:	5d                   	pop    %ebp
  1032ca:	c3                   	ret
  1032cb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
            KERN_INFO("\tIOAPIC: APIC id = %x, base = %x\n",
  1032d0:	83 ec 04             	sub    $0x4,%esp
  1032d3:	ff 75 04             	push   0x4(%ebp)
  1032d6:	0f b6 55 01          	movzbl 0x1(%ebp),%edx
            p += sizeof(struct mpioapic);
  1032da:	8d 7d 08             	lea    0x8(%ebp),%edi
            KERN_INFO("\tIOAPIC: APIC id = %x, base = %x\n",
  1032dd:	52                   	push   %edx
  1032de:	ff 74 24 1c          	push   0x1c(%esp)
  1032e2:	e8 69 14 00 00       	call   104750 <debug_info>
            ioapic_register((uintptr_t) mpio->addr, mpio->apicno, 0);
  1032e7:	83 c4 0c             	add    $0xc,%esp
  1032ea:	6a 00                	push   $0x0
  1032ec:	0f b6 55 01          	movzbl 0x1(%ebp),%edx
  1032f0:	52                   	push   %edx
  1032f1:	ff 75 04             	push   0x4(%ebp)
            p += sizeof(struct mpioapic);
  1032f4:	89 fd                	mov    %edi,%ebp
            ioapic_register((uintptr_t) mpio->addr, mpio->apicno, 0);
  1032f6:	e8 b5 f7 ff ff       	call   102ab0 <ioapic_register>
            continue;
  1032fb:	83 c4 10             	add    $0x10,%esp
  1032fe:	e9 78 ff ff ff       	jmp    10327b <pcpu_mp_init+0x3eb>
  103303:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
            p += sizeof(struct mpproc);
  103308:	8d 7d 14             	lea    0x14(%ebp),%edi
            if (!(proc->flags & MPENAB))
  10330b:	f6 45 03 01          	testb  $0x1,0x3(%ebp)
  10330f:	75 67                	jne    103378 <pcpu_mp_init+0x4e8>
            p += sizeof(struct mpproc);
  103311:	89 fd                	mov    %edi,%ebp
  103313:	e9 63 ff ff ff       	jmp    10327b <pcpu_mp_init+0x3eb>
  103318:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10331f:	00 
  103320:	8b 7c 24 18          	mov    0x18(%esp),%edi
    if (mp->imcrp) {
  103324:	80 7f 0c 00          	cmpb   $0x0,0xc(%edi)
  103328:	0f 85 49 01 00 00    	jne    103477 <pcpu_mp_init+0x5e7>
    memcpy((uint8_t *) 0x8000,
  10332e:	83 ec 04             	sub    $0x4,%esp
  103331:	ff b3 e8 ff ff ff    	push   -0x18(%ebx)
  103337:	ff b3 fc ff ff ff    	push   -0x4(%ebx)
  10333d:	68 00 80 00 00       	push   $0x8000
  103342:	e8 99 11 00 00       	call   1044e0 <memcpy>
    mp_inited = TRUE;
  103347:	c6 83 6d a9 08 00 01 	movb   $0x1,0x8a96d(%ebx)
  10334e:	83 c4 10             	add    $0x10,%esp
  103351:	e9 eb fc ff ff       	jmp    103041 <pcpu_mp_init+0x1b1>
  103356:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10335d:	00 
  10335e:	66 90                	xchg   %ax,%ax
        KERN_DEBUG("Not found MADT.\n");
  103360:	83 ec 04             	sub    $0x4,%esp
  103363:	8d 83 f4 62 ff ff    	lea    -0x9d0c(%ebx),%eax
  103369:	50                   	push   %eax
  10336a:	68 5e 01 00 00       	push   $0x15e
  10336f:	e9 bb fd ff ff       	jmp    10312f <pcpu_mp_init+0x29f>
  103374:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            KERN_INFO("\tCPU%d: APIC id = %x, ", ncpu, proc->apicid);
  103378:	0f b6 4d 01          	movzbl 0x1(%ebp),%ecx
  10337c:	83 ec 04             	sub    $0x4,%esp
  10337f:	51                   	push   %ecx
  103380:	8d 8b 05 63 ff ff    	lea    -0x9cfb(%ebx),%ecx
  103386:	ff b3 70 a9 08 00    	push   0x8a970(%ebx)
  10338c:	51                   	push   %ecx
  10338d:	e8 be 13 00 00       	call   104750 <debug_info>
            if (proc->flags & MPBOOT) {
  103392:	83 c4 10             	add    $0x10,%esp
  103395:	f6 45 03 02          	testb  $0x2,0x3(%ebp)
  103399:	0f 85 a6 00 00 00    	jne    103445 <pcpu_mp_init+0x5b5>
                KERN_INFO("AP.\n");
  10339f:	83 ec 0c             	sub    $0xc,%esp
  1033a2:	8d 8b 30 63 ff ff    	lea    -0x9cd0(%ebx),%ecx
  1033a8:	51                   	push   %ecx
  1033a9:	e8 a2 13 00 00       	call   104750 <debug_info>
    if (idx >= NUM_CPUS)
  1033ae:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  1033b2:	83 c4 10             	add    $0x10,%esp
  1033b5:	83 f8 07             	cmp    $0x7,%eax
  1033b8:	77 1b                	ja     1033d5 <pcpu_mp_init+0x545>
    struct pcpuinfo *info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(idx);
  1033ba:	83 ec 0c             	sub    $0xc,%esp
                pcpu_mp_init_cpu(ap_idx, proc->apicid, FALSE);
  1033bd:	0f b6 6d 01          	movzbl 0x1(%ebp),%ebp
    struct pcpuinfo *info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(idx);
  1033c1:	50                   	push   %eax
  1033c2:	e8 d9 2f 00 00       	call   1063a0 <get_pcpu_arch_info_pointer>
    info->lapicid = lapic_id;
  1033c7:	89 e9                	mov    %ebp,%ecx
    info->bsp = is_bsp;
  1033c9:	83 c4 10             	add    $0x10,%esp
    info->lapicid = lapic_id;
  1033cc:	0f b6 d1             	movzbl %cl,%edx
    info->bsp = is_bsp;
  1033cf:	c6 40 04 00          	movb   $0x0,0x4(%eax)
    info->lapicid = lapic_id;
  1033d3:	89 10                	mov    %edx,(%eax)
                ap_idx++;
  1033d5:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
            ncpu++;
  1033da:	83 83 70 a9 08 00 01 	addl   $0x1,0x8a970(%ebx)
            p += sizeof(struct mpproc);
  1033e1:	89 fd                	mov    %edi,%ebp
            continue;
  1033e3:	e9 93 fe ff ff       	jmp    10327b <pcpu_mp_init+0x3eb>
  1033e8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1033ef:	00 
            break;
  1033f0:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  1033f5:	8d b3 cb 62 ff ff    	lea    -0x9d35(%ebx),%esi
  1033fb:	eb 11                	jmp    10340e <pcpu_mp_init+0x57e>
  1033fd:	8d 76 00             	lea    0x0(%esi),%esi
    for (p = addr; p < e; p += sizeof(struct mp))
  103400:	89 ef                	mov    %ebp,%edi
  103402:	81 fd 00 00 10 00    	cmp    $0x100000,%ebp
  103408:	0f 84 a2 fe ff ff    	je     1032b0 <pcpu_mp_init+0x420>
        if (memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
  10340e:	83 ec 04             	sub    $0x4,%esp
  103411:	8d 6f 10             	lea    0x10(%edi),%ebp
  103414:	6a 04                	push   $0x4
  103416:	56                   	push   %esi
  103417:	57                   	push   %edi
  103418:	e8 13 12 00 00       	call   104630 <memcmp>
  10341d:	83 c4 10             	add    $0x10,%esp
  103420:	85 c0                	test   %eax,%eax
  103422:	75 dc                	jne    103400 <pcpu_mp_init+0x570>
  103424:	89 fa                	mov    %edi,%edx
  103426:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10342d:	00 
  10342e:	66 90                	xchg   %ax,%ax
        sum += addr[i];
  103430:	0f b6 0a             	movzbl (%edx),%ecx
    for (i = 0; i < len; i++)
  103433:	83 c2 01             	add    $0x1,%edx
        sum += addr[i];
  103436:	01 c8                	add    %ecx,%eax
    for (i = 0; i < len; i++)
  103438:	39 ea                	cmp    %ebp,%edx
  10343a:	75 f4                	jne    103430 <pcpu_mp_init+0x5a0>
        if (memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
  10343c:	84 c0                	test   %al,%al
  10343e:	75 c0                	jne    103400 <pcpu_mp_init+0x570>
  103440:	e9 6c fd ff ff       	jmp    1031b1 <pcpu_mp_init+0x321>
                KERN_INFO("BSP.\n");
  103445:	83 ec 0c             	sub    $0xc,%esp
  103448:	8d 8b 2a 63 ff ff    	lea    -0x9cd6(%ebx),%ecx
  10344e:	51                   	push   %ecx
  10344f:	e8 fc 12 00 00       	call   104750 <debug_info>
                pcpu_mp_init_cpu(0, proc->apicid, TRUE);
  103454:	0f b6 6d 01          	movzbl 0x1(%ebp),%ebp
    struct pcpuinfo *info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(idx);
  103458:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10345f:	e8 3c 2f 00 00       	call   1063a0 <get_pcpu_arch_info_pointer>
    info->bsp = is_bsp;
  103464:	83 c4 10             	add    $0x10,%esp
    info->lapicid = lapic_id;
  103467:	89 e9                	mov    %ebp,%ecx
    info->bsp = is_bsp;
  103469:	c6 40 04 01          	movb   $0x1,0x4(%eax)
    info->lapicid = lapic_id;
  10346d:	0f b6 d1             	movzbl %cl,%edx
  103470:	89 10                	mov    %edx,(%eax)
    info->bsp = is_bsp;
  103472:	e9 63 ff ff ff       	jmp    1033da <pcpu_mp_init+0x54a>
        outb(0x22, 0x70);
  103477:	83 ec 08             	sub    $0x8,%esp
  10347a:	6a 70                	push   $0x70
  10347c:	6a 22                	push   $0x22
  10347e:	e8 9d 21 00 00       	call   105620 <outb>
        outb(0x23, inb(0x23) | 1);
  103483:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  10348a:	e8 61 21 00 00       	call   1055f0 <inb>
  10348f:	5a                   	pop    %edx
  103490:	59                   	pop    %ecx
  103491:	83 c8 01             	or     $0x1,%eax
  103494:	0f b6 c0             	movzbl %al,%eax
  103497:	50                   	push   %eax
  103498:	6a 23                	push   $0x23
  10349a:	e8 81 21 00 00       	call   105620 <outb>
  10349f:	83 c4 10             	add    $0x10,%esp
  1034a2:	e9 87 fe ff ff       	jmp    10332e <pcpu_mp_init+0x49e>
        KERN_DEBUG("Not found either RSDT or XSDT.\n");
  1034a7:	83 ec 04             	sub    $0x4,%esp
  1034aa:	8d 83 d0 6e ff ff    	lea    -0x9130(%ebx),%eax
  1034b0:	50                   	push   %eax
  1034b1:	68 56 01 00 00       	push   $0x156
  1034b6:	e9 74 fc ff ff       	jmp    10312f <pcpu_mp_init+0x29f>
  1034bb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

001034c0 <pcpu_boot_ap>:

int pcpu_boot_ap(uint32_t cpu_idx, void (*f)(void), uintptr_t stack_addr)
{
  1034c0:	57                   	push   %edi
  1034c1:	56                   	push   %esi
  1034c2:	53                   	push   %ebx
  1034c3:	8b 74 24 10          	mov    0x10(%esp),%esi
  1034c7:	e8 d6 ce ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1034cc:	81 c3 28 3b 01 00    	add    $0x13b28,%ebx
  1034d2:	8b 7c 24 14          	mov    0x14(%esp),%edi
    KERN_ASSERT(cpu_idx > 0 && cpu_idx < pcpu_ncpu());
  1034d6:	85 f6                	test   %esi,%esi
  1034d8:	74 6e                	je     103548 <pcpu_boot_ap+0x88>
  1034da:	3b b3 70 a9 08 00    	cmp    0x8a970(%ebx),%esi
  1034e0:	73 66                	jae    103548 <pcpu_boot_ap+0x88>
    KERN_ASSERT(get_pcpu_inited_info(cpu_idx) == TRUE);
  1034e2:	83 ec 0c             	sub    $0xc,%esp
  1034e5:	56                   	push   %esi
  1034e6:	e8 d5 2e 00 00       	call   1063c0 <get_pcpu_inited_info>
  1034eb:	83 c4 10             	add    $0x10,%esp
  1034ee:	3c 01                	cmp    $0x1,%al
  1034f0:	74 22                	je     103514 <pcpu_boot_ap+0x54>
  1034f2:	8d 83 b4 6f ff ff    	lea    -0x904c(%ebx),%eax
  1034f8:	50                   	push   %eax
  1034f9:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  1034ff:	50                   	push   %eax
  103500:	8d 83 e1 62 ff ff    	lea    -0x9d1f(%ebx),%eax
  103506:	68 b8 01 00 00       	push   $0x1b8
  10350b:	50                   	push   %eax
  10350c:	e8 df 12 00 00       	call   1047f0 <debug_panic>
  103511:	83 c4 10             	add    $0x10,%esp
    KERN_ASSERT(f != NULL);
  103514:	85 ff                	test   %edi,%edi
  103516:	0f 84 54 01 00 00    	je     103670 <pcpu_boot_ap+0x1b0>
    return ismp;
}

bool pcpu_onboot(void)
{
    int cpu_idx = get_pcpu_idx();
  10351c:	e8 3f 2d 00 00       	call   106260 <get_pcpu_idx>
    struct pcpuinfo *arch_info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(cpu_idx);
  103521:	83 ec 0c             	sub    $0xc,%esp
  103524:	50                   	push   %eax
  103525:	e8 76 2e 00 00       	call   1063a0 <get_pcpu_arch_info_pointer>
    return (mp_inited == TRUE) ? arch_info->bsp : (get_pcpu_idx() == 0);
  10352a:	83 c4 10             	add    $0x10,%esp
  10352d:	80 bb 6d a9 08 00 01 	cmpb   $0x1,0x8a96d(%ebx)
  103534:	75 3a                	jne    103570 <pcpu_boot_ap+0xb0>
    if (pcpu_onboot() == FALSE)
  103536:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
  10353a:	75 3d                	jne    103579 <pcpu_boot_ap+0xb9>
}
  10353c:	5b                   	pop    %ebx
        return 1;
  10353d:	b8 01 00 00 00       	mov    $0x1,%eax
}
  103542:	5e                   	pop    %esi
  103543:	5f                   	pop    %edi
  103544:	c3                   	ret
  103545:	8d 76 00             	lea    0x0(%esi),%esi
    KERN_ASSERT(cpu_idx > 0 && cpu_idx < pcpu_ncpu());
  103548:	8d 83 8c 6f ff ff    	lea    -0x9074(%ebx),%eax
  10354e:	50                   	push   %eax
  10354f:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  103555:	50                   	push   %eax
  103556:	8d 83 e1 62 ff ff    	lea    -0x9d1f(%ebx),%eax
  10355c:	68 b7 01 00 00       	push   $0x1b7
  103561:	50                   	push   %eax
  103562:	e8 89 12 00 00       	call   1047f0 <debug_panic>
  103567:	83 c4 10             	add    $0x10,%esp
  10356a:	e9 73 ff ff ff       	jmp    1034e2 <pcpu_boot_ap+0x22>
  10356f:	90                   	nop
    return (mp_inited == TRUE) ? arch_info->bsp : (get_pcpu_idx() == 0);
  103570:	e8 eb 2c 00 00       	call   106260 <get_pcpu_idx>
    if (pcpu_onboot() == FALSE)
  103575:	85 c0                	test   %eax,%eax
  103577:	75 c3                	jne    10353c <pcpu_boot_ap+0x7c>
    if (get_pcpu_boot_info(cpu_idx) == TRUE)
  103579:	83 ec 0c             	sub    $0xc,%esp
  10357c:	56                   	push   %esi
  10357d:	e8 8e 2d 00 00       	call   106310 <get_pcpu_boot_info>
  103582:	83 c4 10             	add    $0x10,%esp
  103585:	3c 01                	cmp    $0x1,%al
  103587:	74 7c                	je     103605 <pcpu_boot_ap+0x145>
    *(uintptr_t *) (boot - 4) = stack_addr + PAGE_SIZE;
  103589:	8b 44 24 18          	mov    0x18(%esp),%eax
}

lapicid_t pcpu_cpu_lapicid(int cpu_idx)
{
    struct pcpuinfo *arch_info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(cpu_idx);
  10358d:	83 ec 0c             	sub    $0xc,%esp
    *(uintptr_t *) (boot - 8) = (uintptr_t) f;
  103590:	89 3d f8 7f 00 00    	mov    %edi,0x7ff8
    *(uintptr_t *) (boot - 4) = stack_addr + PAGE_SIZE;
  103596:	05 00 10 00 00       	add    $0x1000,%eax
  10359b:	a3 fc 7f 00 00       	mov    %eax,0x7ffc
    *(uintptr_t *) (boot - 12) = (uintptr_t) kern_init_ap;
  1035a0:	c7 c0 30 65 10 00    	mov    $0x106530,%eax
  1035a6:	a3 f4 7f 00 00       	mov    %eax,0x7ff4
    struct pcpuinfo *arch_info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(cpu_idx);
  1035ab:	56                   	push   %esi
  1035ac:	e8 ef 2d 00 00       	call   1063a0 <get_pcpu_arch_info_pointer>
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < ncpu);
  1035b1:	83 c4 10             	add    $0x10,%esp
    struct pcpuinfo *arch_info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(cpu_idx);
  1035b4:	89 c7                	mov    %eax,%edi
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < ncpu);
  1035b6:	85 f6                	test   %esi,%esi
  1035b8:	0f 88 82 00 00 00    	js     103640 <pcpu_boot_ap+0x180>
  1035be:	3b b3 70 a9 08 00    	cmp    0x8a970(%ebx),%esi
  1035c4:	73 7a                	jae    103640 <pcpu_boot_ap+0x180>
    lapic_startcpu(pcpu_cpu_lapicid(cpu_idx), (uintptr_t) boot);
  1035c6:	83 ec 08             	sub    $0x8,%esp
  1035c9:	68 00 80 00 00       	push   $0x8000
  1035ce:	0f b6 07             	movzbl (%edi),%eax
  1035d1:	50                   	push   %eax
  1035d2:	e8 29 f3 ff ff       	call   102900 <lapic_startcpu>
    while (get_pcpu_boot_info(cpu_idx) == FALSE)
  1035d7:	83 c4 10             	add    $0x10,%esp
  1035da:	eb 09                	jmp    1035e5 <pcpu_boot_ap+0x125>
  1035dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        pause();
  1035e0:	e8 5b 1e 00 00       	call   105440 <pause>
    while (get_pcpu_boot_info(cpu_idx) == FALSE)
  1035e5:	83 ec 0c             	sub    $0xc,%esp
  1035e8:	56                   	push   %esi
  1035e9:	e8 22 2d 00 00       	call   106310 <get_pcpu_boot_info>
  1035ee:	83 c4 10             	add    $0x10,%esp
  1035f1:	84 c0                	test   %al,%al
  1035f3:	74 eb                	je     1035e0 <pcpu_boot_ap+0x120>
    KERN_ASSERT(get_pcpu_boot_info(cpu_idx) == TRUE);
  1035f5:	83 ec 0c             	sub    $0xc,%esp
  1035f8:	56                   	push   %esi
  1035f9:	e8 12 2d 00 00       	call   106310 <get_pcpu_boot_info>
  1035fe:	83 c4 10             	add    $0x10,%esp
  103601:	3c 01                	cmp    $0x1,%al
  103603:	75 0b                	jne    103610 <pcpu_boot_ap+0x150>
        return 0;
  103605:	31 c0                	xor    %eax,%eax
}
  103607:	5b                   	pop    %ebx
  103608:	5e                   	pop    %esi
  103609:	5f                   	pop    %edi
  10360a:	c3                   	ret
  10360b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    KERN_ASSERT(get_pcpu_boot_info(cpu_idx) == TRUE);
  103610:	8d 83 fc 6f ff ff    	lea    -0x9004(%ebx),%eax
  103616:	50                   	push   %eax
  103617:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  10361d:	50                   	push   %eax
  10361e:	8d 83 e1 62 ff ff    	lea    -0x9d1f(%ebx),%eax
  103624:	68 cd 01 00 00       	push   $0x1cd
  103629:	50                   	push   %eax
  10362a:	e8 c1 11 00 00       	call   1047f0 <debug_panic>
  10362f:	83 c4 10             	add    $0x10,%esp
        return 0;
  103632:	31 c0                	xor    %eax,%eax
  103634:	eb d1                	jmp    103607 <pcpu_boot_ap+0x147>
  103636:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10363d:	00 
  10363e:	66 90                	xchg   %ax,%ax
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < ncpu);
  103640:	8d 83 dc 6f ff ff    	lea    -0x9024(%ebx),%eax
  103646:	50                   	push   %eax
  103647:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  10364d:	50                   	push   %eax
  10364e:	8d 83 e1 62 ff ff    	lea    -0x9d1f(%ebx),%eax
  103654:	68 ea 01 00 00       	push   $0x1ea
  103659:	50                   	push   %eax
  10365a:	e8 91 11 00 00       	call   1047f0 <debug_panic>
  10365f:	83 c4 10             	add    $0x10,%esp
  103662:	e9 5f ff ff ff       	jmp    1035c6 <pcpu_boot_ap+0x106>
  103667:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10366e:	00 
  10366f:	90                   	nop
    KERN_ASSERT(f != NULL);
  103670:	8d 83 35 63 ff ff    	lea    -0x9ccb(%ebx),%eax
  103676:	50                   	push   %eax
  103677:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  10367d:	50                   	push   %eax
  10367e:	8d 83 e1 62 ff ff    	lea    -0x9d1f(%ebx),%eax
  103684:	68 b9 01 00 00       	push   $0x1b9
  103689:	50                   	push   %eax
  10368a:	e8 61 11 00 00       	call   1047f0 <debug_panic>
  10368f:	83 c4 10             	add    $0x10,%esp
  103692:	e9 85 fe ff ff       	jmp    10351c <pcpu_boot_ap+0x5c>
  103697:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10369e:	00 
  10369f:	90                   	nop

001036a0 <pcpu_init_cpu>:
{
  1036a0:	55                   	push   %ebp
  1036a1:	e8 63 db ff ff       	call   101209 <__x86.get_pc_thunk.bp>
  1036a6:	81 c5 4e 39 01 00    	add    $0x1394e,%ebp
  1036ac:	57                   	push   %edi
  1036ad:	56                   	push   %esi
  1036ae:	53                   	push   %ebx
  1036af:	83 ec 4c             	sub    $0x4c,%esp
    int cpu_idx = get_pcpu_idx();
  1036b2:	89 eb                	mov    %ebp,%ebx
  1036b4:	e8 a7 2b 00 00       	call   106260 <get_pcpu_idx>
    struct pcpuinfo *cpuinfo = (struct pcpuinfo *) get_pcpu_arch_info_pointer(cpu_idx);
  1036b9:	83 ec 0c             	sub    $0xc,%esp
  1036bc:	50                   	push   %eax
  1036bd:	e8 de 2c 00 00       	call   1063a0 <get_pcpu_arch_info_pointer>
    uint32_t *regs[4] = { &eax, &ebx, &ecx, &edx };
  1036c2:	8d 7c 24 3c          	lea    0x3c(%esp),%edi
  1036c6:	8d 4c 24 34          	lea    0x34(%esp),%ecx
  1036ca:	8d 5c 24 38          	lea    0x38(%esp),%ebx
    struct pcpuinfo *cpuinfo = (struct pcpuinfo *) get_pcpu_arch_info_pointer(cpu_idx);
  1036ce:	89 c6                	mov    %eax,%esi
    uint32_t *regs[4] = { &eax, &ebx, &ecx, &edx };
  1036d0:	8d 44 24 30          	lea    0x30(%esp),%eax
  1036d4:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  1036d8:	89 44 24 10          	mov    %eax,0x10(%esp)
  1036dc:	89 44 24 40          	mov    %eax,0x40(%esp)
  1036e0:	89 4c 24 44          	mov    %ecx,0x44(%esp)
  1036e4:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  1036e8:	89 5c 24 48          	mov    %ebx,0x48(%esp)
  1036ec:	89 7c 24 4c          	mov    %edi,0x4c(%esp)
    cpuid(0x0, &eax, &ebx, &ecx, &edx);
  1036f0:	89 3c 24             	mov    %edi,(%esp)
  1036f3:	53                   	push   %ebx
  1036f4:	89 eb                	mov    %ebp,%ebx
  1036f6:	51                   	push   %ecx
  1036f7:	50                   	push   %eax
  1036f8:	6a 00                	push   $0x0
  1036fa:	e8 c1 1d 00 00       	call   1054c0 <cpuid>
    cpuinfo->cpuid_high = eax;
  1036ff:	8b 44 24 40          	mov    0x40(%esp),%eax
    cpuinfo->vendor[12] = '\0';
  103703:	c6 46 18 00          	movb   $0x0,0x18(%esi)
    cpuinfo->cpuid_high = eax;
  103707:	89 46 08             	mov    %eax,0x8(%esi)
    ((uint32_t *) cpuinfo->vendor)[0] = ebx;
  10370a:	8b 44 24 44          	mov    0x44(%esp),%eax
  10370e:	89 46 0c             	mov    %eax,0xc(%esi)
    ((uint32_t *) cpuinfo->vendor)[1] = edx;
  103711:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  103715:	89 46 10             	mov    %eax,0x10(%esi)
    ((uint32_t *) cpuinfo->vendor)[2] = ecx;
  103718:	8b 44 24 48          	mov    0x48(%esp),%eax
  10371c:	89 46 14             	mov    %eax,0x14(%esi)
    if (strncmp(cpuinfo->vendor, "GenuineIntel", 20) == 0)
  10371f:	8d 46 0c             	lea    0xc(%esi),%eax
  103722:	89 44 24 30          	mov    %eax,0x30(%esp)
  103726:	89 c1                	mov    %eax,%ecx
  103728:	83 c4 1c             	add    $0x1c,%esp
  10372b:	8d 85 74 63 ff ff    	lea    -0x9c8c(%ebp),%eax
  103731:	6a 14                	push   $0x14
  103733:	50                   	push   %eax
  103734:	51                   	push   %ecx
  103735:	e8 b6 0d 00 00       	call   1044f0 <strncmp>
  10373a:	83 c4 10             	add    $0x10,%esp
  10373d:	89 c2                	mov    %eax,%edx
  10373f:	b8 01 00 00 00       	mov    $0x1,%eax
  103744:	85 d2                	test   %edx,%edx
  103746:	0f 85 f4 02 00 00    	jne    103a40 <pcpu_init_cpu+0x3a0>
    cpuid(0x1, &eax, &ebx, &ecx, &edx);
  10374c:	83 ec 0c             	sub    $0xc,%esp
        cpuinfo->cpu_vendor = INTEL;
  10374f:	89 46 20             	mov    %eax,0x20(%esi)
    cpuid(0x1, &eax, &ebx, &ecx, &edx);
  103752:	89 eb                	mov    %ebp,%ebx
  103754:	57                   	push   %edi
  103755:	ff 74 24 18          	push   0x18(%esp)
  103759:	ff 74 24 18          	push   0x18(%esp)
  10375d:	ff 74 24 18          	push   0x18(%esp)
  103761:	6a 01                	push   $0x1
  103763:	e8 58 1d 00 00       	call   1054c0 <cpuid>
    cpuinfo->family = (eax >> 8) & 0xf;
  103768:	8b 44 24 40          	mov    0x40(%esp),%eax
  10376c:	89 c2                	mov    %eax,%edx
  10376e:	c1 ea 08             	shr    $0x8,%edx
  103771:	83 e2 0f             	and    $0xf,%edx
  103774:	88 56 24             	mov    %dl,0x24(%esi)
    cpuinfo->model = (eax >> 4) & 0xf;
  103777:	89 c2                	mov    %eax,%edx
  103779:	c0 ea 04             	shr    $0x4,%dl
  10377c:	88 56 25             	mov    %dl,0x25(%esi)
    cpuinfo->step = eax & 0xf;
  10377f:	89 c2                	mov    %eax,%edx
  103781:	83 e2 0f             	and    $0xf,%edx
  103784:	88 56 26             	mov    %dl,0x26(%esi)
    cpuinfo->ext_family = (eax >> 20) & 0xff;
  103787:	89 c2                	mov    %eax,%edx
    cpuinfo->ext_model = (eax >> 16) & 0xff;
  103789:	c1 e8 10             	shr    $0x10,%eax
  10378c:	88 46 28             	mov    %al,0x28(%esi)
    cpuinfo->brand_idx = ebx & 0xff;
  10378f:	8b 44 24 44          	mov    0x44(%esp),%eax
    cpuinfo->ext_family = (eax >> 20) & 0xff;
  103793:	c1 ea 14             	shr    $0x14,%edx
  103796:	88 56 27             	mov    %dl,0x27(%esi)
    cpuinfo->brand_idx = ebx & 0xff;
  103799:	89 46 29             	mov    %eax,0x29(%esi)
    cpuinfo->feature1 = ecx;
  10379c:	8b 44 24 48          	mov    0x48(%esp),%eax
  1037a0:	89 46 30             	mov    %eax,0x30(%esi)
    cpuinfo->feature2 = edx;
  1037a3:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    switch (cpuinfo->cpu_vendor) {
  1037a7:	83 c4 20             	add    $0x20,%esp
    cpuinfo->feature2 = edx;
  1037aa:	89 46 34             	mov    %eax,0x34(%esi)
    switch (cpuinfo->cpu_vendor) {
  1037ad:	8b 46 20             	mov    0x20(%esi),%eax
  1037b0:	83 f8 01             	cmp    $0x1,%eax
  1037b3:	0f 84 6f 01 00 00    	je     103928 <pcpu_init_cpu+0x288>
  1037b9:	83 f8 02             	cmp    $0x2,%eax
  1037bc:	0f 85 4e 01 00 00    	jne    103910 <pcpu_init_cpu+0x270>
        cpuid(0x80000005, &eax, &ebx, &ecx, &edx);
  1037c2:	83 ec 0c             	sub    $0xc,%esp
  1037c5:	57                   	push   %edi
  1037c6:	ff 74 24 18          	push   0x18(%esp)
  1037ca:	ff 74 24 18          	push   0x18(%esp)
  1037ce:	ff 74 24 18          	push   0x18(%esp)
  1037d2:	68 05 00 00 80       	push   $0x80000005
  1037d7:	e8 e4 1c 00 00       	call   1054c0 <cpuid>
        cpuinfo->l1_cache_size = (ecx & 0xff000000) >> 24;
  1037dc:	8b 44 24 48          	mov    0x48(%esp),%eax
        break;
  1037e0:	83 c4 20             	add    $0x20,%esp
        cpuinfo->l1_cache_size = (ecx & 0xff000000) >> 24;
  1037e3:	89 c2                	mov    %eax,%edx
        cpuinfo->l1_cache_line_size = (ecx & 0x000000ff);
  1037e5:	25 ff 00 00 00       	and    $0xff,%eax
        cpuinfo->l1_cache_size = (ecx & 0xff000000) >> 24;
  1037ea:	c1 ea 18             	shr    $0x18,%edx
        cpuinfo->l1_cache_line_size = (ecx & 0x000000ff);
  1037ed:	89 46 3c             	mov    %eax,0x3c(%esi)
        cpuinfo->l1_cache_size = (ecx & 0xff000000) >> 24;
  1037f0:	89 56 38             	mov    %edx,0x38(%esi)
    cpuid(0x80000000, &eax, &ebx, &ecx, &edx);
  1037f3:	83 ec 0c             	sub    $0xc,%esp
  1037f6:	89 eb                	mov    %ebp,%ebx
  1037f8:	57                   	push   %edi
  1037f9:	ff 74 24 18          	push   0x18(%esp)
  1037fd:	ff 74 24 18          	push   0x18(%esp)
  103801:	ff 74 24 18          	push   0x18(%esp)
  103805:	68 00 00 00 80       	push   $0x80000000
  10380a:	e8 b1 1c 00 00       	call   1054c0 <cpuid>
    cpuinfo->cpuid_exthigh = eax;
  10380f:	8b 44 24 40          	mov    0x40(%esp),%eax
    pcpu_print_cpuinfo(get_pcpu_idx(), cpuinfo);
  103813:	83 c4 20             	add    $0x20,%esp
    cpuinfo->cpuid_exthigh = eax;
  103816:	89 46 40             	mov    %eax,0x40(%esi)
    pcpu_print_cpuinfo(get_pcpu_idx(), cpuinfo);
  103819:	e8 42 2a 00 00       	call   106260 <get_pcpu_idx>
    KERN_INFO("CPU%d: %s, FAMILY %d(%d), MODEL %d(%d), STEP %d, "
  10381e:	8b 56 30             	mov    0x30(%esi),%edx
  103821:	8d 8d 3f 63 ff ff    	lea    -0x9cc1(%ebp),%ecx
  103827:	8b 7e 38             	mov    0x38(%esi),%edi
    pcpu_print_cpuinfo(get_pcpu_idx(), cpuinfo);
  10382a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    KERN_INFO("CPU%d: %s, FAMILY %d(%d), MODEL %d(%d), STEP %d, "
  10382e:	8d 85 91 65 ff ff    	lea    -0x9a6f(%ebp),%eax
  103834:	f7 c2 00 00 80 00    	test   $0x800000,%edx
  10383a:	89 3c 24             	mov    %edi,(%esp)
  10383d:	0f 44 c8             	cmove  %eax,%ecx
  103840:	f7 c2 00 00 10 00    	test   $0x100000,%edx
  103846:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  10384a:	8d 8d 48 63 ff ff    	lea    -0x9cb8(%ebp),%ecx
  103850:	89 cf                	mov    %ecx,%edi
  103852:	8d 8d 50 63 ff ff    	lea    -0x9cb0(%ebp),%ecx
  103858:	0f 44 f8             	cmove  %eax,%edi
  10385b:	f7 c2 00 00 08 00    	test   $0x80000,%edx
  103861:	0f 44 c8             	cmove  %eax,%ecx
  103864:	f6 c6 02             	test   $0x2,%dh
  103867:	89 7c 24 14          	mov    %edi,0x14(%esp)
  10386b:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  10386f:	8d 8d 58 63 ff ff    	lea    -0x9ca8(%ebp),%ecx
  103875:	89 cb                	mov    %ecx,%ebx
  103877:	8d 8d 60 63 ff ff    	lea    -0x9ca0(%ebp),%ecx
  10387d:	0f 44 d8             	cmove  %eax,%ebx
  103880:	89 cf                	mov    %ecx,%edi
  103882:	8b 4e 34             	mov    0x34(%esi),%ecx
  103885:	f6 c2 01             	test   $0x1,%dl
  103888:	0f 44 f8             	cmove  %eax,%edi
  10388b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10388f:	f7 c1 00 00 00 04    	test   $0x4000000,%ecx
  103895:	8d 9d 67 63 ff ff    	lea    -0x9c99(%ebp),%ebx
  10389b:	0f 44 d8             	cmove  %eax,%ebx
  10389e:	f7 c1 00 00 00 02    	test   $0x2000000,%ecx
  1038a4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1038a8:	8d 9d 6e 63 ff ff    	lea    -0x9c92(%ebp),%ebx
  1038ae:	0f 45 c3             	cmovne %ebx,%eax
  1038b1:	83 ec 04             	sub    $0x4,%esp
  1038b4:	ff 76 3c             	push   0x3c(%esi)
  1038b7:	89 eb                	mov    %ebp,%ebx
  1038b9:	ff 74 24 08          	push   0x8(%esp)
  1038bd:	ff 74 24 24          	push   0x24(%esp)
  1038c1:	ff 74 24 24          	push   0x24(%esp)
  1038c5:	ff 74 24 20          	push   0x20(%esp)
  1038c9:	ff 74 24 20          	push   0x20(%esp)
  1038cd:	57                   	push   %edi
  1038ce:	ff 74 24 24          	push   0x24(%esp)
  1038d2:	50                   	push   %eax
  1038d3:	51                   	push   %ecx
  1038d4:	52                   	push   %edx
  1038d5:	0f b6 46 26          	movzbl 0x26(%esi),%eax
  1038d9:	50                   	push   %eax
  1038da:	0f b6 46 28          	movzbl 0x28(%esi),%eax
  1038de:	50                   	push   %eax
  1038df:	0f b6 46 25          	movzbl 0x25(%esi),%eax
  1038e3:	50                   	push   %eax
  1038e4:	0f b6 46 27          	movzbl 0x27(%esi),%eax
  1038e8:	50                   	push   %eax
  1038e9:	0f b6 46 24          	movzbl 0x24(%esi),%eax
  1038ed:	50                   	push   %eax
  1038ee:	8d 85 20 70 ff ff    	lea    -0x8fe0(%ebp),%eax
  1038f4:	ff 74 24 54          	push   0x54(%esp)
  1038f8:	ff 74 24 64          	push   0x64(%esp)
  1038fc:	50                   	push   %eax
  1038fd:	e8 4e 0e 00 00       	call   104750 <debug_info>
}
  103902:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  103908:	5b                   	pop    %ebx
  103909:	5e                   	pop    %esi
  10390a:	5f                   	pop    %edi
  10390b:	5d                   	pop    %ebp
  10390c:	c3                   	ret
  10390d:	8d 76 00             	lea    0x0(%esi),%esi
        cpuinfo->l1_cache_size = 0;
  103910:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
        cpuinfo->l1_cache_line_size = 0;
  103917:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
        break;
  10391e:	e9 d0 fe ff ff       	jmp    1037f3 <pcpu_init_cpu+0x153>
  103923:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        cpuid(0x00000002, &eax, &ebx, &ecx, &edx);
  103928:	83 ec 0c             	sub    $0xc,%esp
  10392b:	57                   	push   %edi
  10392c:	ff 74 24 18          	push   0x18(%esp)
  103930:	ff 74 24 18          	push   0x18(%esp)
  103934:	ff 74 24 18          	push   0x18(%esp)
  103938:	6a 02                	push   $0x2
  10393a:	e8 81 1b 00 00       	call   1054c0 <cpuid>
        i = eax & 0x000000ff;
  10393f:	0f b6 44 24 40       	movzbl 0x40(%esp),%eax
        while (i--)
  103944:	83 c4 20             	add    $0x20,%esp
  103947:	85 c0                	test   %eax,%eax
  103949:	74 32                	je     10397d <pcpu_init_cpu+0x2dd>
  10394b:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10394f:	89 c6                	mov    %eax,%esi
  103951:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            cpuid(0x00000002, &eax, &ebx, &ecx, &edx);
  103958:	83 ec 0c             	sub    $0xc,%esp
  10395b:	89 eb                	mov    %ebp,%ebx
  10395d:	57                   	push   %edi
  10395e:	ff 74 24 18          	push   0x18(%esp)
  103962:	ff 74 24 18          	push   0x18(%esp)
  103966:	ff 74 24 18          	push   0x18(%esp)
  10396a:	6a 02                	push   $0x2
  10396c:	e8 4f 1b 00 00       	call   1054c0 <cpuid>
        while (i--)
  103971:	83 c4 20             	add    $0x20,%esp
  103974:	83 ee 01             	sub    $0x1,%esi
  103977:	75 df                	jne    103958 <pcpu_init_cpu+0x2b8>
  103979:	8b 74 24 0c          	mov    0xc(%esp),%esi
        for (i = 0; i < 4; i++) {
  10397d:	8d 44 24 30          	lea    0x30(%esp),%eax
  103981:	89 7c 24 18          	mov    %edi,0x18(%esp)
  103985:	8d 8d 0c 76 ff ff    	lea    -0x89f4(%ebp),%ecx
  10398b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10398f:	8d 44 24 40          	lea    0x40(%esp),%eax
  103993:	89 44 24 14          	mov    %eax,0x14(%esp)
            for (j = 0; j < 4; j++) {
  103997:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10399b:	8b 00                	mov    (%eax),%eax
  10399d:	8d 78 04             	lea    0x4(%eax),%edi
                cpuinfo->l1_cache_size = intel_cache_info[desc[j]][0];
  1039a0:	0f b6 10             	movzbl (%eax),%edx
            for (j = 0; j < 4; j++) {
  1039a3:	83 c0 01             	add    $0x1,%eax
                cpuinfo->l1_cache_size = intel_cache_info[desc[j]][0];
  1039a6:	8b 14 d1             	mov    (%ecx,%edx,8),%edx
  1039a9:	89 56 38             	mov    %edx,0x38(%esi)
                cpuinfo->l1_cache_line_size = intel_cache_info[desc[j]][1];
  1039ac:	0f b6 58 ff          	movzbl -0x1(%eax),%ebx
  1039b0:	8b 5c d9 04          	mov    0x4(%ecx,%ebx,8),%ebx
  1039b4:	89 5e 3c             	mov    %ebx,0x3c(%esi)
            for (j = 0; j < 4; j++) {
  1039b7:	39 f8                	cmp    %edi,%eax
  1039b9:	75 e5                	jne    1039a0 <pcpu_init_cpu+0x300>
        for (i = 0; i < 4; i++) {
  1039bb:	83 44 24 0c 04       	addl   $0x4,0xc(%esp)
  1039c0:	8b 7c 24 14          	mov    0x14(%esp),%edi
  1039c4:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1039c8:	39 f8                	cmp    %edi,%eax
  1039ca:	75 cb                	jne    103997 <pcpu_init_cpu+0x2f7>
        if (cpuinfo->l1_cache_size && cpuinfo->l1_cache_line_size)
  1039cc:	8b 7c 24 18          	mov    0x18(%esp),%edi
  1039d0:	85 d2                	test   %edx,%edx
  1039d2:	0f 85 98 00 00 00    	jne    103a70 <pcpu_init_cpu+0x3d0>
  1039d8:	31 d2                	xor    %edx,%edx
  1039da:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1039de:	89 d6                	mov    %edx,%esi
            cpuid_subleaf(0x00000004, i, &eax, &ebx, &ecx, &edx);
  1039e0:	83 ec 08             	sub    $0x8,%esp
  1039e3:	89 eb                	mov    %ebp,%ebx
  1039e5:	57                   	push   %edi
  1039e6:	ff 74 24 14          	push   0x14(%esp)
  1039ea:	ff 74 24 14          	push   0x14(%esp)
  1039ee:	ff 74 24 14          	push   0x14(%esp)
  1039f2:	56                   	push   %esi
  1039f3:	6a 04                	push   $0x4
  1039f5:	e8 06 1b 00 00       	call   105500 <cpuid_subleaf>
            if ((eax & 0xf) == 1 && ((eax & 0xe0) >> 5) == 1)
  1039fa:	8b 44 24 40          	mov    0x40(%esp),%eax
  1039fe:	83 c4 20             	add    $0x20,%esp
  103a01:	25 ef 00 00 00       	and    $0xef,%eax
  103a06:	83 f8 21             	cmp    $0x21,%eax
  103a09:	74 72                	je     103a7d <pcpu_init_cpu+0x3dd>
        for (i = 0; i < 3; i++) {
  103a0b:	83 c6 01             	add    $0x1,%esi
  103a0e:	83 fe 03             	cmp    $0x3,%esi
  103a11:	75 cd                	jne    1039e0 <pcpu_init_cpu+0x340>
  103a13:	8b 74 24 0c          	mov    0xc(%esp),%esi
            KERN_WARN("Cannot determine L1 cache size.\n");
  103a17:	8d 85 90 70 ff ff    	lea    -0x8f70(%ebp),%eax
  103a1d:	83 ec 04             	sub    $0x4,%esp
  103a20:	50                   	push   %eax
  103a21:	8d 85 e1 62 ff ff    	lea    -0x9d1f(%ebp),%eax
  103a27:	6a 7c                	push   $0x7c
  103a29:	50                   	push   %eax
  103a2a:	e8 d1 0e 00 00       	call   104900 <debug_warn>
            break;
  103a2f:	83 c4 10             	add    $0x10,%esp
  103a32:	e9 bc fd ff ff       	jmp    1037f3 <pcpu_init_cpu+0x153>
  103a37:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  103a3e:	00 
  103a3f:	90                   	nop
    else if (strncmp(cpuinfo->vendor, "AuthenticAMD", 20) == 0)
  103a40:	83 ec 04             	sub    $0x4,%esp
  103a43:	8d 85 81 63 ff ff    	lea    -0x9c7f(%ebp),%eax
  103a49:	6a 14                	push   $0x14
  103a4b:	50                   	push   %eax
  103a4c:	ff 74 24 1c          	push   0x1c(%esp)
  103a50:	e8 9b 0a 00 00       	call   1044f0 <strncmp>
  103a55:	83 c4 10             	add    $0x10,%esp
  103a58:	85 c0                	test   %eax,%eax
  103a5a:	0f 94 c0             	sete   %al
  103a5d:	0f b6 c0             	movzbl %al,%eax
  103a60:	01 c0                	add    %eax,%eax
  103a62:	e9 e5 fc ff ff       	jmp    10374c <pcpu_init_cpu+0xac>
  103a67:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  103a6e:	00 
  103a6f:	90                   	nop
        if (cpuinfo->l1_cache_size && cpuinfo->l1_cache_line_size)
  103a70:	85 db                	test   %ebx,%ebx
  103a72:	0f 85 7b fd ff ff    	jne    1037f3 <pcpu_init_cpu+0x153>
  103a78:	e9 5b ff ff ff       	jmp    1039d8 <pcpu_init_cpu+0x338>
            (((ebx & 0xffc00000) >> 22) + 1) *  /* ways */
  103a7d:	8b 5c 24 24          	mov    0x24(%esp),%ebx
            (ecx + 1) /                         /* sets */
  103a81:	8b 54 24 28          	mov    0x28(%esp),%edx
            (((ebx & 0xffc00000) >> 22) + 1) *  /* ways */
  103a85:	8b 74 24 0c          	mov    0xc(%esp),%esi
            (((ebx & 0x00000fff)) + 1) *        /* line size */
  103a89:	89 d8                	mov    %ebx,%eax
            (ecx + 1) /                         /* sets */
  103a8b:	83 c2 01             	add    $0x1,%edx
            (((ebx & 0x00000fff)) + 1) *        /* line size */
  103a8e:	25 ff 0f 00 00       	and    $0xfff,%eax
  103a93:	8d 48 01             	lea    0x1(%eax),%ecx
            (((ebx & 0xffc00000) >> 22) + 1) *  /* ways */
  103a96:	89 d8                	mov    %ebx,%eax
            (((ebx & 0x003ff000) >> 12) + 1) *  /* partitions */
  103a98:	c1 eb 0c             	shr    $0xc,%ebx
            (((ebx & 0xffc00000) >> 22) + 1) *  /* ways */
  103a9b:	c1 e8 16             	shr    $0x16,%eax
        cpuinfo->l1_cache_line_size = ((ebx & 0x00000fff)) + 1;
  103a9e:	89 4e 3c             	mov    %ecx,0x3c(%esi)
            (((ebx & 0xffc00000) >> 22) + 1) *  /* ways */
  103aa1:	83 c0 01             	add    $0x1,%eax
            (((ebx & 0x00000fff)) + 1) *        /* line size */
  103aa4:	0f af c1             	imul   %ecx,%eax
  103aa7:	0f af c2             	imul   %edx,%eax
            (((ebx & 0x003ff000) >> 12) + 1) *  /* partitions */
  103aaa:	89 da                	mov    %ebx,%edx
  103aac:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  103ab2:	83 c2 01             	add    $0x1,%edx
            (((ebx & 0x00000fff)) + 1) *        /* line size */
  103ab5:	0f af c2             	imul   %edx,%eax
            (ecx + 1) /                         /* sets */
  103ab8:	c1 e8 0a             	shr    $0xa,%eax
  103abb:	89 46 38             	mov    %eax,0x38(%esi)
        break;
  103abe:	e9 30 fd ff ff       	jmp    1037f3 <pcpu_init_cpu+0x153>
  103ac3:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  103aca:	00 
  103acb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00103ad0 <pcpu_ncpu>:
    return ncpu;
  103ad0:	e8 c5 c8 ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  103ad5:	05 1f 35 01 00       	add    $0x1351f,%eax
  103ada:	8b 80 70 a9 08 00    	mov    0x8a970(%eax),%eax
}
  103ae0:	c3                   	ret
  103ae1:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  103ae8:	00 
  103ae9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00103af0 <pcpu_is_smp>:
    return ismp;
  103af0:	e8 a5 c8 ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  103af5:	05 ff 34 01 00       	add    $0x134ff,%eax
  103afa:	0f b6 80 6c a9 08 00 	movzbl 0x8a96c(%eax),%eax
}
  103b01:	c3                   	ret
  103b02:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  103b09:	00 
  103b0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00103b10 <pcpu_onboot>:
{
  103b10:	53                   	push   %ebx
  103b11:	e8 8c c8 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  103b16:	81 c3 de 34 01 00    	add    $0x134de,%ebx
  103b1c:	83 ec 08             	sub    $0x8,%esp
    int cpu_idx = get_pcpu_idx();
  103b1f:	e8 3c 27 00 00       	call   106260 <get_pcpu_idx>
    struct pcpuinfo *arch_info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(cpu_idx);
  103b24:	83 ec 0c             	sub    $0xc,%esp
  103b27:	50                   	push   %eax
  103b28:	e8 73 28 00 00       	call   1063a0 <get_pcpu_arch_info_pointer>
    return (mp_inited == TRUE) ? arch_info->bsp : (get_pcpu_idx() == 0);
  103b2d:	83 c4 10             	add    $0x10,%esp
  103b30:	80 bb 6d a9 08 00 01 	cmpb   $0x1,0x8a96d(%ebx)
  103b37:	75 0f                	jne    103b48 <pcpu_onboot+0x38>
  103b39:	0f b6 40 04          	movzbl 0x4(%eax),%eax
}
  103b3d:	83 c4 08             	add    $0x8,%esp
  103b40:	5b                   	pop    %ebx
  103b41:	c3                   	ret
  103b42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    return (mp_inited == TRUE) ? arch_info->bsp : (get_pcpu_idx() == 0);
  103b48:	e8 13 27 00 00       	call   106260 <get_pcpu_idx>
  103b4d:	85 c0                	test   %eax,%eax
  103b4f:	0f 94 c0             	sete   %al
}
  103b52:	83 c4 08             	add    $0x8,%esp
  103b55:	5b                   	pop    %ebx
  103b56:	c3                   	ret
  103b57:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  103b5e:	00 
  103b5f:	90                   	nop

00103b60 <pcpu_cpu_lapicid>:
{
  103b60:	57                   	push   %edi
  103b61:	56                   	push   %esi
  103b62:	53                   	push   %ebx
  103b63:	8b 7c 24 10          	mov    0x10(%esp),%edi
  103b67:	e8 36 c8 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  103b6c:	81 c3 88 34 01 00    	add    $0x13488,%ebx
    struct pcpuinfo *arch_info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(cpu_idx);
  103b72:	83 ec 0c             	sub    $0xc,%esp
  103b75:	57                   	push   %edi
  103b76:	e8 25 28 00 00       	call   1063a0 <get_pcpu_arch_info_pointer>
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < ncpu);
  103b7b:	83 c4 10             	add    $0x10,%esp
    struct pcpuinfo *arch_info = (struct pcpuinfo *) get_pcpu_arch_info_pointer(cpu_idx);
  103b7e:	89 c6                	mov    %eax,%esi
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < ncpu);
  103b80:	85 ff                	test   %edi,%edi
  103b82:	78 08                	js     103b8c <pcpu_cpu_lapicid+0x2c>
  103b84:	3b bb 70 a9 08 00    	cmp    0x8a970(%ebx),%edi
  103b8a:	72 22                	jb     103bae <pcpu_cpu_lapicid+0x4e>
  103b8c:	8d 83 dc 6f ff ff    	lea    -0x9024(%ebx),%eax
  103b92:	50                   	push   %eax
  103b93:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  103b99:	50                   	push   %eax
  103b9a:	8d 83 e1 62 ff ff    	lea    -0x9d1f(%ebx),%eax
  103ba0:	68 ea 01 00 00       	push   $0x1ea
  103ba5:	50                   	push   %eax
  103ba6:	e8 45 0c 00 00       	call   1047f0 <debug_panic>
  103bab:	83 c4 10             	add    $0x10,%esp
    return arch_info->lapicid;
  103bae:	0f b6 06             	movzbl (%esi),%eax
}
  103bb1:	5b                   	pop    %ebx
  103bb2:	5e                   	pop    %esi
  103bb3:	5f                   	pop    %edi
  103bb4:	c3                   	ret

00103bb5 <__x86.get_pc_thunk.si>:
  103bb5:	8b 34 24             	mov    (%esp),%esi
  103bb8:	c3                   	ret
  103bb9:	66 90                	xchg   %ax,%ax
  103bbb:	66 90                	xchg   %ax,%ax
  103bbd:	66 90                	xchg   %ax,%ax
  103bbf:	90                   	nop

00103bc0 <ioapicinit>:
void ioapicinit(void)
{
    int32_t i, maxintr;
    int32_t id __attribute__((unused));

    ioapic = (volatile struct ioapic *) IOAPIC;
  103bc0:	e8 d5 c7 ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  103bc5:	05 2f 34 01 00       	add    $0x1342f,%eax
{
  103bca:	53                   	push   %ebx
    return ioapic->data;
  103bcb:	ba 10 00 00 00       	mov    $0x10,%edx
    ioapic = (volatile struct ioapic *) IOAPIC;
  103bd0:	c7 80 74 a9 08 00 00 	movl   $0xfec00000,0x8a974(%eax)
  103bd7:	00 c0 fe 
    ioapic->reg = reg;
  103bda:	c7 05 00 00 c0 fe 01 	movl   $0x1,0xfec00000
  103be1:	00 00 00 
    return ioapic->data;
  103be4:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
    ioapic->reg = reg;
  103bea:	c7 05 00 00 c0 fe 00 	movl   $0x0,0xfec00000
  103bf1:	00 00 00 
    return ioapic->data;
  103bf4:	a1 10 00 c0 fe       	mov    0xfec00010,%eax
    maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
    id = ioapicread(REG_ID) >> 24;

    // Mark all interrupts edge-triggered, active high, disabled,
    // and not routed to any CPUs.
    for (i = 0; i <= maxintr; i++) {
  103bf9:	31 c0                	xor    %eax,%eax
    maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
  103bfb:	c1 eb 10             	shr    $0x10,%ebx
  103bfe:	0f b6 db             	movzbl %bl,%ebx
    for (i = 0; i <= maxintr; i++) {
  103c01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        ioapicwrite(REG_TABLE + 2 * i, INT_DISABLED | (T_IRQ0 + i));
  103c08:	8d 48 20             	lea    0x20(%eax),%ecx
    ioapic->reg = reg;
  103c0b:	89 15 00 00 c0 fe    	mov    %edx,0xfec00000
    for (i = 0; i <= maxintr; i++) {
  103c11:	83 c0 01             	add    $0x1,%eax
  103c14:	81 c9 00 00 01 00    	or     $0x10000,%ecx
    ioapic->data = data;
  103c1a:	89 0d 10 00 c0 fe    	mov    %ecx,0xfec00010
    ioapic->reg = reg;
  103c20:	8d 4a 01             	lea    0x1(%edx),%ecx
    for (i = 0; i <= maxintr; i++) {
  103c23:	83 c2 02             	add    $0x2,%edx
    ioapic->reg = reg;
  103c26:	89 0d 00 00 c0 fe    	mov    %ecx,0xfec00000
    ioapic->data = data;
  103c2c:	c7 05 10 00 c0 fe 00 	movl   $0x0,0xfec00010
  103c33:	00 00 00 
    for (i = 0; i <= maxintr; i++) {
  103c36:	39 c3                	cmp    %eax,%ebx
  103c38:	7d ce                	jge    103c08 <ioapicinit+0x48>
        ioapicwrite(REG_TABLE + 2 * i + 1, 0);
    }
}
  103c3a:	5b                   	pop    %ebx
  103c3b:	c3                   	ret
  103c3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00103c40 <ioapicenable>:

void ioapicenable(int irq, int cpunum)
{
  103c40:	53                   	push   %ebx
  103c41:	8b 44 24 08          	mov    0x8(%esp),%eax
  103c45:	e8 58 c7 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  103c4a:	81 c3 aa 33 01 00    	add    $0x133aa,%ebx
    // Mark interrupt edge-triggered, active high,
    // enabled, and routed to the given cpunum,
    // which happens to be that cpu's APIC ID.
    ioapicwrite(REG_TABLE + 2 * irq, T_IRQ0 + irq);
  103c50:	8d 48 20             	lea    0x20(%eax),%ecx
  103c53:	8d 54 00 10          	lea    0x10(%eax,%eax,1),%edx
    ioapic->reg = reg;
  103c57:	8b 83 74 a9 08 00    	mov    0x8a974(%ebx),%eax
  103c5d:	89 10                	mov    %edx,(%eax)
    ioapicwrite(REG_TABLE + 2 * irq + 1, cpunum << 24);
  103c5f:	83 c2 01             	add    $0x1,%edx
    ioapic->data = data;
  103c62:	89 48 10             	mov    %ecx,0x10(%eax)
    ioapicwrite(REG_TABLE + 2 * irq + 1, cpunum << 24);
  103c65:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    ioapic->reg = reg;
  103c69:	89 10                	mov    %edx,(%eax)
    ioapicwrite(REG_TABLE + 2 * irq + 1, cpunum << 24);
  103c6b:	c1 e1 18             	shl    $0x18,%ecx
    ioapic->data = data;
  103c6e:	89 48 10             	mov    %ecx,0x10(%eax)
}
  103c71:	5b                   	pop    %ebx
  103c72:	c3                   	ret
  103c73:	66 90                	xchg   %ax,%ax
  103c75:	66 90                	xchg   %ax,%ax
  103c77:	66 90                	xchg   %ax,%ax
  103c79:	66 90                	xchg   %ax,%ax
  103c7b:	66 90                	xchg   %ax,%ax
  103c7d:	66 90                	xchg   %ax,%ax
  103c7f:	90                   	nop

00103c80 <picenable>:
    outb(IO_PIC1 + 1, mask);
    outb(IO_PIC2 + 1, mask >> 8);
}

void picenable(int32_t irq)
{
  103c80:	56                   	push   %esi
  103c81:	53                   	push   %ebx
  103c82:	e8 1b c7 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  103c87:	81 c3 6d 33 01 00    	add    $0x1336d,%ebx
  103c8d:	83 ec 0c             	sub    $0xc,%esp
    picsetmask(irqmask & ~(1 << irq));
  103c90:	8b 44 24 18          	mov    0x18(%esp),%eax
  103c94:	0f b7 b3 14 03 00 00 	movzwl 0x314(%ebx),%esi
  103c9b:	0f b3 c6             	btr    %eax,%esi
    outb(IO_PIC1 + 1, mask);
  103c9e:	89 f0                	mov    %esi,%eax
    irqmask = mask;
  103ca0:	66 89 b3 14 03 00 00 	mov    %si,0x314(%ebx)
    outb(IO_PIC1 + 1, mask);
  103ca7:	0f b6 c0             	movzbl %al,%eax
  103caa:	50                   	push   %eax
  103cab:	6a 21                	push   $0x21
  103cad:	e8 6e 19 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, mask >> 8);
  103cb2:	58                   	pop    %eax
  103cb3:	89 f0                	mov    %esi,%eax
  103cb5:	5a                   	pop    %edx
  103cb6:	0f b6 f4             	movzbl %ah,%esi
  103cb9:	56                   	push   %esi
  103cba:	68 a1 00 00 00       	push   $0xa1
  103cbf:	e8 5c 19 00 00       	call   105620 <outb>
}
  103cc4:	83 c4 14             	add    $0x14,%esp
  103cc7:	5b                   	pop    %ebx
  103cc8:	5e                   	pop    %esi
  103cc9:	c3                   	ret
  103cca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00103cd0 <picinit>:

// Initialize the 8259A interrupt controllers.
void picinit(void)
{
  103cd0:	56                   	push   %esi
  103cd1:	53                   	push   %ebx
  103cd2:	e8 cb c6 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  103cd7:	81 c3 1d 33 01 00    	add    $0x1331d,%ebx
  103cdd:	83 ec 0c             	sub    $0xc,%esp
    // mask all interrupts
    outb(IO_PIC1 + 1, 0xFF);
  103ce0:	68 ff 00 00 00       	push   $0xff
  103ce5:	6a 21                	push   $0x21
  103ce7:	e8 34 19 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, 0xFF);
  103cec:	59                   	pop    %ecx
  103ced:	5e                   	pop    %esi
  103cee:	68 ff 00 00 00       	push   $0xff
  103cf3:	68 a1 00 00 00       	push   $0xa1
  103cf8:	e8 23 19 00 00       	call   105620 <outb>

    // ICW1: 0001g0hi
    //    g: 0 = edge triggering, 1 = level triggering
    //    h: 0 = cascaded PICs, 1 = master only
    //    i: 0 = no ICW4, 1 = ICW4 required
    outb(IO_PIC1, 0x11);
  103cfd:	58                   	pop    %eax
  103cfe:	5a                   	pop    %edx
  103cff:	6a 11                	push   $0x11
  103d01:	6a 20                	push   $0x20
  103d03:	e8 18 19 00 00       	call   105620 <outb>

    // ICW2: Vector offset
    outb(IO_PIC1 + 1, T_IRQ0);
  103d08:	59                   	pop    %ecx
  103d09:	5e                   	pop    %esi
  103d0a:	6a 20                	push   $0x20
  103d0c:	6a 21                	push   $0x21
  103d0e:	e8 0d 19 00 00       	call   105620 <outb>

    // ICW3: (master PIC) bit mask of IR lines connected to slaves
    //       (slave PIC) 3-bit # of slave's connection to master
    outb(IO_PIC1 + 1, 1 << IRQ_SLAVE);
  103d13:	58                   	pop    %eax
  103d14:	5a                   	pop    %edx
  103d15:	6a 04                	push   $0x4
  103d17:	6a 21                	push   $0x21
  103d19:	e8 02 19 00 00       	call   105620 <outb>
    //    m: 0 = slave PIC, 1 = master PIC
    //       (ignored when b is 0, as the master/slave role
    //       can be hardwired).
    //    a: 1 = Automatic EOI mode
    //    p: 0 = MCS-80/85 mode, 1 = intel x86 mode
    outb(IO_PIC1 + 1, 0x3);
  103d1e:	59                   	pop    %ecx
  103d1f:	5e                   	pop    %esi
  103d20:	6a 03                	push   $0x3
  103d22:	6a 21                	push   $0x21
  103d24:	e8 f7 18 00 00       	call   105620 <outb>

    // Set up slave (8259A-2)
    outb(IO_PIC2, 0x11);            // ICW1
  103d29:	58                   	pop    %eax
  103d2a:	5a                   	pop    %edx
  103d2b:	6a 11                	push   $0x11
  103d2d:	68 a0 00 00 00       	push   $0xa0
  103d32:	e8 e9 18 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, T_IRQ0 + 8);  // ICW2
  103d37:	59                   	pop    %ecx
  103d38:	5e                   	pop    %esi
  103d39:	6a 28                	push   $0x28
  103d3b:	68 a1 00 00 00       	push   $0xa1
  103d40:	e8 db 18 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, IRQ_SLAVE);   // ICW3
  103d45:	58                   	pop    %eax
  103d46:	5a                   	pop    %edx
  103d47:	6a 02                	push   $0x2
  103d49:	68 a1 00 00 00       	push   $0xa1
  103d4e:	e8 cd 18 00 00       	call   105620 <outb>
    // NB Automatic EOI mode doesn't tend to work on the slave.
    // Linux source code says it's "to be investigated".
    outb(IO_PIC2 + 1, 0x3);         // ICW4
  103d53:	59                   	pop    %ecx
  103d54:	5e                   	pop    %esi
  103d55:	6a 03                	push   $0x3
  103d57:	68 a1 00 00 00       	push   $0xa1
  103d5c:	e8 bf 18 00 00       	call   105620 <outb>

    // OCW3: 0ef01prs
    //   ef: 0x = NOP, 10 = clear specific mask, 11 = set specific mask
    //    p: 0 = no polling, 1 = polling mode
    //   rs: 0x = NOP, 10 = read IRR, 11 = read ISR
    outb(IO_PIC1, 0x68);  // clear specific mask
  103d61:	58                   	pop    %eax
  103d62:	5a                   	pop    %edx
  103d63:	6a 68                	push   $0x68
  103d65:	6a 20                	push   $0x20
  103d67:	e8 b4 18 00 00       	call   105620 <outb>
    outb(IO_PIC1, 0x0a);  // read IRR by default
  103d6c:	59                   	pop    %ecx
  103d6d:	5e                   	pop    %esi
  103d6e:	6a 0a                	push   $0xa
  103d70:	6a 20                	push   $0x20
  103d72:	e8 a9 18 00 00       	call   105620 <outb>

    outb(IO_PIC2, 0x68);  // OCW3
  103d77:	58                   	pop    %eax
  103d78:	5a                   	pop    %edx
  103d79:	6a 68                	push   $0x68
  103d7b:	68 a0 00 00 00       	push   $0xa0
  103d80:	e8 9b 18 00 00       	call   105620 <outb>
    outb(IO_PIC2, 0x0a);  // OCW3
  103d85:	59                   	pop    %ecx
  103d86:	5e                   	pop    %esi
  103d87:	6a 0a                	push   $0xa
  103d89:	68 a0 00 00 00       	push   $0xa0
  103d8e:	e8 8d 18 00 00       	call   105620 <outb>

    if (irqmask != 0xFFFF)
  103d93:	0f b7 b3 14 03 00 00 	movzwl 0x314(%ebx),%esi
  103d9a:	83 c4 10             	add    $0x10,%esp
  103d9d:	66 83 fe ff          	cmp    $0xffff,%si
  103da1:	74 25                	je     103dc8 <picinit+0xf8>
    outb(IO_PIC1 + 1, mask);
  103da3:	89 f0                	mov    %esi,%eax
  103da5:	83 ec 08             	sub    $0x8,%esp
  103da8:	0f b6 c0             	movzbl %al,%eax
  103dab:	50                   	push   %eax
  103dac:	6a 21                	push   $0x21
  103dae:	e8 6d 18 00 00       	call   105620 <outb>
    outb(IO_PIC2 + 1, mask >> 8);
  103db3:	58                   	pop    %eax
  103db4:	89 f0                	mov    %esi,%eax
  103db6:	5a                   	pop    %edx
  103db7:	0f b6 f4             	movzbl %ah,%esi
  103dba:	56                   	push   %esi
  103dbb:	68 a1 00 00 00       	push   $0xa1
  103dc0:	e8 5b 18 00 00       	call   105620 <outb>
}
  103dc5:	83 c4 10             	add    $0x10,%esp
        picsetmask(irqmask);
}
  103dc8:	83 c4 04             	add    $0x4,%esp
  103dcb:	5b                   	pop    %ebx
  103dcc:	5e                   	pop    %esi
  103dcd:	c3                   	ret
  103dce:	66 90                	xchg   %ax,%ax

00103dd0 <ide_start>:

/**
 * Start the request for b.  Caller must hold ide_lk.
 */
static void ide_start(struct buf *b)
{
  103dd0:	56                   	push   %esi
  103dd1:	89 c6                	mov    %eax,%esi
  103dd3:	53                   	push   %ebx
  103dd4:	e8 c9 c5 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  103dd9:	81 c3 1b 32 01 00    	add    $0x1321b,%ebx
  103ddf:	83 ec 04             	sub    $0x4,%esp
    if (b == 0)
  103de2:	85 c0                	test   %eax,%eax
  103de4:	0f 84 e6 00 00 00    	je     103ed0 <ide_start+0x100>
  103dea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    while (((r = inb(0x1f7)) & (IDE_BSY | IDE_DRDY)) != IDE_DRDY);
  103df0:	83 ec 0c             	sub    $0xc,%esp
  103df3:	68 f7 01 00 00       	push   $0x1f7
  103df8:	e8 f3 17 00 00       	call   1055f0 <inb>
  103dfd:	83 c4 10             	add    $0x10,%esp
  103e00:	83 e0 c0             	and    $0xffffffc0,%eax
  103e03:	3c 40                	cmp    $0x40,%al
  103e05:	75 e9                	jne    103df0 <ide_start+0x20>
        KERN_PANIC("ide_start");

    ide_wait(0);
    outb(0x3f6, 0);  // generate interrupt
  103e07:	83 ec 08             	sub    $0x8,%esp
  103e0a:	6a 00                	push   $0x0
  103e0c:	68 f6 03 00 00       	push   $0x3f6
  103e11:	e8 0a 18 00 00       	call   105620 <outb>
    outb(0x1f2, 1);  // number of sectors
  103e16:	58                   	pop    %eax
  103e17:	5a                   	pop    %edx
  103e18:	6a 01                	push   $0x1
  103e1a:	68 f2 01 00 00       	push   $0x1f2
  103e1f:	e8 fc 17 00 00       	call   105620 <outb>
    outb(0x1f3, b->sector & 0xff);
  103e24:	59                   	pop    %ecx
  103e25:	58                   	pop    %eax
  103e26:	0f b6 46 08          	movzbl 0x8(%esi),%eax
  103e2a:	50                   	push   %eax
  103e2b:	68 f3 01 00 00       	push   $0x1f3
  103e30:	e8 eb 17 00 00       	call   105620 <outb>
    outb(0x1f4, (b->sector >> 8) & 0xff);
  103e35:	58                   	pop    %eax
  103e36:	0f b6 46 09          	movzbl 0x9(%esi),%eax
  103e3a:	5a                   	pop    %edx
  103e3b:	50                   	push   %eax
  103e3c:	68 f4 01 00 00       	push   $0x1f4
  103e41:	e8 da 17 00 00       	call   105620 <outb>
    outb(0x1f5, (b->sector >> 16) & 0xff);
  103e46:	59                   	pop    %ecx
  103e47:	58                   	pop    %eax
  103e48:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  103e4c:	50                   	push   %eax
  103e4d:	68 f5 01 00 00       	push   $0x1f5
  103e52:	e8 c9 17 00 00       	call   105620 <outb>
    outb(0x1f6, 0xe0 | ((b->dev & 1) << 4) | ((b->sector >> 24) & 0x0f));
  103e57:	58                   	pop    %eax
  103e58:	0f b6 46 04          	movzbl 0x4(%esi),%eax
  103e5c:	5a                   	pop    %edx
  103e5d:	0f b6 56 0b          	movzbl 0xb(%esi),%edx
  103e61:	c1 e0 04             	shl    $0x4,%eax
  103e64:	83 e2 0f             	and    $0xf,%edx
  103e67:	83 e0 10             	and    $0x10,%eax
  103e6a:	09 d0                	or     %edx,%eax
  103e6c:	83 c8 e0             	or     $0xffffffe0,%eax
  103e6f:	0f b6 c0             	movzbl %al,%eax
  103e72:	50                   	push   %eax
  103e73:	68 f6 01 00 00       	push   $0x1f6
  103e78:	e8 a3 17 00 00       	call   105620 <outb>
    if (b->flags & B_DIRTY) {
  103e7d:	83 c4 10             	add    $0x10,%esp
  103e80:	f6 06 04             	testb  $0x4,(%esi)
  103e83:	74 33                	je     103eb8 <ide_start+0xe8>
        outb(0x1f7, IDE_CMD_WRITE);
  103e85:	83 ec 08             	sub    $0x8,%esp
        outsl(0x1f0, b->data, 512 / 4);
  103e88:	83 c6 18             	add    $0x18,%esi
        outb(0x1f7, IDE_CMD_WRITE);
  103e8b:	6a 30                	push   $0x30
  103e8d:	68 f7 01 00 00       	push   $0x1f7
  103e92:	e8 89 17 00 00       	call   105620 <outb>
        outsl(0x1f0, b->data, 512 / 4);
  103e97:	83 c4 0c             	add    $0xc,%esp
  103e9a:	68 80 00 00 00       	push   $0x80
  103e9f:	56                   	push   %esi
  103ea0:	68 f0 01 00 00       	push   $0x1f0
  103ea5:	e8 a6 17 00 00       	call   105650 <outsl>
  103eaa:	83 c4 10             	add    $0x10,%esp
    } else {
        outb(0x1f7, IDE_CMD_READ);
    }
}
  103ead:	83 c4 04             	add    $0x4,%esp
  103eb0:	5b                   	pop    %ebx
  103eb1:	5e                   	pop    %esi
  103eb2:	c3                   	ret
  103eb3:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        outb(0x1f7, IDE_CMD_READ);
  103eb8:	83 ec 08             	sub    $0x8,%esp
  103ebb:	6a 20                	push   $0x20
  103ebd:	68 f7 01 00 00       	push   $0x1f7
  103ec2:	e8 59 17 00 00       	call   105620 <outb>
  103ec7:	83 c4 10             	add    $0x10,%esp
}
  103eca:	83 c4 04             	add    $0x4,%esp
  103ecd:	5b                   	pop    %ebx
  103ece:	5e                   	pop    %esi
  103ecf:	c3                   	ret
        KERN_PANIC("ide_start");
  103ed0:	83 ec 04             	sub    $0x4,%esp
  103ed3:	8d 83 8e 63 ff ff    	lea    -0x9c72(%ebx),%eax
  103ed9:	50                   	push   %eax
  103eda:	8d 83 98 63 ff ff    	lea    -0x9c68(%ebx),%eax
  103ee0:	6a 3e                	push   $0x3e
  103ee2:	50                   	push   %eax
  103ee3:	e8 08 09 00 00       	call   1047f0 <debug_panic>
  103ee8:	83 c4 10             	add    $0x10,%esp
  103eeb:	e9 00 ff ff ff       	jmp    103df0 <ide_start+0x20>

00103ef0 <ide_init>:
{
  103ef0:	56                   	push   %esi
  103ef1:	53                   	push   %ebx
  103ef2:	e8 ab c4 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  103ef7:	81 c3 fd 30 01 00    	add    $0x130fd,%ebx
  103efd:	83 ec 10             	sub    $0x10,%esp
    spinlock_init(&ide_lk);
  103f00:	8d 83 80 a9 08 00    	lea    0x8a980(%ebx),%eax
  103f06:	50                   	push   %eax
  103f07:	e8 b4 1f 00 00       	call   105ec0 <spinlock_init>
    picenable(IRQ_IDE1);
  103f0c:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  103f13:	e8 68 fd ff ff       	call   103c80 <picenable>
    ioapicenable(IRQ_IDE1, pcpu_ncpu() - 1);
  103f18:	e8 b3 fb ff ff       	call   103ad0 <pcpu_ncpu>
  103f1d:	5a                   	pop    %edx
  103f1e:	59                   	pop    %ecx
  103f1f:	83 e8 01             	sub    $0x1,%eax
  103f22:	50                   	push   %eax
  103f23:	6a 0e                	push   $0xe
  103f25:	e8 16 fd ff ff       	call   103c40 <ioapicenable>
    while (((r = inb(0x1f7)) & (IDE_BSY | IDE_DRDY)) != IDE_DRDY);
  103f2a:	83 c4 10             	add    $0x10,%esp
  103f2d:	8d 76 00             	lea    0x0(%esi),%esi
  103f30:	83 ec 0c             	sub    $0xc,%esp
  103f33:	68 f7 01 00 00       	push   $0x1f7
  103f38:	e8 b3 16 00 00       	call   1055f0 <inb>
  103f3d:	83 c4 10             	add    $0x10,%esp
  103f40:	83 e0 c0             	and    $0xffffffc0,%eax
  103f43:	3c 40                	cmp    $0x40,%al
  103f45:	75 e9                	jne    103f30 <ide_init+0x40>
    outb(0x1f6, 0xe0 | (1 << 4));
  103f47:	83 ec 08             	sub    $0x8,%esp
  103f4a:	be e8 03 00 00       	mov    $0x3e8,%esi
  103f4f:	68 f0 00 00 00       	push   $0xf0
  103f54:	68 f6 01 00 00       	push   $0x1f6
  103f59:	e8 c2 16 00 00       	call   105620 <outb>
  103f5e:	83 c4 10             	add    $0x10,%esp
  103f61:	eb 0a                	jmp    103f6d <ide_init+0x7d>
  103f63:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    for (i = 0; i < 1000; i++) {
  103f68:	83 ee 01             	sub    $0x1,%esi
  103f6b:	74 1e                	je     103f8b <ide_init+0x9b>
        if (inb(0x1f7) != 0) {
  103f6d:	83 ec 0c             	sub    $0xc,%esp
  103f70:	68 f7 01 00 00       	push   $0x1f7
  103f75:	e8 76 16 00 00       	call   1055f0 <inb>
  103f7a:	83 c4 10             	add    $0x10,%esp
  103f7d:	84 c0                	test   %al,%al
  103f7f:	74 e7                	je     103f68 <ide_init+0x78>
            havedisk1 = 1;
  103f81:	c7 83 78 a9 08 00 01 	movl   $0x1,0x8a978(%ebx)
  103f88:	00 00 00 
    outb(0x1f6, 0xe0 | (0 << 4));
  103f8b:	83 ec 08             	sub    $0x8,%esp
  103f8e:	68 e0 00 00 00       	push   $0xe0
  103f93:	68 f6 01 00 00       	push   $0x1f6
  103f98:	e8 83 16 00 00       	call   105620 <outb>
}
  103f9d:	83 c4 14             	add    $0x14,%esp
  103fa0:	5b                   	pop    %ebx
  103fa1:	5e                   	pop    %esi
  103fa2:	c3                   	ret
  103fa3:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  103faa:	00 
  103fab:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00103fb0 <ide_intr>:

/**
 * Interrupt handler.
 */
void ide_intr(void)
{
  103fb0:	57                   	push   %edi
  103fb1:	56                   	push   %esi
  103fb2:	53                   	push   %ebx
  103fb3:	e8 ea c3 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  103fb8:	81 c3 3c 30 01 00    	add    $0x1303c,%ebx
    struct buf *b;

    // First queued buffer is the active request.
    spinlock_acquire(&ide_lk);
  103fbe:	83 ec 0c             	sub    $0xc,%esp
  103fc1:	8d b3 80 a9 08 00    	lea    0x8a980(%ebx),%esi
  103fc7:	56                   	push   %esi
  103fc8:	e8 83 1f 00 00       	call   105f50 <spinlock_acquire>
    if ((b = idequeue) == 0) {
  103fcd:	8b bb 7c a9 08 00    	mov    0x8a97c(%ebx),%edi
  103fd3:	83 c4 10             	add    $0x10,%esp
  103fd6:	85 ff                	test   %edi,%edi
  103fd8:	0f 84 82 00 00 00    	je     104060 <ide_intr+0xb0>
        spinlock_release(&ide_lk);
        KERN_INFO("spurious IDE interrupt\n");
        return;
    }
    idequeue = b->qnext;
  103fde:	8b 47 14             	mov    0x14(%edi),%eax
  103fe1:	89 83 7c a9 08 00    	mov    %eax,0x8a97c(%ebx)

    // Read data if needed.
    if (!(b->flags & B_DIRTY) && ide_wait(1) >= 0)
  103fe7:	8b 07                	mov    (%edi),%eax
  103fe9:	a8 04                	test   $0x4,%al
  103feb:	74 33                	je     104020 <ide_intr+0x70>
        insl(0x1f0, b->data, 512 / 4);

    // Wake process waiting for this buf.
    b->flags |= B_VALID;
    b->flags &= ~B_DIRTY;
  103fed:	83 e0 fb             	and    $0xfffffffb,%eax
    thread_wakeup(b);
  103ff0:	83 ec 0c             	sub    $0xc,%esp
    b->flags &= ~B_DIRTY;
  103ff3:	83 c8 02             	or     $0x2,%eax
  103ff6:	89 07                	mov    %eax,(%edi)
    thread_wakeup(b);
  103ff8:	57                   	push   %edi
  103ff9:	e8 a2 3d 00 00       	call   107da0 <thread_wakeup>

    // Start disk on next buf in queue.
    if (idequeue != 0)
  103ffe:	8b 83 7c a9 08 00    	mov    0x8a97c(%ebx),%eax
  104004:	83 c4 10             	add    $0x10,%esp
  104007:	85 c0                	test   %eax,%eax
  104009:	74 05                	je     104010 <ide_intr+0x60>
        ide_start(idequeue);
  10400b:	e8 c0 fd ff ff       	call   103dd0 <ide_start>

    spinlock_release(&ide_lk);
  104010:	83 ec 0c             	sub    $0xc,%esp
  104013:	56                   	push   %esi
  104014:	e8 b7 1f 00 00       	call   105fd0 <spinlock_release>
  104019:	83 c4 10             	add    $0x10,%esp
}
  10401c:	5b                   	pop    %ebx
  10401d:	5e                   	pop    %esi
  10401e:	5f                   	pop    %edi
  10401f:	c3                   	ret
    while (((r = inb(0x1f7)) & (IDE_BSY | IDE_DRDY)) != IDE_DRDY);
  104020:	83 ec 0c             	sub    $0xc,%esp
  104023:	68 f7 01 00 00       	push   $0x1f7
  104028:	e8 c3 15 00 00       	call   1055f0 <inb>
  10402d:	83 c4 10             	add    $0x10,%esp
  104030:	89 c2                	mov    %eax,%edx
  104032:	83 e2 c0             	and    $0xffffffc0,%edx
  104035:	80 fa 40             	cmp    $0x40,%dl
  104038:	75 e6                	jne    104020 <ide_intr+0x70>
    if (checkerr && (r & (IDE_DF | IDE_ERR)) != 0)
  10403a:	a8 21                	test   $0x21,%al
  10403c:	75 3e                	jne    10407c <ide_intr+0xcc>
        insl(0x1f0, b->data, 512 / 4);
  10403e:	83 ec 04             	sub    $0x4,%esp
  104041:	8d 47 18             	lea    0x18(%edi),%eax
  104044:	68 80 00 00 00       	push   $0x80
  104049:	50                   	push   %eax
  10404a:	68 f0 01 00 00       	push   $0x1f0
  10404f:	e8 ac 15 00 00       	call   105600 <insl>
    b->flags |= B_VALID;
  104054:	8b 07                	mov    (%edi),%eax
  104056:	83 c4 10             	add    $0x10,%esp
  104059:	eb 92                	jmp    103fed <ide_intr+0x3d>
  10405b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        spinlock_release(&ide_lk);
  104060:	83 ec 0c             	sub    $0xc,%esp
  104063:	56                   	push   %esi
  104064:	e8 67 1f 00 00       	call   105fd0 <spinlock_release>
        KERN_INFO("spurious IDE interrupt\n");
  104069:	8d 83 ac 63 ff ff    	lea    -0x9c54(%ebx),%eax
  10406f:	89 04 24             	mov    %eax,(%esp)
  104072:	e8 d9 06 00 00       	call   104750 <debug_info>
        return;
  104077:	83 c4 10             	add    $0x10,%esp
  10407a:	eb a0                	jmp    10401c <ide_intr+0x6c>
    b->flags |= B_VALID;
  10407c:	8b 07                	mov    (%edi),%eax
  10407e:	e9 6a ff ff ff       	jmp    103fed <ide_intr+0x3d>
  104083:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10408a:	00 
  10408b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00104090 <ide_rw>:
 * Sync buf with disk.
 * If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
 * Else if B_VALID is not set, read buf from disk, set B_VALID.
 */
void ide_rw(struct buf *b)
{
  104090:	57                   	push   %edi
  104091:	56                   	push   %esi
  104092:	53                   	push   %ebx
  104093:	8b 7c 24 10          	mov    0x10(%esp),%edi
  104097:	e8 06 c3 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10409c:	81 c3 58 2f 01 00    	add    $0x12f58,%ebx
    struct buf **pp;

    if (!(b->flags & B_BUSY))
  1040a2:	8b 07                	mov    (%edi),%eax
  1040a4:	a8 01                	test   $0x1,%al
  1040a6:	0f 84 a4 00 00 00    	je     104150 <ide_rw+0xc0>
        KERN_PANIC("ide_rw: buf not busy");
    if ((b->flags & (B_VALID | B_DIRTY)) == B_VALID)
  1040ac:	83 e0 06             	and    $0x6,%eax
  1040af:	83 f8 02             	cmp    $0x2,%eax
  1040b2:	0f 84 c1 00 00 00    	je     104179 <ide_rw+0xe9>
        KERN_PANIC("ide_rw: nothing to do");
    if (b->dev != 0 && !havedisk1)
  1040b8:	8b 57 04             	mov    0x4(%edi),%edx
  1040bb:	85 d2                	test   %edx,%edx
  1040bd:	74 0e                	je     1040cd <ide_rw+0x3d>
  1040bf:	8b 83 78 a9 08 00    	mov    0x8a978(%ebx),%eax
  1040c5:	85 c0                	test   %eax,%eax
  1040c7:	0f 84 d3 00 00 00    	je     1041a0 <ide_rw+0x110>
        KERN_PANIC("ide_rw: ide disk 1 not present");

    spinlock_acquire(&ide_lk);
  1040cd:	83 ec 0c             	sub    $0xc,%esp
  1040d0:	8d b3 80 a9 08 00    	lea    0x8a980(%ebx),%esi
  1040d6:	56                   	push   %esi
  1040d7:	e8 74 1e 00 00       	call   105f50 <spinlock_acquire>

    // Append b to idequeue.
    b->qnext = 0;
    for (pp = &idequeue; *pp; pp = &(*pp)->qnext)
  1040dc:	8b 83 7c a9 08 00    	mov    0x8a97c(%ebx),%eax
    b->qnext = 0;
  1040e2:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
    for (pp = &idequeue; *pp; pp = &(*pp)->qnext)
  1040e9:	83 c4 10             	add    $0x10,%esp
  1040ec:	85 c0                	test   %eax,%eax
  1040ee:	0f 84 dc 00 00 00    	je     1041d0 <ide_rw+0x140>
  1040f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  1040f8:	89 c2                	mov    %eax,%edx
  1040fa:	8b 40 14             	mov    0x14(%eax),%eax
  1040fd:	85 c0                	test   %eax,%eax
  1040ff:	75 f7                	jne    1040f8 <ide_rw+0x68>
  104101:	83 c2 14             	add    $0x14,%edx
        ;
    *pp = b;
  104104:	89 3a                	mov    %edi,(%edx)

    // Start disk if necessary.
    if (idequeue == b)
  104106:	39 bb 7c a9 08 00    	cmp    %edi,0x8a97c(%ebx)
  10410c:	0f 84 ae 00 00 00    	je     1041c0 <ide_rw+0x130>
        ide_start(b);

    // Wait for request to finish.
    while ((b->flags & (B_VALID | B_DIRTY)) != B_VALID) {
  104112:	8b 07                	mov    (%edi),%eax
  104114:	83 e0 06             	and    $0x6,%eax
  104117:	83 f8 02             	cmp    $0x2,%eax
  10411a:	74 1b                	je     104137 <ide_rw+0xa7>
  10411c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        thread_sleep(b, &ide_lk);
  104120:	83 ec 08             	sub    $0x8,%esp
  104123:	56                   	push   %esi
  104124:	57                   	push   %edi
  104125:	e8 66 3b 00 00       	call   107c90 <thread_sleep>
    while ((b->flags & (B_VALID | B_DIRTY)) != B_VALID) {
  10412a:	8b 07                	mov    (%edi),%eax
  10412c:	83 c4 10             	add    $0x10,%esp
  10412f:	83 e0 06             	and    $0x6,%eax
  104132:	83 f8 02             	cmp    $0x2,%eax
  104135:	75 e9                	jne    104120 <ide_rw+0x90>
    }

    spinlock_release(&ide_lk);
  104137:	83 ec 0c             	sub    $0xc,%esp
  10413a:	56                   	push   %esi
  10413b:	e8 90 1e 00 00       	call   105fd0 <spinlock_release>
}
  104140:	83 c4 10             	add    $0x10,%esp
  104143:	5b                   	pop    %ebx
  104144:	5e                   	pop    %esi
  104145:	5f                   	pop    %edi
  104146:	c3                   	ret
  104147:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10414e:	00 
  10414f:	90                   	nop
        KERN_PANIC("ide_rw: buf not busy");
  104150:	83 ec 04             	sub    $0x4,%esp
  104153:	8d 83 c4 63 ff ff    	lea    -0x9c3c(%ebx),%eax
  104159:	50                   	push   %eax
  10415a:	8d 83 98 63 ff ff    	lea    -0x9c68(%ebx),%eax
  104160:	6a 79                	push   $0x79
  104162:	50                   	push   %eax
  104163:	e8 88 06 00 00       	call   1047f0 <debug_panic>
    if ((b->flags & (B_VALID | B_DIRTY)) == B_VALID)
  104168:	8b 07                	mov    (%edi),%eax
  10416a:	83 c4 10             	add    $0x10,%esp
  10416d:	83 e0 06             	and    $0x6,%eax
  104170:	83 f8 02             	cmp    $0x2,%eax
  104173:	0f 85 3f ff ff ff    	jne    1040b8 <ide_rw+0x28>
        KERN_PANIC("ide_rw: nothing to do");
  104179:	83 ec 04             	sub    $0x4,%esp
  10417c:	8d 83 d9 63 ff ff    	lea    -0x9c27(%ebx),%eax
  104182:	50                   	push   %eax
  104183:	8d 83 98 63 ff ff    	lea    -0x9c68(%ebx),%eax
  104189:	6a 7b                	push   $0x7b
  10418b:	50                   	push   %eax
  10418c:	e8 5f 06 00 00       	call   1047f0 <debug_panic>
  104191:	83 c4 10             	add    $0x10,%esp
  104194:	e9 1f ff ff ff       	jmp    1040b8 <ide_rw+0x28>
  104199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        KERN_PANIC("ide_rw: ide disk 1 not present");
  1041a0:	83 ec 04             	sub    $0x4,%esp
  1041a3:	8d 83 b4 70 ff ff    	lea    -0x8f4c(%ebx),%eax
  1041a9:	50                   	push   %eax
  1041aa:	8d 83 98 63 ff ff    	lea    -0x9c68(%ebx),%eax
  1041b0:	6a 7d                	push   $0x7d
  1041b2:	50                   	push   %eax
  1041b3:	e8 38 06 00 00       	call   1047f0 <debug_panic>
  1041b8:	83 c4 10             	add    $0x10,%esp
  1041bb:	e9 0d ff ff ff       	jmp    1040cd <ide_rw+0x3d>
        ide_start(b);
  1041c0:	89 f8                	mov    %edi,%eax
  1041c2:	e8 09 fc ff ff       	call   103dd0 <ide_start>
  1041c7:	e9 46 ff ff ff       	jmp    104112 <ide_rw+0x82>
  1041cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    for (pp = &idequeue; *pp; pp = &(*pp)->qnext)
  1041d0:	8d 93 7c a9 08 00    	lea    0x8a97c(%ebx),%edx
  1041d6:	e9 29 ff ff ff       	jmp    104104 <ide_rw+0x74>
  1041db:	66 90                	xchg   %ax,%ax
  1041dd:	66 90                	xchg   %ax,%ax
  1041df:	90                   	nop

001041e0 <detect_kvm>:
}

#define CPUID_FEATURE_HYPERVISOR	(1<<31) /* Running on a hypervisor */

int detect_kvm(void)
{
  1041e0:	57                   	push   %edi
	__asm __volatile("cpuid"
  1041e1:	b8 01 00 00 00       	mov    $0x1,%eax
  1041e6:	31 c9                	xor    %ecx,%ecx
{
  1041e8:	56                   	push   %esi
  1041e9:	e8 c7 f9 ff ff       	call   103bb5 <__x86.get_pc_thunk.si>
  1041ee:	81 c6 06 2e 01 00    	add    $0x12e06,%esi
  1041f4:	53                   	push   %ebx
  1041f5:	83 ec 10             	sub    $0x10,%esp
	__asm __volatile("cpuid"
  1041f8:	0f a2                	cpuid
	uint32_t eax;

	if (cpu_has (CPUID_FEATURE_HYPERVISOR))
  1041fa:	83 e2 01             	and    $0x1,%edx
  1041fd:	75 11                	jne    104210 <detect_kvm+0x30>
		{
			return 1;
		}
	}
	return 0;
}
  1041ff:	83 c4 10             	add    $0x10,%esp
	return 0;
  104202:	31 c0                	xor    %eax,%eax
}
  104204:	5b                   	pop    %ebx
  104205:	5e                   	pop    %esi
  104206:	5f                   	pop    %edi
  104207:	c3                   	ret
  104208:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10420f:	00 
		cpuid (CPUID_KVM_SIGNATURE, &eax, &hyper_vendor_id[0],
  104210:	83 ec 0c             	sub    $0xc,%esp
  104213:	89 f3                	mov    %esi,%ebx
  104215:	8d 44 24 18          	lea    0x18(%esp),%eax
  104219:	8d 7c 24 10          	lea    0x10(%esp),%edi
  10421d:	50                   	push   %eax
  10421e:	8d 44 24 18          	lea    0x18(%esp),%eax
  104222:	50                   	push   %eax
  104223:	57                   	push   %edi
  104224:	8d 44 24 18          	lea    0x18(%esp),%eax
  104228:	50                   	push   %eax
  104229:	68 00 00 00 40       	push   $0x40000000
  10422e:	e8 8d 12 00 00       	call   1054c0 <cpuid>
		if (!strncmp ("KVMKVMKVM", (const char *) hyper_vendor_id, 9))
  104233:	83 c4 1c             	add    $0x1c,%esp
  104236:	8d 86 ef 63 ff ff    	lea    -0x9c11(%esi),%eax
  10423c:	6a 09                	push   $0x9
  10423e:	57                   	push   %edi
  10423f:	50                   	push   %eax
  104240:	e8 ab 02 00 00       	call   1044f0 <strncmp>
  104245:	83 c4 10             	add    $0x10,%esp
  104248:	85 c0                	test   %eax,%eax
  10424a:	75 b3                	jne    1041ff <detect_kvm+0x1f>
}
  10424c:	83 c4 10             	add    $0x10,%esp
			return 1;
  10424f:	b8 01 00 00 00       	mov    $0x1,%eax
}
  104254:	5b                   	pop    %ebx
  104255:	5e                   	pop    %esi
  104256:	5f                   	pop    %edi
  104257:	c3                   	ret
  104258:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10425f:	00 

00104260 <kvm_has_feature>:

int
kvm_has_feature(uint32_t feature)
{
  104260:	53                   	push   %ebx
  104261:	e8 3c c1 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  104266:	81 c3 8e 2d 01 00    	add    $0x12d8e,%ebx
  10426c:	83 ec 24             	sub    $0x24,%esp
	uint32_t eax, ebx, ecx, edx;
	eax = 0; edx = 0;
	cpuid(CPUID_KVM_FEATURES, &eax, &ebx, &ecx, &edx);
  10426f:	8d 44 24 18          	lea    0x18(%esp),%eax
	eax = 0; edx = 0;
  104273:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10427a:	00 
  10427b:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  104282:	00 
	cpuid(CPUID_KVM_FEATURES, &eax, &ebx, &ecx, &edx);
  104283:	50                   	push   %eax
  104284:	8d 44 24 18          	lea    0x18(%esp),%eax
  104288:	50                   	push   %eax
  104289:	8d 44 24 18          	lea    0x18(%esp),%eax
  10428d:	50                   	push   %eax
  10428e:	8d 44 24 18          	lea    0x18(%esp),%eax
  104292:	50                   	push   %eax
  104293:	68 01 00 00 40       	push   $0x40000001
  104298:	e8 23 12 00 00       	call   1054c0 <cpuid>

	return ((eax & feature) != 0 ? 1 : 0);
  10429d:	8b 44 24 40          	mov    0x40(%esp),%eax
  1042a1:	23 44 24 20          	and    0x20(%esp),%eax
  1042a5:	85 c0                	test   %eax,%eax
  1042a7:	0f 95 c0             	setne  %al
}
  1042aa:	83 c4 38             	add    $0x38,%esp
	return ((eax & feature) != 0 ? 1 : 0);
  1042ad:	0f b6 c0             	movzbl %al,%eax
}
  1042b0:	5b                   	pop    %ebx
  1042b1:	c3                   	ret
  1042b2:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1042b9:	00 
  1042ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001042c0 <kvm_enable_feature>:

int
kvm_enable_feature(uint32_t feature)
{
  1042c0:	53                   	push   %ebx
	uint32_t eax, ebx, ecx, edx;
	eax = 1 << feature; edx = 0;
  1042c1:	b8 01 00 00 00       	mov    $0x1,%eax
  1042c6:	e8 d7 c0 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1042cb:	81 c3 29 2d 01 00    	add    $0x12d29,%ebx
{
  1042d1:	83 ec 24             	sub    $0x24,%esp
	eax = 1 << feature; edx = 0;
  1042d4:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  1042d8:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  1042df:	00 
  1042e0:	d3 e0                	shl    %cl,%eax
  1042e2:	89 44 24 0c          	mov    %eax,0xc(%esp)
	cpuid(CPUID_KVM_FEATURES, &eax, &ebx, &ecx, &edx);
  1042e6:	8d 44 24 18          	lea    0x18(%esp),%eax
  1042ea:	50                   	push   %eax
  1042eb:	8d 44 24 18          	lea    0x18(%esp),%eax
  1042ef:	50                   	push   %eax
  1042f0:	8d 44 24 18          	lea    0x18(%esp),%eax
  1042f4:	50                   	push   %eax
  1042f5:	8d 44 24 18          	lea    0x18(%esp),%eax
  1042f9:	50                   	push   %eax
  1042fa:	68 01 00 00 40       	push   $0x40000001
  1042ff:	e8 bc 11 00 00       	call   1054c0 <cpuid>

	return (ebx == 0 ? 1 : 0);
  104304:	8b 54 24 24          	mov    0x24(%esp),%edx
  104308:	31 c0                	xor    %eax,%eax
  10430a:	85 d2                	test   %edx,%edx
  10430c:	0f 94 c0             	sete   %al
}
  10430f:	83 c4 38             	add    $0x38,%esp
  104312:	5b                   	pop    %ebx
  104313:	c3                   	ret
  104314:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10431b:	00 
  10431c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00104320 <kvm_get_tsc_hz>:

uint64_t
kvm_get_tsc_hz(void)
{
  104320:	55                   	push   %ebp
  104321:	57                   	push   %edi
  104322:	56                   	push   %esi
  104323:	53                   	push   %ebx
  104324:	e8 79 c0 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  104329:	81 c3 cb 2c 01 00    	add    $0x12ccb,%ebx
  10432f:	83 ec 38             	sub    $0x38,%esp
	cpuid(CPUID_KVM_FEATURES, &eax, &ebx, &ecx, &edx);
  104332:	8d 44 24 28          	lea    0x28(%esp),%eax
	eax = 0; edx = 0;
  104336:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
  10433d:	00 
  10433e:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
  104345:	00 
	cpuid(CPUID_KVM_FEATURES, &eax, &ebx, &ecx, &edx);
  104346:	50                   	push   %eax
  104347:	8d 6c 24 28          	lea    0x28(%esp),%ebp
  10434b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10434f:	55                   	push   %ebp
  104350:	8d 7c 24 28          	lea    0x28(%esp),%edi
  104354:	57                   	push   %edi
  104355:	8d 74 24 28          	lea    0x28(%esp),%esi
  104359:	56                   	push   %esi
  10435a:	68 01 00 00 40       	push   $0x40000001
  10435f:	e8 5c 11 00 00       	call   1054c0 <cpuid>
	uint64_t tsc_hz = 0llu;
	uint32_t msr_sys_time;

	if (kvm_has_feature(KVM_FEATURE_CLOCKSOURCE2))
  104364:	83 c4 20             	add    $0x20,%esp
  104367:	f6 44 24 10 03       	testb  $0x3,0x10(%esp)
  10436c:	75 42                	jne    1043b0 <kvm_get_tsc_hz+0x90>
	eax = 0; edx = 0;
  10436e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  104375:	00 
	cpuid(CPUID_KVM_FEATURES, &eax, &ebx, &ecx, &edx);
  104376:	83 ec 0c             	sub    $0xc,%esp
	eax = 0; edx = 0;
  104379:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
  104380:	00 
	cpuid(CPUID_KVM_FEATURES, &eax, &ebx, &ecx, &edx);
  104381:	8b 44 24 18          	mov    0x18(%esp),%eax
  104385:	50                   	push   %eax
  104386:	55                   	push   %ebp
  104387:	57                   	push   %edi
	{
		msr_sys_time = MSR_KVM_SYSTEM_TIME;
	}
	else
	{
		return (0llu);
  104388:	31 ff                	xor    %edi,%edi
	cpuid(CPUID_KVM_FEATURES, &eax, &ebx, &ecx, &edx);
  10438a:	56                   	push   %esi
		return (0llu);
  10438b:	31 f6                	xor    %esi,%esi
	cpuid(CPUID_KVM_FEATURES, &eax, &ebx, &ecx, &edx);
  10438d:	68 01 00 00 40       	push   $0x40000001
  104392:	e8 29 11 00 00       	call   1054c0 <cpuid>
	return ((eax & feature) != 0 ? 1 : 0);
  104397:	83 c4 20             	add    $0x20,%esp

	/* disable update */
	wrmsr(msr_sys_time, (uint64_t) ((uint32_t) &pvclock));

	return tsc_hz;
}
  10439a:	89 f0                	mov    %esi,%eax
  10439c:	89 fa                	mov    %edi,%edx
  10439e:	83 c4 2c             	add    $0x2c,%esp
  1043a1:	5b                   	pop    %ebx
  1043a2:	5e                   	pop    %esi
  1043a3:	5f                   	pop    %edi
  1043a4:	5d                   	pop    %ebp
  1043a5:	c3                   	ret
  1043a6:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1043ad:	00 
  1043ae:	66 90                	xchg   %ax,%ax
	wrmsr(msr_sys_time, (uint64_t) ((uint32_t) &pvclock) | 0x1llu);
  1043b0:	8d ab 8c a9 08 00    	lea    0x8a98c(%ebx),%ebp
  1043b6:	83 ec 04             	sub    $0x4,%esp
  1043b9:	31 d2                	xor    %edx,%edx
	tsc_hz = (uint64_t) pvclock.tsc_to_system_mul;
  1043bb:	31 ff                	xor    %edi,%edi
	wrmsr(msr_sys_time, (uint64_t) ((uint32_t) &pvclock) | 0x1llu);
  1043bd:	89 e8                	mov    %ebp,%eax
  1043bf:	52                   	push   %edx
  1043c0:	83 c8 01             	or     $0x1,%eax
  1043c3:	50                   	push   %eax
  1043c4:	68 01 4d 56 4b       	push   $0x4b564d01
  1043c9:	e8 52 10 00 00       	call   105420 <wrmsr>
	wrmsr(msr_sys_time, (uint64_t) ((uint32_t) &pvclock));
  1043ce:	83 c4 0c             	add    $0xc,%esp
  1043d1:	31 d2                	xor    %edx,%edx
	tsc_hz = (uint64_t) pvclock.tsc_to_system_mul;
  1043d3:	8b b3 a4 a9 08 00    	mov    0x8a9a4(%ebx),%esi
	wrmsr(msr_sys_time, (uint64_t) ((uint32_t) &pvclock));
  1043d9:	52                   	push   %edx
  1043da:	55                   	push   %ebp
  1043db:	68 01 4d 56 4b       	push   $0x4b564d01
  1043e0:	e8 3b 10 00 00       	call   105420 <wrmsr>
	return tsc_hz;
  1043e5:	83 c4 10             	add    $0x10,%esp
}
  1043e8:	89 f0                	mov    %esi,%eax
  1043ea:	89 fa                	mov    %edi,%edx
  1043ec:	83 c4 2c             	add    $0x2c,%esp
  1043ef:	5b                   	pop    %ebx
  1043f0:	5e                   	pop    %esi
  1043f1:	5f                   	pop    %edi
  1043f2:	5d                   	pop    %ebp
  1043f3:	c3                   	ret
  1043f4:	66 90                	xchg   %ax,%ax
  1043f6:	66 90                	xchg   %ax,%ax
  1043f8:	66 90                	xchg   %ax,%ax
  1043fa:	66 90                	xchg   %ax,%ax
  1043fc:	66 90                	xchg   %ax,%ax
  1043fe:	66 90                	xchg   %ax,%ax

00104400 <aesenc128>:

	return y;
}

uint128_t aesenc128 (uint128_t a, uint128_t round_key)
{
  104400:	83 ec 2c             	sub    $0x2c,%esp
	v2di _a = v2di_cast(a);
	v2di _round_key = v2di_cast(round_key);

	v2di _ret = __builtin_ia32_aesenc128(_a, _round_key);
  104403:	f3 0f 6f 44 24 34    	movdqu 0x34(%esp),%xmm0
  104409:	f3 0f 6f 4c 24 44    	movdqu 0x44(%esp),%xmm1
{
  10440f:	8b 44 24 30          	mov    0x30(%esp),%eax
	v2di _ret = __builtin_ia32_aesenc128(_a, _round_key);
  104413:	66 0f 38 dc c1       	aesenc %xmm1,%xmm0

	uint128_t ret = uint128_cast(_ret);
	return ret;
  104418:	0f 29 00             	movaps %xmm0,(%eax)
}
  10441b:	83 c4 2c             	add    $0x2c,%esp
  10441e:	c2 04 00             	ret    $0x4
  104421:	66 90                	xchg   %ax,%ax
  104423:	66 90                	xchg   %ax,%ax
  104425:	66 90                	xchg   %ax,%ax
  104427:	66 90                	xchg   %ax,%ax
  104429:	66 90                	xchg   %ax,%ax
  10442b:	66 90                	xchg   %ax,%ax
  10442d:	66 90                	xchg   %ax,%ax
  10442f:	90                   	nop

00104430 <memset>:
#include "string.h"
#include "types.h"

void *memset(void *v, int c, size_t n)
{
  104430:	57                   	push   %edi
  104431:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  104435:	8b 7c 24 08          	mov    0x8(%esp),%edi
    if (n == 0)
  104439:	85 c9                	test   %ecx,%ecx
  10443b:	74 19                	je     104456 <memset+0x26>
        return v;
    if ((int) v % 4 == 0 && n % 4 == 0) {
  10443d:	89 f8                	mov    %edi,%eax
  10443f:	09 c8                	or     %ecx,%eax
  104441:	a8 03                	test   $0x3,%al
  104443:	75 1b                	jne    104460 <memset+0x30>
        c &= 0xFF;
  104445:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
        c = (c << 24) | (c << 16) | (c << 8) | c;
        asm volatile ("cld; rep stosl\n"
                      :: "D" (v), "a" (c), "c" (n / 4)
  10444a:	c1 e9 02             	shr    $0x2,%ecx
  10444d:	69 c0 01 01 01 01    	imul   $0x1010101,%eax,%eax
        asm volatile ("cld; rep stosl\n"
  104453:	fc                   	cld
  104454:	f3 ab                	rep stos %eax,%es:(%edi)
    } else
        asm volatile ("cld; rep stosb\n"
                      :: "D" (v), "a" (c), "c" (n)
                      : "cc", "memory");
    return v;
}
  104456:	89 f8                	mov    %edi,%eax
  104458:	5f                   	pop    %edi
  104459:	c3                   	ret
  10445a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        asm volatile ("cld; rep stosb\n"
  104460:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104464:	fc                   	cld
  104465:	f3 aa                	rep stos %al,%es:(%edi)
}
  104467:	89 f8                	mov    %edi,%eax
  104469:	5f                   	pop    %edi
  10446a:	c3                   	ret
  10446b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00104470 <memmove>:

void *memmove(void *dst, const void *src, size_t n)
{
  104470:	57                   	push   %edi
  104471:	56                   	push   %esi
  104472:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104476:	8b 74 24 10          	mov    0x10(%esp),%esi
  10447a:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    const char *s;
    char *d;

    s = src;
    d = dst;
    if (s < d && s + n > d) {
  10447e:	39 c6                	cmp    %eax,%esi
  104480:	73 26                	jae    1044a8 <memmove+0x38>
  104482:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  104485:	39 d0                	cmp    %edx,%eax
  104487:	73 1f                	jae    1044a8 <memmove+0x38>
        s += n;
        d += n;
  104489:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
        if ((int) s % 4 == 0 && (int) d % 4 == 0 && n % 4 == 0)
  10448c:	89 fe                	mov    %edi,%esi
  10448e:	09 ce                	or     %ecx,%esi
  104490:	09 d6                	or     %edx,%esi
  104492:	83 e6 03             	and    $0x3,%esi
  104495:	74 39                	je     1044d0 <memmove+0x60>
            asm volatile ("std; rep movsl\n"
                          :: "D" (d - 4), "S" (s - 4), "c" (n / 4)
                          : "cc", "memory");
        else
            asm volatile ("std; rep movsb\n"
                          :: "D" (d - 1), "S" (s - 1), "c" (n)
  104497:	83 ef 01             	sub    $0x1,%edi
  10449a:	8d 72 ff             	lea    -0x1(%edx),%esi
            asm volatile ("std; rep movsb\n"
  10449d:	fd                   	std
  10449e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
                          : "cc", "memory");
        // Some versions of GCC rely on DF being clear
        asm volatile ("cld" ::: "cc");
  1044a0:	fc                   	cld
            asm volatile ("cld; rep movsb\n"
                          :: "D" (d), "S" (s), "c" (n)
                          : "cc", "memory");
    }
    return dst;
}
  1044a1:	5e                   	pop    %esi
  1044a2:	5f                   	pop    %edi
  1044a3:	c3                   	ret
  1044a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if ((int) s % 4 == 0 && (int) d % 4 == 0 && n % 4 == 0)
  1044a8:	89 c2                	mov    %eax,%edx
  1044aa:	09 ca                	or     %ecx,%edx
  1044ac:	09 f2                	or     %esi,%edx
  1044ae:	83 e2 03             	and    $0x3,%edx
  1044b1:	74 0d                	je     1044c0 <memmove+0x50>
            asm volatile ("cld; rep movsb\n"
  1044b3:	89 c7                	mov    %eax,%edi
  1044b5:	fc                   	cld
  1044b6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
}
  1044b8:	5e                   	pop    %esi
  1044b9:	5f                   	pop    %edi
  1044ba:	c3                   	ret
  1044bb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
                          :: "D" (d), "S" (s), "c" (n / 4)
  1044c0:	c1 e9 02             	shr    $0x2,%ecx
            asm volatile ("cld; rep movsl\n"
  1044c3:	89 c7                	mov    %eax,%edi
  1044c5:	fc                   	cld
  1044c6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  1044c8:	eb ee                	jmp    1044b8 <memmove+0x48>
  1044ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                          :: "D" (d - 4), "S" (s - 4), "c" (n / 4)
  1044d0:	83 ef 04             	sub    $0x4,%edi
  1044d3:	8d 72 fc             	lea    -0x4(%edx),%esi
  1044d6:	c1 e9 02             	shr    $0x2,%ecx
            asm volatile ("std; rep movsl\n"
  1044d9:	fd                   	std
  1044da:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  1044dc:	eb c2                	jmp    1044a0 <memmove+0x30>
  1044de:	66 90                	xchg   %ax,%ax

001044e0 <memcpy>:

void *memcpy(void *dst, const void *src, size_t n)
{
    return memmove(dst, src, n);
  1044e0:	eb 8e                	jmp    104470 <memmove>
  1044e2:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1044e9:	00 
  1044ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001044f0 <strncmp>:
}

int strncmp(const char *p, const char *q, size_t n)
{
  1044f0:	53                   	push   %ebx
  1044f1:	8b 54 24 10          	mov    0x10(%esp),%edx
  1044f5:	8b 44 24 08          	mov    0x8(%esp),%eax
  1044f9:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    while (n > 0 && *p && *p == *q)
  1044fd:	85 d2                	test   %edx,%edx
  1044ff:	75 16                	jne    104517 <strncmp+0x27>
  104501:	eb 2d                	jmp    104530 <strncmp+0x40>
  104503:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
  104508:	3a 19                	cmp    (%ecx),%bl
  10450a:	75 12                	jne    10451e <strncmp+0x2e>
        n--, p++, q++;
  10450c:	83 c0 01             	add    $0x1,%eax
  10450f:	83 c1 01             	add    $0x1,%ecx
    while (n > 0 && *p && *p == *q)
  104512:	83 ea 01             	sub    $0x1,%edx
  104515:	74 19                	je     104530 <strncmp+0x40>
  104517:	0f b6 18             	movzbl (%eax),%ebx
  10451a:	84 db                	test   %bl,%bl
  10451c:	75 ea                	jne    104508 <strncmp+0x18>
    if (n == 0)
        return 0;
    else
        return (int) ((unsigned char) *p - (unsigned char) *q);
  10451e:	0f b6 00             	movzbl (%eax),%eax
  104521:	0f b6 11             	movzbl (%ecx),%edx
}
  104524:	5b                   	pop    %ebx
        return (int) ((unsigned char) *p - (unsigned char) *q);
  104525:	29 d0                	sub    %edx,%eax
}
  104527:	c3                   	ret
  104528:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10452f:	00 
        return 0;
  104530:	31 c0                	xor    %eax,%eax
}
  104532:	5b                   	pop    %ebx
  104533:	c3                   	ret
  104534:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10453b:	00 
  10453c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00104540 <strnlen>:

int strnlen(const char *s, size_t size)
{
  104540:	8b 54 24 08          	mov    0x8(%esp),%edx
  104544:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    int n;

    for (n = 0; size > 0 && *s != '\0'; s++, size--)
  104548:	31 c0                	xor    %eax,%eax
  10454a:	85 d2                	test   %edx,%edx
  10454c:	75 09                	jne    104557 <strnlen+0x17>
  10454e:	c3                   	ret
  10454f:	90                   	nop
        n++;
  104550:	83 c0 01             	add    $0x1,%eax
    for (n = 0; size > 0 && *s != '\0'; s++, size--)
  104553:	39 c2                	cmp    %eax,%edx
  104555:	74 09                	je     104560 <strnlen+0x20>
  104557:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  10455b:	75 f3                	jne    104550 <strnlen+0x10>
  10455d:	c3                   	ret
  10455e:	66 90                	xchg   %ax,%ax
    return n;
}
  104560:	c3                   	ret
  104561:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  104568:	00 
  104569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00104570 <strcmp>:

int strcmp(const char *p, const char *q)
{
  104570:	53                   	push   %ebx
  104571:	8b 54 24 08          	mov    0x8(%esp),%edx
  104575:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    while (*p && *p == *q)
  104579:	0f b6 02             	movzbl (%edx),%eax
  10457c:	84 c0                	test   %al,%al
  10457e:	75 18                	jne    104598 <strcmp+0x28>
  104580:	eb 30                	jmp    1045b2 <strcmp+0x42>
  104582:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  104588:	0f b6 42 01          	movzbl 0x1(%edx),%eax
        p++, q++;
  10458c:	83 c2 01             	add    $0x1,%edx
  10458f:	8d 59 01             	lea    0x1(%ecx),%ebx
    while (*p && *p == *q)
  104592:	84 c0                	test   %al,%al
  104594:	74 12                	je     1045a8 <strcmp+0x38>
  104596:	89 d9                	mov    %ebx,%ecx
  104598:	0f b6 19             	movzbl (%ecx),%ebx
  10459b:	38 c3                	cmp    %al,%bl
  10459d:	74 e9                	je     104588 <strcmp+0x18>
    return (int) ((unsigned char) *p - (unsigned char) *q);
  10459f:	29 d8                	sub    %ebx,%eax
}
  1045a1:	5b                   	pop    %ebx
  1045a2:	c3                   	ret
  1045a3:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    return (int) ((unsigned char) *p - (unsigned char) *q);
  1045a8:	0f b6 59 01          	movzbl 0x1(%ecx),%ebx
  1045ac:	31 c0                	xor    %eax,%eax
  1045ae:	29 d8                	sub    %ebx,%eax
}
  1045b0:	5b                   	pop    %ebx
  1045b1:	c3                   	ret
    return (int) ((unsigned char) *p - (unsigned char) *q);
  1045b2:	0f b6 19             	movzbl (%ecx),%ebx
  1045b5:	31 c0                	xor    %eax,%eax
  1045b7:	eb e6                	jmp    10459f <strcmp+0x2f>
  1045b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001045c0 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *strchr(const char *s, char c)
{
  1045c0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1045c4:	0f b6 4c 24 08       	movzbl 0x8(%esp),%ecx
    for (; *s; s++)
  1045c9:	0f b6 10             	movzbl (%eax),%edx
  1045cc:	84 d2                	test   %dl,%dl
  1045ce:	75 13                	jne    1045e3 <strchr+0x23>
  1045d0:	eb 1e                	jmp    1045f0 <strchr+0x30>
  1045d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1045d8:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  1045dc:	83 c0 01             	add    $0x1,%eax
  1045df:	84 d2                	test   %dl,%dl
  1045e1:	74 0d                	je     1045f0 <strchr+0x30>
        if (*s == c)
  1045e3:	38 d1                	cmp    %dl,%cl
  1045e5:	75 f1                	jne    1045d8 <strchr+0x18>
            return (char *) s;
    return 0;
}
  1045e7:	c3                   	ret
  1045e8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1045ef:	00 
    return 0;
  1045f0:	31 c0                	xor    %eax,%eax
}
  1045f2:	c3                   	ret
  1045f3:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1045fa:	00 
  1045fb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00104600 <memzero>:

void *memzero(void *v, size_t n)
{
  104600:	57                   	push   %edi
  104601:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  104605:	8b 7c 24 08          	mov    0x8(%esp),%edi
    if (n == 0)
  104609:	85 c9                	test   %ecx,%ecx
  10460b:	74 0f                	je     10461c <memzero+0x1c>
    if ((int) v % 4 == 0 && n % 4 == 0) {
  10460d:	89 f8                	mov    %edi,%eax
  10460f:	09 c8                	or     %ecx,%eax
  104611:	83 e0 03             	and    $0x3,%eax
  104614:	75 0a                	jne    104620 <memzero+0x20>
                      :: "D" (v), "a" (c), "c" (n / 4)
  104616:	c1 e9 02             	shr    $0x2,%ecx
        asm volatile ("cld; rep stosl\n"
  104619:	fc                   	cld
  10461a:	f3 ab                	rep stos %eax,%es:(%edi)
    return memset(v, 0, n);
}
  10461c:	89 f8                	mov    %edi,%eax
  10461e:	5f                   	pop    %edi
  10461f:	c3                   	ret
        asm volatile ("cld; rep stosb\n"
  104620:	31 c0                	xor    %eax,%eax
  104622:	fc                   	cld
  104623:	f3 aa                	rep stos %al,%es:(%edi)
}
  104625:	89 f8                	mov    %edi,%eax
  104627:	5f                   	pop    %edi
  104628:	c3                   	ret
  104629:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00104630 <memcmp>:

int memcmp(const void *v1, const void *v2, size_t n)
{
  104630:	56                   	push   %esi
  104631:	53                   	push   %ebx
  104632:	8b 74 24 14          	mov    0x14(%esp),%esi
  104636:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10463a:	8b 54 24 10          	mov    0x10(%esp),%edx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
  10463e:	85 f6                	test   %esi,%esi
  104640:	74 2e                	je     104670 <memcmp+0x40>
  104642:	01 c6                	add    %eax,%esi
  104644:	eb 14                	jmp    10465a <memcmp+0x2a>
  104646:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10464d:	00 
  10464e:	66 90                	xchg   %ax,%ax
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
        s1++, s2++;
  104650:	83 c0 01             	add    $0x1,%eax
  104653:	83 c2 01             	add    $0x1,%edx
    while (n-- > 0) {
  104656:	39 f0                	cmp    %esi,%eax
  104658:	74 16                	je     104670 <memcmp+0x40>
        if (*s1 != *s2)
  10465a:	0f b6 08             	movzbl (%eax),%ecx
  10465d:	0f b6 1a             	movzbl (%edx),%ebx
  104660:	38 d9                	cmp    %bl,%cl
  104662:	74 ec                	je     104650 <memcmp+0x20>
            return (int) *s1 - (int) *s2;
  104664:	0f b6 c1             	movzbl %cl,%eax
  104667:	29 d8                	sub    %ebx,%eax
    }

    return 0;
}
  104669:	5b                   	pop    %ebx
  10466a:	5e                   	pop    %esi
  10466b:	c3                   	ret
  10466c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    return 0;
  104670:	31 c0                	xor    %eax,%eax
}
  104672:	5b                   	pop    %ebx
  104673:	5e                   	pop    %esi
  104674:	c3                   	ret
  104675:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10467c:	00 
  10467d:	8d 76 00             	lea    0x0(%esi),%esi

00104680 <strncpy>:

char *strncpy(char *s, const char *t, int n)
{
  104680:	57                   	push   %edi
  104681:	56                   	push   %esi
  104682:	53                   	push   %ebx
  104683:	8b 7c 24 10          	mov    0x10(%esp),%edi
  104687:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  10468b:	8b 54 24 18          	mov    0x18(%esp),%edx
    char *os;

    os = s;
    while (n-- > 0 && (*s++ = *t++) != 0) {}
  10468f:	89 f8                	mov    %edi,%eax
  104691:	eb 15                	jmp    1046a8 <strncpy+0x28>
  104693:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
  104698:	0f b6 19             	movzbl (%ecx),%ebx
  10469b:	83 c1 01             	add    $0x1,%ecx
  10469e:	83 c0 01             	add    $0x1,%eax
  1046a1:	88 58 ff             	mov    %bl,-0x1(%eax)
  1046a4:	84 db                	test   %bl,%bl
  1046a6:	74 18                	je     1046c0 <strncpy+0x40>
  1046a8:	89 d6                	mov    %edx,%esi
  1046aa:	83 ea 01             	sub    $0x1,%edx
  1046ad:	85 f6                	test   %esi,%esi
  1046af:	7f e7                	jg     104698 <strncpy+0x18>
    while (n-- > 0)
        *s++ = 0;
    return os;
}
  1046b1:	89 f8                	mov    %edi,%eax
  1046b3:	5b                   	pop    %ebx
  1046b4:	5e                   	pop    %esi
  1046b5:	5f                   	pop    %edi
  1046b6:	c3                   	ret
  1046b7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1046be:	00 
  1046bf:	90                   	nop
    while (n-- > 0)
  1046c0:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
  1046c3:	83 e9 01             	sub    $0x1,%ecx
  1046c6:	85 d2                	test   %edx,%edx
  1046c8:	74 e7                	je     1046b1 <strncpy+0x31>
  1046ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        *s++ = 0;
  1046d0:	83 c0 01             	add    $0x1,%eax
  1046d3:	89 ca                	mov    %ecx,%edx
  1046d5:	c6 40 ff 00          	movb   $0x0,-0x1(%eax)
    while (n-- > 0)
  1046d9:	29 c2                	sub    %eax,%edx
  1046db:	85 d2                	test   %edx,%edx
  1046dd:	7f f1                	jg     1046d0 <strncpy+0x50>
}
  1046df:	89 f8                	mov    %edi,%eax
  1046e1:	5b                   	pop    %ebx
  1046e2:	5e                   	pop    %esi
  1046e3:	5f                   	pop    %edi
  1046e4:	c3                   	ret
  1046e5:	66 90                	xchg   %ax,%ax
  1046e7:	66 90                	xchg   %ax,%ax
  1046e9:	66 90                	xchg   %ax,%ax
  1046eb:	66 90                	xchg   %ax,%ax
  1046ed:	66 90                	xchg   %ax,%ax
  1046ef:	90                   	nop

001046f0 <debug_init>:
#include <lib/reentrant_lock.h>

static reentrantlock debug_lk;

void debug_init(void)
{
  1046f0:	53                   	push   %ebx
  1046f1:	e8 ac bc ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1046f6:	81 c3 fe 28 01 00    	add    $0x128fe,%ebx
  1046fc:	83 ec 14             	sub    $0x14,%esp
    reentrantlock_init(&debug_lk);
  1046ff:	8d 83 ac a9 08 00    	lea    0x8a9ac(%ebx),%eax
  104705:	50                   	push   %eax
  104706:	e8 95 19 00 00       	call   1060a0 <reentrantlock_init>
}
  10470b:	83 c4 18             	add    $0x18,%esp
  10470e:	5b                   	pop    %ebx
  10470f:	c3                   	ret

00104710 <debug_lock>:

void debug_lock(void)
{
  104710:	53                   	push   %ebx
  104711:	e8 8c bc ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  104716:	81 c3 de 28 01 00    	add    $0x128de,%ebx
  10471c:	83 ec 14             	sub    $0x14,%esp
    reentrantlock_acquire(&debug_lk);
  10471f:	8d 83 ac a9 08 00    	lea    0x8a9ac(%ebx),%eax
  104725:	50                   	push   %eax
  104726:	e8 a5 19 00 00       	call   1060d0 <reentrantlock_acquire>
}
  10472b:	83 c4 18             	add    $0x18,%esp
  10472e:	5b                   	pop    %ebx
  10472f:	c3                   	ret

00104730 <debug_unlock>:

void debug_unlock(void)
{
  104730:	53                   	push   %ebx
  104731:	e8 6c bc ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  104736:	81 c3 be 28 01 00    	add    $0x128be,%ebx
  10473c:	83 ec 14             	sub    $0x14,%esp
    reentrantlock_release(&debug_lk);
  10473f:	8d 83 ac a9 08 00    	lea    0x8a9ac(%ebx),%eax
  104745:	50                   	push   %eax
  104746:	e8 35 1a 00 00       	call   106180 <reentrantlock_release>
}
  10474b:	83 c4 18             	add    $0x18,%esp
  10474e:	5b                   	pop    %ebx
  10474f:	c3                   	ret

00104750 <debug_info>:

extern int vdprintf(const char *fmt, va_list ap);

void debug_info(const char *fmt, ...)
{
  104750:	56                   	push   %esi
  104751:	53                   	push   %ebx
  104752:	e8 4b bc ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  104757:	81 c3 9d 28 01 00    	add    $0x1289d,%ebx
  10475d:	83 ec 10             	sub    $0x10,%esp
    reentrantlock_acquire(&debug_lk);
  104760:	8d b3 ac a9 08 00    	lea    0x8a9ac(%ebx),%esi
  104766:	56                   	push   %esi
  104767:	e8 64 19 00 00       	call   1060d0 <reentrantlock_acquire>
#ifdef DEBUG_MSG
    debug_lock();
    va_list ap;
    va_start(ap, fmt);
  10476c:	8d 44 24 24          	lea    0x24(%esp),%eax
    vdprintf(fmt, ap);
  104770:	5a                   	pop    %edx
  104771:	59                   	pop    %ecx
  104772:	50                   	push   %eax
  104773:	ff 74 24 1c          	push   0x1c(%esp)
  104777:	e8 54 02 00 00       	call   1049d0 <vdprintf>
    reentrantlock_release(&debug_lk);
  10477c:	89 34 24             	mov    %esi,(%esp)
  10477f:	e8 fc 19 00 00       	call   106180 <reentrantlock_release>
    va_end(ap);
    debug_unlock();
#endif
}
  104784:	83 c4 14             	add    $0x14,%esp
  104787:	5b                   	pop    %ebx
  104788:	5e                   	pop    %esi
  104789:	c3                   	ret
  10478a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00104790 <debug_normal>:

#ifdef DEBUG_MSG

void debug_normal(const char *file, int line, const char *fmt, ...)
{
  104790:	56                   	push   %esi
  104791:	53                   	push   %ebx
  104792:	e8 0b bc ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  104797:	81 c3 5d 28 01 00    	add    $0x1285d,%ebx
  10479d:	83 ec 10             	sub    $0x10,%esp
    reentrantlock_acquire(&debug_lk);
  1047a0:	8d b3 ac a9 08 00    	lea    0x8a9ac(%ebx),%esi
  1047a6:	56                   	push   %esi
  1047a7:	e8 24 19 00 00       	call   1060d0 <reentrantlock_acquire>
    debug_lock();
    dprintf("[D] %s:%d: ", file, line);
  1047ac:	83 c4 0c             	add    $0xc,%esp
  1047af:	8d 83 f9 63 ff ff    	lea    -0x9c07(%ebx),%eax
  1047b5:	ff 74 24 18          	push   0x18(%esp)
  1047b9:	ff 74 24 18          	push   0x18(%esp)
  1047bd:	50                   	push   %eax
  1047be:	e8 9d 02 00 00       	call   104a60 <dprintf>

    va_list ap;
    va_start(ap, fmt);
  1047c3:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    vdprintf(fmt, ap);
  1047c7:	5a                   	pop    %edx
  1047c8:	59                   	pop    %ecx
  1047c9:	50                   	push   %eax
  1047ca:	ff 74 24 24          	push   0x24(%esp)
  1047ce:	e8 fd 01 00 00       	call   1049d0 <vdprintf>
    reentrantlock_release(&debug_lk);
  1047d3:	89 34 24             	mov    %esi,(%esp)
  1047d6:	e8 a5 19 00 00       	call   106180 <reentrantlock_release>
    va_end(ap);
    debug_unlock();
}
  1047db:	83 c4 14             	add    $0x14,%esp
  1047de:	5b                   	pop    %ebx
  1047df:	5e                   	pop    %esi
  1047e0:	c3                   	ret
  1047e1:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1047e8:	00 
  1047e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001047f0 <debug_panic>:
    for (; i < DEBUG_TRACEFRAMES; i++)
        eips[i] = 0;
}

gcc_noinline void debug_panic(const char *file, int line, const char *fmt, ...)
{
  1047f0:	55                   	push   %ebp
  1047f1:	57                   	push   %edi
  1047f2:	56                   	push   %esi
  1047f3:	53                   	push   %ebx
  1047f4:	e8 a9 bb ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1047f9:	81 c3 fb 27 01 00    	add    $0x127fb,%ebx
  1047ff:	83 ec 58             	sub    $0x58,%esp
    reentrantlock_acquire(&debug_lk);
  104802:	8d 83 ac a9 08 00    	lea    0x8a9ac(%ebx),%eax
  104808:	89 44 24 18          	mov    %eax,0x18(%esp)
  10480c:	50                   	push   %eax
  10480d:	e8 be 18 00 00       	call   1060d0 <reentrantlock_acquire>
    int i;
    uintptr_t eips[DEBUG_TRACEFRAMES];
    va_list ap;

    debug_lock();
    dprintf("[P] %s:%d: ", file, line);
  104812:	83 c4 0c             	add    $0xc,%esp
  104815:	8d 83 05 64 ff ff    	lea    -0x9bfb(%ebx),%eax
  10481b:	ff 74 24 68          	push   0x68(%esp)
  10481f:	ff 74 24 68          	push   0x68(%esp)
  104823:	50                   	push   %eax
  104824:	e8 37 02 00 00       	call   104a60 <dprintf>

    va_start(ap, fmt);
  104829:	8d 44 24 7c          	lea    0x7c(%esp),%eax
    vdprintf(fmt, ap);
  10482d:	5a                   	pop    %edx
  10482e:	59                   	pop    %ecx
  10482f:	50                   	push   %eax
  104830:	ff 74 24 74          	push   0x74(%esp)
  104834:	e8 97 01 00 00       	call   1049d0 <vdprintf>
    va_end(ap);

    debug_trace(read_ebp(), eips);
  104839:	e8 92 0b 00 00       	call   1053d0 <read_ebp>
    for (i = 0; i < DEBUG_TRACEFRAMES && frame; i++) {
  10483e:	83 c4 10             	add    $0x10,%esp
  104841:	31 c9                	xor    %ecx,%ecx
  104843:	8d 54 24 18          	lea    0x18(%esp),%edx
  104847:	85 c0                	test   %eax,%eax
  104849:	74 1e                	je     104869 <debug_panic+0x79>
  10484b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        eips[i] = frame[1];              /* saved %eip */
  104850:	8b 70 04             	mov    0x4(%eax),%esi
        frame = (uintptr_t *) frame[0];  /* saved %ebp */
  104853:	8b 00                	mov    (%eax),%eax
        eips[i] = frame[1];              /* saved %eip */
  104855:	89 34 8a             	mov    %esi,(%edx,%ecx,4)
    for (i = 0; i < DEBUG_TRACEFRAMES && frame; i++) {
  104858:	83 c1 01             	add    $0x1,%ecx
  10485b:	83 f9 09             	cmp    $0x9,%ecx
  10485e:	7f 04                	jg     104864 <debug_panic+0x74>
  104860:	85 c0                	test   %eax,%eax
  104862:	75 ec                	jne    104850 <debug_panic+0x60>
    for (; i < DEBUG_TRACEFRAMES; i++)
  104864:	83 f9 0a             	cmp    $0xa,%ecx
  104867:	74 3b                	je     1048a4 <debug_panic+0xb4>
  104869:	8d 04 8a             	lea    (%edx,%ecx,4),%eax
  10486c:	8d 4c 24 40          	lea    0x40(%esp),%ecx
  104870:	89 ce                	mov    %ecx,%esi
  104872:	29 c6                	sub    %eax,%esi
  104874:	83 e6 04             	and    $0x4,%esi
  104877:	74 17                	je     104890 <debug_panic+0xa0>
        eips[i] = 0;
  104879:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (; i < DEBUG_TRACEFRAMES; i++)
  10487f:	8d 7c 24 40          	lea    0x40(%esp),%edi
  104883:	83 c0 04             	add    $0x4,%eax
  104886:	39 f8                	cmp    %edi,%eax
  104888:	74 1a                	je     1048a4 <debug_panic+0xb4>
  10488a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        eips[i] = 0;
  104890:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (; i < DEBUG_TRACEFRAMES; i++)
  104896:	83 c0 08             	add    $0x8,%eax
        eips[i] = 0;
  104899:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    for (; i < DEBUG_TRACEFRAMES; i++)
  1048a0:	39 c8                	cmp    %ecx,%eax
  1048a2:	75 ec                	jne    104890 <debug_panic+0xa0>
    for (i = 0; i < DEBUG_TRACEFRAMES && eips[i] != 0; i++)
  1048a4:	89 d5                	mov    %edx,%ebp
  1048a6:	8d 7c 24 40          	lea    0x40(%esp),%edi
        dprintf("\tfrom 0x%08x\n", eips[i]);
  1048aa:	8d b3 11 64 ff ff    	lea    -0x9bef(%ebx),%esi
    for (i = 0; i < DEBUG_TRACEFRAMES && eips[i] != 0; i++)
  1048b0:	8b 45 00             	mov    0x0(%ebp),%eax
  1048b3:	85 c0                	test   %eax,%eax
  1048b5:	74 14                	je     1048cb <debug_panic+0xdb>
        dprintf("\tfrom 0x%08x\n", eips[i]);
  1048b7:	83 ec 08             	sub    $0x8,%esp
    for (i = 0; i < DEBUG_TRACEFRAMES && eips[i] != 0; i++)
  1048ba:	83 c5 04             	add    $0x4,%ebp
        dprintf("\tfrom 0x%08x\n", eips[i]);
  1048bd:	50                   	push   %eax
  1048be:	56                   	push   %esi
  1048bf:	e8 9c 01 00 00       	call   104a60 <dprintf>
    for (i = 0; i < DEBUG_TRACEFRAMES && eips[i] != 0; i++)
  1048c4:	83 c4 10             	add    $0x10,%esp
  1048c7:	39 ef                	cmp    %ebp,%edi
  1048c9:	75 e5                	jne    1048b0 <debug_panic+0xc0>

    dprintf("Kernel Panic !!!\n");
  1048cb:	83 ec 0c             	sub    $0xc,%esp
  1048ce:	8d 83 1f 64 ff ff    	lea    -0x9be1(%ebx),%eax
  1048d4:	50                   	push   %eax
  1048d5:	e8 86 01 00 00       	call   104a60 <dprintf>
    reentrantlock_release(&debug_lk);
  1048da:	58                   	pop    %eax
  1048db:	ff 74 24 18          	push   0x18(%esp)
  1048df:	e8 9c 18 00 00       	call   106180 <reentrantlock_release>

    debug_unlock();
    halt();
  1048e4:	e8 47 0b 00 00       	call   105430 <halt>
}
  1048e9:	83 c4 5c             	add    $0x5c,%esp
  1048ec:	5b                   	pop    %ebx
  1048ed:	5e                   	pop    %esi
  1048ee:	5f                   	pop    %edi
  1048ef:	5d                   	pop    %ebp
  1048f0:	c3                   	ret
  1048f1:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1048f8:	00 
  1048f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00104900 <debug_warn>:

void debug_warn(const char *file, int line, const char *fmt, ...)
{
  104900:	56                   	push   %esi
  104901:	53                   	push   %ebx
  104902:	e8 9b ba ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  104907:	81 c3 ed 26 01 00    	add    $0x126ed,%ebx
  10490d:	83 ec 10             	sub    $0x10,%esp
    reentrantlock_acquire(&debug_lk);
  104910:	8d b3 ac a9 08 00    	lea    0x8a9ac(%ebx),%esi
  104916:	56                   	push   %esi
  104917:	e8 b4 17 00 00       	call   1060d0 <reentrantlock_acquire>
    debug_lock();
    dprintf("[W] %s:%d: ", file, line);
  10491c:	83 c4 0c             	add    $0xc,%esp
  10491f:	8d 83 31 64 ff ff    	lea    -0x9bcf(%ebx),%eax
  104925:	ff 74 24 18          	push   0x18(%esp)
  104929:	ff 74 24 18          	push   0x18(%esp)
  10492d:	50                   	push   %eax
  10492e:	e8 2d 01 00 00       	call   104a60 <dprintf>

    va_list ap;
    va_start(ap, fmt);
  104933:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    vdprintf(fmt, ap);
  104937:	5a                   	pop    %edx
  104938:	59                   	pop    %ecx
  104939:	50                   	push   %eax
  10493a:	ff 74 24 24          	push   0x24(%esp)
  10493e:	e8 8d 00 00 00       	call   1049d0 <vdprintf>
    reentrantlock_release(&debug_lk);
  104943:	89 34 24             	mov    %esi,(%esp)
  104946:	e8 35 18 00 00       	call   106180 <reentrantlock_release>
    va_end(ap);
    debug_unlock();
}
  10494b:	83 c4 14             	add    $0x14,%esp
  10494e:	5b                   	pop    %ebx
  10494f:	5e                   	pop    %esi
  104950:	c3                   	ret
  104951:	66 90                	xchg   %ax,%ax
  104953:	66 90                	xchg   %ax,%ax
  104955:	66 90                	xchg   %ax,%ax
  104957:	66 90                	xchg   %ax,%ax
  104959:	66 90                	xchg   %ax,%ax
  10495b:	66 90                	xchg   %ax,%ax
  10495d:	66 90                	xchg   %ax,%ax
  10495f:	90                   	nop

00104960 <putch>:
        str += 1;
    }
}

static void putch(int ch, struct dprintbuf *b)
{
  104960:	57                   	push   %edi
  104961:	56                   	push   %esi
  104962:	53                   	push   %ebx
  104963:	8b 74 24 14          	mov    0x14(%esp),%esi
  104967:	e8 36 ba ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10496c:	81 c3 88 26 01 00    	add    $0x12688,%ebx
    b->buf[b->idx++] = ch;
  104972:	8b 54 24 10          	mov    0x10(%esp),%edx
  104976:	8b 0e                	mov    (%esi),%ecx
  104978:	8d 41 01             	lea    0x1(%ecx),%eax
  10497b:	89 06                	mov    %eax,(%esi)
  10497d:	88 54 0e 08          	mov    %dl,0x8(%esi,%ecx,1)
    if (b->idx == CONSOLE_BUFFER_SIZE - 1) {
  104981:	3d ff 01 00 00       	cmp    $0x1ff,%eax
  104986:	74 08                	je     104990 <putch+0x30>
        b->buf[b->idx] = 0;
        cputs(b->buf);
        b->idx = 0;
    }
    b->cnt++;
  104988:	83 46 04 01          	addl   $0x1,0x4(%esi)
}
  10498c:	5b                   	pop    %ebx
  10498d:	5e                   	pop    %esi
  10498e:	5f                   	pop    %edi
  10498f:	c3                   	ret
    while (*str) {
  104990:	0f be 46 08          	movsbl 0x8(%esi),%eax
        b->buf[b->idx] = 0;
  104994:	c6 86 07 02 00 00 00 	movb   $0x0,0x207(%esi)
        cputs(b->buf);
  10499b:	8d 7e 08             	lea    0x8(%esi),%edi
    while (*str) {
  10499e:	84 c0                	test   %al,%al
  1049a0:	74 1c                	je     1049be <putch+0x5e>
  1049a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        cons_putc(*str);
  1049a8:	83 ec 0c             	sub    $0xc,%esp
        str += 1;
  1049ab:	83 c7 01             	add    $0x1,%edi
        cons_putc(*str);
  1049ae:	50                   	push   %eax
  1049af:	e8 5c bb ff ff       	call   100510 <cons_putc>
    while (*str) {
  1049b4:	0f be 07             	movsbl (%edi),%eax
  1049b7:	83 c4 10             	add    $0x10,%esp
  1049ba:	84 c0                	test   %al,%al
  1049bc:	75 ea                	jne    1049a8 <putch+0x48>
    b->cnt++;
  1049be:	83 46 04 01          	addl   $0x1,0x4(%esi)
        b->idx = 0;
  1049c2:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
  1049c8:	5b                   	pop    %ebx
  1049c9:	5e                   	pop    %esi
  1049ca:	5f                   	pop    %edi
  1049cb:	c3                   	ret
  1049cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001049d0 <vdprintf>:

int vdprintf(const char *fmt, va_list ap)
{
  1049d0:	56                   	push   %esi
  1049d1:	53                   	push   %ebx
  1049d2:	e8 cb b9 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1049d7:	81 c3 1d 26 01 00    	add    $0x1261d,%ebx
  1049dd:	81 ec 14 02 00 00    	sub    $0x214,%esp
    struct dprintbuf b;

    debug_lock();
  1049e3:	e8 28 fd ff ff       	call   104710 <debug_lock>
    b.idx = 0;
  1049e8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1049ef:	00 
    b.cnt = 0;
  1049f0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1049f7:	00 
    vprintfmt((void *) putch, &b, fmt, ap);
  1049f8:	ff b4 24 24 02 00 00 	push   0x224(%esp)
  1049ff:	ff b4 24 24 02 00 00 	push   0x224(%esp)
  104a06:	8d 44 24 10          	lea    0x10(%esp),%eax
  104a0a:	50                   	push   %eax
  104a0b:	8d 83 6c d9 fe ff    	lea    -0x12694(%ebx),%eax
  104a11:	50                   	push   %eax
  104a12:	e8 49 01 00 00       	call   104b60 <vprintfmt>

    b.buf[b.idx] = 0;
  104a17:	8b 44 24 18          	mov    0x18(%esp),%eax
  104a1b:	c6 44 04 20 00       	movb   $0x0,0x20(%esp,%eax,1)
    while (*str) {
  104a20:	0f be 44 24 20       	movsbl 0x20(%esp),%eax
  104a25:	83 c4 10             	add    $0x10,%esp
  104a28:	84 c0                	test   %al,%al
  104a2a:	74 1a                	je     104a46 <vdprintf+0x76>
  104a2c:	8d 74 24 10          	lea    0x10(%esp),%esi
        cons_putc(*str);
  104a30:	83 ec 0c             	sub    $0xc,%esp
        str += 1;
  104a33:	83 c6 01             	add    $0x1,%esi
        cons_putc(*str);
  104a36:	50                   	push   %eax
  104a37:	e8 d4 ba ff ff       	call   100510 <cons_putc>
    while (*str) {
  104a3c:	0f be 06             	movsbl (%esi),%eax
  104a3f:	83 c4 10             	add    $0x10,%esp
  104a42:	84 c0                	test   %al,%al
  104a44:	75 ea                	jne    104a30 <vdprintf+0x60>
    cputs(b.buf);
    debug_unlock();
  104a46:	e8 e5 fc ff ff       	call   104730 <debug_unlock>

    return b.cnt;
}
  104a4b:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104a4f:	81 c4 14 02 00 00    	add    $0x214,%esp
  104a55:	5b                   	pop    %ebx
  104a56:	5e                   	pop    %esi
  104a57:	c3                   	ret
  104a58:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  104a5f:	00 

00104a60 <dprintf>:

int dprintf(const char *fmt, ...)
{
  104a60:	83 ec 0c             	sub    $0xc,%esp
    va_list ap;
    int cnt;

    va_start(ap, fmt);
  104a63:	8d 44 24 14          	lea    0x14(%esp),%eax
    cnt = vdprintf(fmt, ap);
  104a67:	83 ec 08             	sub    $0x8,%esp
  104a6a:	50                   	push   %eax
  104a6b:	ff 74 24 1c          	push   0x1c(%esp)
  104a6f:	e8 5c ff ff ff       	call   1049d0 <vdprintf>
    va_end(ap);

    return cnt;
}
  104a74:	83 c4 1c             	add    $0x1c,%esp
  104a77:	c3                   	ret
  104a78:	66 90                	xchg   %ax,%ax
  104a7a:	66 90                	xchg   %ax,%ax
  104a7c:	66 90                	xchg   %ax,%ax
  104a7e:	66 90                	xchg   %ax,%ax

00104a80 <printnum>:
 */
static void printnum(putch_t putch, void *putdat, unsigned long long num,
                     unsigned base, int width, int padc)
{
    /* first recursively print all preceding (more significant) digits */
    if (num >= base) {
  104a80:	e8 6e e3 ff ff       	call   102df3 <__x86.get_pc_thunk.cx>
  104a85:	81 c1 6f 25 01 00    	add    $0x1256f,%ecx
{
  104a8b:	55                   	push   %ebp
  104a8c:	57                   	push   %edi
  104a8d:	89 d7                	mov    %edx,%edi
  104a8f:	56                   	push   %esi
  104a90:	89 c6                	mov    %eax,%esi
  104a92:	53                   	push   %ebx
  104a93:	83 ec 2c             	sub    $0x2c,%esp
  104a96:	8b 44 24 40          	mov    0x40(%esp),%eax
  104a9a:	8b 54 24 44          	mov    0x44(%esp),%edx
  104a9e:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    if (num >= base) {
  104aa2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  104aa9:	00 
{
  104aaa:	8b 6c 24 50          	mov    0x50(%esp),%ebp
  104aae:	89 44 24 08          	mov    %eax,0x8(%esp)
  104ab2:	8b 44 24 48          	mov    0x48(%esp),%eax
  104ab6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  104aba:	8b 54 24 4c          	mov    0x4c(%esp),%edx
    if (num >= base) {
  104abe:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  104ac2:	39 44 24 08          	cmp    %eax,0x8(%esp)
  104ac6:	89 44 24 10          	mov    %eax,0x10(%esp)
  104aca:	1b 4c 24 14          	sbb    0x14(%esp),%ecx
        printnum(putch, putdat, num / base, base, width - 1, padc);
    } else {
        /* print any needed pad characters before first digit */
        while (--width > 0)
  104ace:	8d 5a ff             	lea    -0x1(%edx),%ebx
    if (num >= base) {
  104ad1:	73 55                	jae    104b28 <printnum+0xa8>
        while (--width > 0)
  104ad3:	83 fa 01             	cmp    $0x1,%edx
  104ad6:	7e 17                	jle    104aef <printnum+0x6f>
  104ad8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  104adf:	00 
            putch(padc, putdat);
  104ae0:	83 ec 08             	sub    $0x8,%esp
  104ae3:	57                   	push   %edi
  104ae4:	55                   	push   %ebp
  104ae5:	ff d6                	call   *%esi
        while (--width > 0)
  104ae7:	83 c4 10             	add    $0x10,%esp
  104aea:	83 eb 01             	sub    $0x1,%ebx
  104aed:	75 f1                	jne    104ae0 <printnum+0x60>
    }

    // then print this (the least significant) digit
    putch("0123456789abcdef"[num % base], putdat);
  104aef:	89 7c 24 44          	mov    %edi,0x44(%esp)
  104af3:	ff 74 24 14          	push   0x14(%esp)
  104af7:	ff 74 24 14          	push   0x14(%esp)
  104afb:	ff 74 24 14          	push   0x14(%esp)
  104aff:	ff 74 24 14          	push   0x14(%esp)
  104b03:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  104b07:	e8 94 79 00 00       	call   10c4a0 <__umoddi3>
  104b0c:	0f be 84 03 3d 64 ff 	movsbl -0x9bc3(%ebx,%eax,1),%eax
  104b13:	ff 
  104b14:	89 44 24 50          	mov    %eax,0x50(%esp)
}
  104b18:	83 c4 3c             	add    $0x3c,%esp
    putch("0123456789abcdef"[num % base], putdat);
  104b1b:	89 f0                	mov    %esi,%eax
}
  104b1d:	5b                   	pop    %ebx
  104b1e:	5e                   	pop    %esi
  104b1f:	5f                   	pop    %edi
  104b20:	5d                   	pop    %ebp
    putch("0123456789abcdef"[num % base], putdat);
  104b21:	ff e0                	jmp    *%eax
  104b23:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        printnum(putch, putdat, num / base, base, width - 1, padc);
  104b28:	83 ec 0c             	sub    $0xc,%esp
  104b2b:	55                   	push   %ebp
  104b2c:	53                   	push   %ebx
  104b2d:	50                   	push   %eax
  104b2e:	83 ec 08             	sub    $0x8,%esp
  104b31:	ff 74 24 34          	push   0x34(%esp)
  104b35:	ff 74 24 34          	push   0x34(%esp)
  104b39:	ff 74 24 34          	push   0x34(%esp)
  104b3d:	ff 74 24 34          	push   0x34(%esp)
  104b41:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
  104b45:	e8 36 78 00 00       	call   10c380 <__udivdi3>
  104b4a:	83 c4 18             	add    $0x18,%esp
  104b4d:	52                   	push   %edx
  104b4e:	89 fa                	mov    %edi,%edx
  104b50:	50                   	push   %eax
  104b51:	89 f0                	mov    %esi,%eax
  104b53:	e8 28 ff ff ff       	call   104a80 <printnum>
  104b58:	83 c4 20             	add    $0x20,%esp
  104b5b:	eb 92                	jmp    104aef <printnum+0x6f>
  104b5d:	8d 76 00             	lea    0x0(%esi),%esi

00104b60 <vprintfmt>:
    else
        return va_arg(*ap, int);
}

void vprintfmt(putch_t putch, void *putdat, const char *fmt, va_list ap)
{
  104b60:	e8 35 b8 ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  104b65:	05 8f 24 01 00       	add    $0x1248f,%eax
  104b6a:	55                   	push   %ebp
  104b6b:	57                   	push   %edi
  104b6c:	56                   	push   %esi
  104b6d:	53                   	push   %ebx
  104b6e:	83 ec 2c             	sub    $0x2c,%esp
  104b71:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  104b75:	8b 7c 24 44          	mov    0x44(%esp),%edi
  104b79:	89 44 24 0c          	mov    %eax,0xc(%esp)
    unsigned long long num;
    int base, lflag, width, precision, altflag;
    char padc;

    while (1) {
        while ((ch = *(unsigned char *) fmt++) != '%') {
  104b7d:	8b 44 24 48          	mov    0x48(%esp),%eax
  104b81:	8d 58 01             	lea    0x1(%eax),%ebx
  104b84:	0f b6 00             	movzbl (%eax),%eax
  104b87:	83 f8 25             	cmp    $0x25,%eax
  104b8a:	75 1a                	jne    104ba6 <vprintfmt+0x46>
  104b8c:	eb 2a                	jmp    104bb8 <vprintfmt+0x58>
  104b8e:	66 90                	xchg   %ax,%ax
            if (ch == '\0')
                return;
            putch(ch, putdat);
  104b90:	83 ec 08             	sub    $0x8,%esp
        while ((ch = *(unsigned char *) fmt++) != '%') {
  104b93:	83 c3 01             	add    $0x1,%ebx
            putch(ch, putdat);
  104b96:	57                   	push   %edi
  104b97:	50                   	push   %eax
  104b98:	ff d5                	call   *%ebp
        while ((ch = *(unsigned char *) fmt++) != '%') {
  104b9a:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
  104b9e:	83 c4 10             	add    $0x10,%esp
  104ba1:	83 f8 25             	cmp    $0x25,%eax
  104ba4:	74 12                	je     104bb8 <vprintfmt+0x58>
            if (ch == '\0')
  104ba6:	85 c0                	test   %eax,%eax
  104ba8:	75 e6                	jne    104b90 <vprintfmt+0x30>
            for (fmt--; fmt[-1] != '%'; fmt--)
                /* do nothing */ ;
            break;
        }
    }
}
  104baa:	83 c4 2c             	add    $0x2c,%esp
  104bad:	5b                   	pop    %ebx
  104bae:	5e                   	pop    %esi
  104baf:	5f                   	pop    %edi
  104bb0:	5d                   	pop    %ebp
  104bb1:	c3                   	ret
  104bb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        precision = -1;
  104bb8:	be ff ff ff ff       	mov    $0xffffffff,%esi
        padc = ' ';
  104bbd:	c6 44 24 10 20       	movb   $0x20,0x10(%esp)
        width = -1;
  104bc2:	ba ff ff ff ff       	mov    $0xffffffff,%edx
        altflag = 0;
  104bc7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  104bce:	00 
        lflag = 0;
  104bcf:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  104bd6:	00 
  104bd7:	89 74 24 14          	mov    %esi,0x14(%esp)
  104bdb:	89 7c 24 44          	mov    %edi,0x44(%esp)
        switch (ch = *(unsigned char *) fmt++) {
  104bdf:	0f b6 0b             	movzbl (%ebx),%ecx
  104be2:	8d 43 01             	lea    0x1(%ebx),%eax
  104be5:	89 44 24 48          	mov    %eax,0x48(%esp)
  104be9:	8d 41 dd             	lea    -0x23(%ecx),%eax
  104bec:	3c 55                	cmp    $0x55,%al
  104bee:	77 18                	ja     104c08 <.L19>
  104bf0:	8b 74 24 0c          	mov    0xc(%esp),%esi
  104bf4:	0f b6 c0             	movzbl %al,%eax
  104bf7:	8b bc 86 04 7e ff ff 	mov    -0x81fc(%esi,%eax,4),%edi
  104bfe:	01 f7                	add    %esi,%edi
  104c00:	ff e7                	jmp    *%edi
  104c02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00104c08 <.L19>:
            putch('%', putdat);
  104c08:	8b 7c 24 44          	mov    0x44(%esp),%edi
  104c0c:	83 ec 08             	sub    $0x8,%esp
  104c0f:	57                   	push   %edi
  104c10:	6a 25                	push   $0x25
  104c12:	ff d5                	call   *%ebp
            for (fmt--; fmt[-1] != '%'; fmt--)
  104c14:	83 c4 10             	add    $0x10,%esp
  104c17:	80 7b ff 25          	cmpb   $0x25,-0x1(%ebx)
  104c1b:	89 5c 24 48          	mov    %ebx,0x48(%esp)
  104c1f:	0f 84 58 ff ff ff    	je     104b7d <vprintfmt+0x1d>
  104c25:	89 d8                	mov    %ebx,%eax
  104c27:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  104c2e:	00 
  104c2f:	90                   	nop
  104c30:	83 e8 01             	sub    $0x1,%eax
  104c33:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  104c37:	75 f7                	jne    104c30 <.L19+0x28>
  104c39:	89 44 24 48          	mov    %eax,0x48(%esp)
  104c3d:	e9 3b ff ff ff       	jmp    104b7d <vprintfmt+0x1d>
  104c42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00104c48 <.L28>:
                ch = *fmt;
  104c48:	0f be 43 01          	movsbl 0x1(%ebx),%eax
                precision = precision * 10 + ch - '0';
  104c4c:	8d 71 d0             	lea    -0x30(%ecx),%esi
        switch (ch = *(unsigned char *) fmt++) {
  104c4f:	8b 5c 24 48          	mov    0x48(%esp),%ebx
                precision = precision * 10 + ch - '0';
  104c53:	89 74 24 14          	mov    %esi,0x14(%esp)
                if (ch < '0' || ch > '9')
  104c57:	8d 48 d0             	lea    -0x30(%eax),%ecx
  104c5a:	83 f9 09             	cmp    $0x9,%ecx
  104c5d:	77 26                	ja     104c85 <.L28+0x3d>
        switch (ch = *(unsigned char *) fmt++) {
  104c5f:	8b 7c 24 44          	mov    0x44(%esp),%edi
  104c63:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
                precision = precision * 10 + ch - '0';
  104c68:	8d 0c b6             	lea    (%esi,%esi,4),%ecx
            for (precision = 0;; ++fmt) {
  104c6b:	83 c3 01             	add    $0x1,%ebx
                precision = precision * 10 + ch - '0';
  104c6e:	8d 74 48 d0          	lea    -0x30(%eax,%ecx,2),%esi
                ch = *fmt;
  104c72:	0f be 03             	movsbl (%ebx),%eax
                if (ch < '0' || ch > '9')
  104c75:	8d 48 d0             	lea    -0x30(%eax),%ecx
  104c78:	83 f9 09             	cmp    $0x9,%ecx
  104c7b:	76 eb                	jbe    104c68 <.L28+0x20>
  104c7d:	89 74 24 14          	mov    %esi,0x14(%esp)
  104c81:	89 7c 24 44          	mov    %edi,0x44(%esp)
            if (width < 0)
  104c85:	85 d2                	test   %edx,%edx
  104c87:	0f 89 52 ff ff ff    	jns    104bdf <vprintfmt+0x7f>
                width = precision, precision = -1;
  104c8d:	8b 54 24 14          	mov    0x14(%esp),%edx
  104c91:	c7 44 24 14 ff ff ff 	movl   $0xffffffff,0x14(%esp)
  104c98:	ff 
  104c99:	e9 41 ff ff ff       	jmp    104bdf <vprintfmt+0x7f>

00104c9e <.L24>:
            putch('0', putdat);
  104c9e:	8b 7c 24 44          	mov    0x44(%esp),%edi
  104ca2:	89 54 24 08          	mov    %edx,0x8(%esp)
  104ca6:	83 ec 08             	sub    $0x8,%esp
  104ca9:	57                   	push   %edi
  104caa:	6a 30                	push   $0x30
  104cac:	ff d5                	call   *%ebp
            putch('x', putdat);
  104cae:	5b                   	pop    %ebx
  104caf:	5e                   	pop    %esi
  104cb0:	57                   	push   %edi
  104cb1:	6a 78                	push   $0x78
            num = (unsigned long long) (uintptr_t) va_arg(ap, void *);
  104cb3:	31 f6                	xor    %esi,%esi
            putch('x', putdat);
  104cb5:	ff d5                	call   *%ebp
            num = (unsigned long long) (uintptr_t) va_arg(ap, void *);
  104cb7:	8b 44 24 5c          	mov    0x5c(%esp),%eax
            goto number;
  104cbb:	8b 54 24 18          	mov    0x18(%esp),%edx
  104cbf:	b9 10 00 00 00       	mov    $0x10,%ecx
            num = (unsigned long long) (uintptr_t) va_arg(ap, void *);
  104cc4:	8b 18                	mov    (%eax),%ebx
  104cc6:	83 c0 04             	add    $0x4,%eax
            goto number;
  104cc9:	83 c4 10             	add    $0x10,%esp
            num = (unsigned long long) (uintptr_t) va_arg(ap, void *);
  104ccc:	89 44 24 4c          	mov    %eax,0x4c(%esp)
            printnum(putch, putdat, num, base, width, padc);
  104cd0:	83 ec 0c             	sub    $0xc,%esp
  104cd3:	0f be 44 24 1c       	movsbl 0x1c(%esp),%eax
  104cd8:	50                   	push   %eax
  104cd9:	89 e8                	mov    %ebp,%eax
  104cdb:	52                   	push   %edx
  104cdc:	89 fa                	mov    %edi,%edx
  104cde:	51                   	push   %ecx
  104cdf:	56                   	push   %esi
  104ce0:	53                   	push   %ebx
  104ce1:	e8 9a fd ff ff       	call   104a80 <printnum>
            break;
  104ce6:	83 c4 20             	add    $0x20,%esp
  104ce9:	e9 8f fe ff ff       	jmp    104b7d <vprintfmt+0x1d>

00104cee <.L32>:
            altflag = 1;
  104cee:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  104cf5:	00 
        switch (ch = *(unsigned char *) fmt++) {
  104cf6:	8b 5c 24 48          	mov    0x48(%esp),%ebx
            goto reswitch;
  104cfa:	e9 e0 fe ff ff       	jmp    104bdf <vprintfmt+0x7f>

00104cff <.L31>:
            putch(ch, putdat);
  104cff:	8b 7c 24 44          	mov    0x44(%esp),%edi
  104d03:	83 ec 08             	sub    $0x8,%esp
  104d06:	57                   	push   %edi
  104d07:	6a 25                	push   $0x25
  104d09:	ff d5                	call   *%ebp
            break;
  104d0b:	83 c4 10             	add    $0x10,%esp
  104d0e:	e9 6a fe ff ff       	jmp    104b7d <vprintfmt+0x1d>

00104d13 <.L30>:
            precision = va_arg(ap, int);
  104d13:	8b 44 24 4c          	mov    0x4c(%esp),%eax
        switch (ch = *(unsigned char *) fmt++) {
  104d17:	8b 5c 24 48          	mov    0x48(%esp),%ebx
            precision = va_arg(ap, int);
  104d1b:	8b 00                	mov    (%eax),%eax
  104d1d:	89 44 24 14          	mov    %eax,0x14(%esp)
  104d21:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  104d25:	83 c0 04             	add    $0x4,%eax
  104d28:	89 44 24 4c          	mov    %eax,0x4c(%esp)
            goto process_precision;
  104d2c:	e9 54 ff ff ff       	jmp    104c85 <.L28+0x3d>

00104d31 <.L29>:
            if (width < 0)
  104d31:	31 c0                	xor    %eax,%eax
  104d33:	85 d2                	test   %edx,%edx
        switch (ch = *(unsigned char *) fmt++) {
  104d35:	8b 5c 24 48          	mov    0x48(%esp),%ebx
            if (width < 0)
  104d39:	0f 48 d0             	cmovs  %eax,%edx
            goto reswitch;
  104d3c:	e9 9e fe ff ff       	jmp    104bdf <vprintfmt+0x7f>

00104d41 <.L23>:
            if ((p = va_arg(ap, char *)) == NULL)
  104d41:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  104d45:	8b 74 24 14          	mov    0x14(%esp),%esi
  104d49:	8b 7c 24 44          	mov    0x44(%esp),%edi
  104d4d:	83 c0 04             	add    $0x4,%eax
            if (width > 0 && padc != '-')
  104d50:	85 d2                	test   %edx,%edx
            if ((p = va_arg(ap, char *)) == NULL)
  104d52:	89 44 24 14          	mov    %eax,0x14(%esp)
  104d56:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  104d5a:	8b 18                	mov    (%eax),%ebx
            if (width > 0 && padc != '-')
  104d5c:	0f 9f c0             	setg   %al
  104d5f:	80 7c 24 10 2d       	cmpb   $0x2d,0x10(%esp)
  104d64:	0f 95 c1             	setne  %cl
            if ((p = va_arg(ap, char *)) == NULL)
  104d67:	89 5c 24 18          	mov    %ebx,0x18(%esp)
            if (width > 0 && padc != '-')
  104d6b:	21 c8                	and    %ecx,%eax
            if ((p = va_arg(ap, char *)) == NULL)
  104d6d:	85 db                	test   %ebx,%ebx
  104d6f:	0f 84 c8 01 00 00    	je     104f3d <.L17+0xe>
            if (width > 0 && padc != '-')
  104d75:	84 c0                	test   %al,%al
  104d77:	0f 85 eb 01 00 00    	jne    104f68 <.L17+0x39>
                 (ch = *p++) != '\0' && (precision < 0 || --precision >= 0);
  104d7d:	89 d8                	mov    %ebx,%eax
  104d7f:	8d 5b 01             	lea    0x1(%ebx),%ebx
  104d82:	0f be 08             	movsbl (%eax),%ecx
  104d85:	89 c8                	mov    %ecx,%eax
  104d87:	85 c9                	test   %ecx,%ecx
  104d89:	0f 84 19 01 00 00    	je     104ea8 <.L25+0x14>
  104d8f:	89 7c 24 44          	mov    %edi,0x44(%esp)
  104d93:	89 f7                	mov    %esi,%edi
  104d95:	89 de                	mov    %ebx,%esi
  104d97:	89 d3                	mov    %edx,%ebx
  104d99:	eb 2f                	jmp    104dca <.L23+0x89>
  104d9b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
                if (altflag && (ch < ' ' || ch > '~'))
  104da0:	83 e8 20             	sub    $0x20,%eax
  104da3:	83 f8 5e             	cmp    $0x5e,%eax
  104da6:	76 37                	jbe    104ddf <.L23+0x9e>
                    putch('?', putdat);
  104da8:	83 ec 08             	sub    $0x8,%esp
  104dab:	ff 74 24 4c          	push   0x4c(%esp)
  104daf:	6a 3f                	push   $0x3f
  104db1:	ff d5                	call   *%ebp
  104db3:	83 c4 10             	add    $0x10,%esp
                 (ch = *p++) != '\0' && (precision < 0 || --precision >= 0);
  104db6:	0f be 06             	movsbl (%esi),%eax
  104db9:	83 c6 01             	add    $0x1,%esi
                 width--)
  104dbc:	83 eb 01             	sub    $0x1,%ebx
                 (ch = *p++) != '\0' && (precision < 0 || --precision >= 0);
  104dbf:	0f be c8             	movsbl %al,%ecx
  104dc2:	85 c9                	test   %ecx,%ecx
  104dc4:	0f 84 d8 00 00 00    	je     104ea2 <.L25+0xe>
  104dca:	85 ff                	test   %edi,%edi
  104dcc:	78 09                	js     104dd7 <.L23+0x96>
  104dce:	83 ef 01             	sub    $0x1,%edi
  104dd1:	0f 82 cb 00 00 00    	jb     104ea2 <.L25+0xe>
                if (altflag && (ch < ' ' || ch > '~'))
  104dd7:	8b 54 24 08          	mov    0x8(%esp),%edx
  104ddb:	85 d2                	test   %edx,%edx
  104ddd:	75 c1                	jne    104da0 <.L23+0x5f>
                    putch(ch, putdat);
  104ddf:	83 ec 08             	sub    $0x8,%esp
  104de2:	ff 74 24 4c          	push   0x4c(%esp)
  104de6:	51                   	push   %ecx
  104de7:	ff d5                	call   *%ebp
  104de9:	83 c4 10             	add    $0x10,%esp
  104dec:	eb c8                	jmp    104db6 <.L23+0x75>

00104dee <.L22>:
    if (lflag >= 2)
  104dee:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
  104df3:	8b 7c 24 44          	mov    0x44(%esp),%edi
        return va_arg(*ap, unsigned long long);
  104df7:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    if (lflag >= 2)
  104dfb:	0f 8f cc 00 00 00    	jg     104ecd <.L25+0x39>
        return va_arg(*ap, unsigned long);
  104e01:	8b 74 24 4c          	mov    0x4c(%esp),%esi
            precision = va_arg(ap, int);
  104e05:	83 c0 04             	add    $0x4,%eax
        return va_arg(*ap, unsigned long);
  104e08:	b9 0a 00 00 00       	mov    $0xa,%ecx
  104e0d:	8b 1e                	mov    (%esi),%ebx
  104e0f:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  104e13:	31 f6                	xor    %esi,%esi
  104e15:	e9 b6 fe ff ff       	jmp    104cd0 <.L24+0x32>

00104e1a <.L20>:
    if (lflag >= 2)
  104e1a:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
  104e1f:	8b 7c 24 44          	mov    0x44(%esp),%edi
        return va_arg(*ap, unsigned long long);
  104e23:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    if (lflag >= 2)
  104e27:	0f 8f ae 00 00 00    	jg     104edb <.L25+0x47>
        return va_arg(*ap, unsigned long);
  104e2d:	8b 74 24 4c          	mov    0x4c(%esp),%esi
            precision = va_arg(ap, int);
  104e31:	83 c0 04             	add    $0x4,%eax
        return va_arg(*ap, unsigned long);
  104e34:	b9 10 00 00 00       	mov    $0x10,%ecx
  104e39:	8b 1e                	mov    (%esi),%ebx
  104e3b:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  104e3f:	31 f6                	xor    %esi,%esi
  104e41:	e9 8a fe ff ff       	jmp    104cd0 <.L24+0x32>

00104e46 <.L27>:
            putch(va_arg(ap, int), putdat);
  104e46:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  104e4a:	8b 7c 24 44          	mov    0x44(%esp),%edi
  104e4e:	83 ec 08             	sub    $0x8,%esp
  104e51:	57                   	push   %edi
  104e52:	8d 58 04             	lea    0x4(%eax),%ebx
  104e55:	8b 44 24 58          	mov    0x58(%esp),%eax
  104e59:	ff 30                	push   (%eax)
  104e5b:	ff d5                	call   *%ebp
  104e5d:	89 5c 24 5c          	mov    %ebx,0x5c(%esp)
            break;
  104e61:	83 c4 10             	add    $0x10,%esp
  104e64:	e9 14 fd ff ff       	jmp    104b7d <vprintfmt+0x1d>

00104e69 <.L26>:
        return va_arg(*ap, long long);
  104e69:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    if (lflag >= 2)
  104e6d:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
  104e72:	8b 7c 24 44          	mov    0x44(%esp),%edi
        return va_arg(*ap, long long);
  104e76:	8b 18                	mov    (%eax),%ebx
    if (lflag >= 2)
  104e78:	7f 77                	jg     104ef1 <.L25+0x5d>
        return va_arg(*ap, long);
  104e7a:	83 c0 04             	add    $0x4,%eax
  104e7d:	89 de                	mov    %ebx,%esi
  104e7f:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  104e83:	c1 fe 1f             	sar    $0x1f,%esi
            if ((long long) num < 0) {
  104e86:	85 f6                	test   %esi,%esi
  104e88:	78 73                	js     104efd <.L25+0x69>
        return va_arg(*ap, unsigned long long);
  104e8a:	b9 0a 00 00 00       	mov    $0xa,%ecx
  104e8f:	e9 3c fe ff ff       	jmp    104cd0 <.L24+0x32>

00104e94 <.L25>:
            lflag++;
  104e94:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
        switch (ch = *(unsigned char *) fmt++) {
  104e99:	8b 5c 24 48          	mov    0x48(%esp),%ebx
            goto reswitch;
  104e9d:	e9 3d fd ff ff       	jmp    104bdf <vprintfmt+0x7f>
  104ea2:	8b 7c 24 44          	mov    0x44(%esp),%edi
  104ea6:	89 da                	mov    %ebx,%edx
            for (; width > 0; width--)
  104ea8:	85 d2                	test   %edx,%edx
  104eaa:	7e 14                	jle    104ec0 <.L25+0x2c>
  104eac:	89 d3                	mov    %edx,%ebx
  104eae:	66 90                	xchg   %ax,%ax
                putch(' ', putdat);
  104eb0:	83 ec 08             	sub    $0x8,%esp
  104eb3:	57                   	push   %edi
  104eb4:	6a 20                	push   $0x20
  104eb6:	ff d5                	call   *%ebp
            for (; width > 0; width--)
  104eb8:	83 c4 10             	add    $0x10,%esp
  104ebb:	83 eb 01             	sub    $0x1,%ebx
  104ebe:	75 f0                	jne    104eb0 <.L25+0x1c>
            if ((p = va_arg(ap, char *)) == NULL)
  104ec0:	8b 44 24 14          	mov    0x14(%esp),%eax
  104ec4:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  104ec8:	e9 b0 fc ff ff       	jmp    104b7d <vprintfmt+0x1d>
        return va_arg(*ap, unsigned long long);
  104ecd:	8b 18                	mov    (%eax),%ebx
  104ecf:	8b 70 04             	mov    0x4(%eax),%esi
  104ed2:	83 c0 08             	add    $0x8,%eax
  104ed5:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  104ed9:	eb af                	jmp    104e8a <.L26+0x21>
  104edb:	8b 18                	mov    (%eax),%ebx
  104edd:	8b 70 04             	mov    0x4(%eax),%esi
  104ee0:	83 c0 08             	add    $0x8,%eax
  104ee3:	b9 10 00 00 00       	mov    $0x10,%ecx
  104ee8:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  104eec:	e9 df fd ff ff       	jmp    104cd0 <.L24+0x32>
        return va_arg(*ap, long long);
  104ef1:	8b 70 04             	mov    0x4(%eax),%esi
  104ef4:	83 c0 08             	add    $0x8,%eax
  104ef7:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  104efb:	eb 89                	jmp    104e86 <.L26+0x1d>
  104efd:	89 54 24 08          	mov    %edx,0x8(%esp)
                putch('-', putdat);
  104f01:	83 ec 08             	sub    $0x8,%esp
  104f04:	57                   	push   %edi
  104f05:	6a 2d                	push   $0x2d
  104f07:	ff d5                	call   *%ebp
                num = -(long long) num;
  104f09:	f7 db                	neg    %ebx
  104f0b:	b9 0a 00 00 00       	mov    $0xa,%ecx
  104f10:	83 d6 00             	adc    $0x0,%esi
  104f13:	8b 54 24 18          	mov    0x18(%esp),%edx
  104f17:	83 c4 10             	add    $0x10,%esp
  104f1a:	f7 de                	neg    %esi
  104f1c:	e9 af fd ff ff       	jmp    104cd0 <.L24+0x32>

00104f21 <.L60>:
        switch (ch = *(unsigned char *) fmt++) {
  104f21:	c6 44 24 10 30       	movb   $0x30,0x10(%esp)
  104f26:	8b 5c 24 48          	mov    0x48(%esp),%ebx
  104f2a:	e9 b0 fc ff ff       	jmp    104bdf <vprintfmt+0x7f>

00104f2f <.L17>:
            padc = '-';
  104f2f:	c6 44 24 10 2d       	movb   $0x2d,0x10(%esp)
        switch (ch = *(unsigned char *) fmt++) {
  104f34:	8b 5c 24 48          	mov    0x48(%esp),%ebx
  104f38:	e9 a2 fc ff ff       	jmp    104bdf <vprintfmt+0x7f>
            if (width > 0 && padc != '-')
  104f3d:	84 c0                	test   %al,%al
  104f3f:	0f 85 83 00 00 00    	jne    104fc8 <.L17+0x99>
                 (ch = *p++) != '\0' && (precision < 0 || --precision >= 0);
  104f45:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104f49:	89 7c 24 44          	mov    %edi,0x44(%esp)
  104f4d:	b9 28 00 00 00       	mov    $0x28,%ecx
  104f52:	89 f7                	mov    %esi,%edi
  104f54:	8d 98 4f 64 ff ff    	lea    -0x9bb1(%eax),%ebx
  104f5a:	b8 28 00 00 00       	mov    $0x28,%eax
  104f5f:	89 de                	mov    %ebx,%esi
  104f61:	89 d3                	mov    %edx,%ebx
  104f63:	e9 62 fe ff ff       	jmp    104dca <.L23+0x89>
  104f68:	89 54 24 1c          	mov    %edx,0x1c(%esp)
                for (width -= strnlen(p, precision); width > 0; width--)
  104f6c:	83 ec 08             	sub    $0x8,%esp
  104f6f:	56                   	push   %esi
  104f70:	ff 74 24 24          	push   0x24(%esp)
  104f74:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  104f78:	e8 c3 f5 ff ff       	call   104540 <strnlen>
  104f7d:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  104f81:	83 c4 10             	add    $0x10,%esp
  104f84:	29 c2                	sub    %eax,%edx
  104f86:	85 d2                	test   %edx,%edx
  104f88:	0f 8e 83 00 00 00    	jle    105011 <.L17+0xe2>
                    putch(padc, putdat);
  104f8e:	0f be 5c 24 10       	movsbl 0x10(%esp),%ebx
  104f93:	89 74 24 10          	mov    %esi,0x10(%esp)
  104f97:	89 d6                	mov    %edx,%esi
  104f99:	83 ec 08             	sub    $0x8,%esp
  104f9c:	57                   	push   %edi
  104f9d:	53                   	push   %ebx
  104f9e:	ff d5                	call   *%ebp
                for (width -= strnlen(p, precision); width > 0; width--)
  104fa0:	83 c4 10             	add    $0x10,%esp
  104fa3:	83 ee 01             	sub    $0x1,%esi
  104fa6:	75 f1                	jne    104f99 <.L17+0x6a>
                 (ch = *p++) != '\0' && (precision < 0 || --precision >= 0);
  104fa8:	8b 44 24 18          	mov    0x18(%esp),%eax
  104fac:	89 f2                	mov    %esi,%edx
  104fae:	8b 74 24 10          	mov    0x10(%esp),%esi
  104fb2:	8d 58 01             	lea    0x1(%eax),%ebx
  104fb5:	0f be 00             	movsbl (%eax),%eax
  104fb8:	0f be c8             	movsbl %al,%ecx
  104fbb:	85 c9                	test   %ecx,%ecx
  104fbd:	0f 85 cc fd ff ff    	jne    104d8f <.L23+0x4e>
  104fc3:	e9 f8 fe ff ff       	jmp    104ec0 <.L25+0x2c>
  104fc8:	89 54 24 1c          	mov    %edx,0x1c(%esp)
                for (width -= strnlen(p, precision); width > 0; width--)
  104fcc:	83 ec 08             	sub    $0x8,%esp
  104fcf:	56                   	push   %esi
  104fd0:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  104fd4:	8d 8b 4e 64 ff ff    	lea    -0x9bb2(%ebx),%ecx
  104fda:	51                   	push   %ecx
  104fdb:	89 4c 24 28          	mov    %ecx,0x28(%esp)
  104fdf:	e8 5c f5 ff ff       	call   104540 <strnlen>
  104fe4:	8b 54 24 2c          	mov    0x2c(%esp),%edx
                 (ch = *p++) != '\0' && (precision < 0 || --precision >= 0);
  104fe8:	b9 28 00 00 00       	mov    $0x28,%ecx
                for (width -= strnlen(p, precision); width > 0; width--)
  104fed:	83 c4 10             	add    $0x10,%esp
  104ff0:	29 c2                	sub    %eax,%edx
                 (ch = *p++) != '\0' && (precision < 0 || --precision >= 0);
  104ff2:	b8 28 00 00 00       	mov    $0x28,%eax
                for (width -= strnlen(p, precision); width > 0; width--)
  104ff7:	85 d2                	test   %edx,%edx
  104ff9:	7f 93                	jg     104f8e <.L17+0x5f>
                 (ch = *p++) != '\0' && (precision < 0 || --precision >= 0);
  104ffb:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  104fff:	89 7c 24 44          	mov    %edi,0x44(%esp)
  105003:	89 f7                	mov    %esi,%edi
  105005:	83 c3 01             	add    $0x1,%ebx
  105008:	89 de                	mov    %ebx,%esi
  10500a:	89 d3                	mov    %edx,%ebx
  10500c:	e9 b9 fd ff ff       	jmp    104dca <.L23+0x89>
  105011:	8b 44 24 18          	mov    0x18(%esp),%eax
  105015:	0f be 08             	movsbl (%eax),%ecx
  105018:	89 c8                	mov    %ecx,%eax
  10501a:	85 c9                	test   %ecx,%ecx
  10501c:	75 dd                	jne    104ffb <.L17+0xcc>
  10501e:	e9 9d fe ff ff       	jmp    104ec0 <.L25+0x2c>
  105023:	66 90                	xchg   %ax,%ax
  105025:	66 90                	xchg   %ax,%ax
  105027:	66 90                	xchg   %ax,%ax
  105029:	66 90                	xchg   %ax,%ax
  10502b:	66 90                	xchg   %ax,%ax
  10502d:	66 90                	xchg   %ax,%ax
  10502f:	90                   	nop

00105030 <kstack_switch>:
#include "seg.h"

#define offsetof(type, member) __builtin_offsetof(type, member)

void kstack_switch(uint32_t pid)
{
  105030:	56                   	push   %esi
  105031:	53                   	push   %ebx
  105032:	e8 6b b3 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105037:	81 c3 bd 1f 01 00    	add    $0x11fbd,%ebx
  10503d:	83 ec 04             	sub    $0x4,%esp
    int cpu_idx = get_pcpu_idx();
  105040:	e8 1b 12 00 00       	call   106260 <get_pcpu_idx>
    struct kstack *ks = (struct kstack *) get_pcpu_kstack_pointer(cpu_idx);
  105045:	83 ec 0c             	sub    $0xc,%esp
  105048:	50                   	push   %eax
  105049:	e8 72 12 00 00       	call   1062c0 <get_pcpu_kstack_pointer>

    /*
     * Switch to the new TSS.
     */
    ks->tss.ts_esp0 = (uint32_t) proc_kstack[pid].kstack_hi;
  10504e:	8b 74 24 20          	mov    0x20(%esp),%esi
  105052:	c7 c1 00 20 1a 00    	mov    $0x1a2000,%ecx
  105058:	8d 56 01             	lea    0x1(%esi),%edx
  10505b:	c1 e2 0c             	shl    $0xc,%edx
  10505e:	8d 34 0a             	lea    (%edx,%ecx,1),%esi
    ks->tss.ts_ss0 = CPU_GDT_KDATA;
    ks->gdt[CPU_GDT_TSS >> 3] =
        SEGDESC16(STS_T32A, (uint32_t) &proc_kstack[pid].tss, sizeof(tss_t) - 1, 0);
  105061:	8d 94 0a 30 f0 ff ff 	lea    -0xfd0(%edx,%ecx,1),%edx
    ks->gdt[CPU_GDT_TSS >> 3] =
  105068:	b9 eb 00 00 00       	mov    $0xeb,%ecx
    ks->tss.ts_esp0 = (uint32_t) proc_kstack[pid].kstack_hi;
  10506d:	89 70 34             	mov    %esi,0x34(%eax)
    ks->tss.ts_ss0 = CPU_GDT_KDATA;
  105070:	be 10 00 00 00       	mov    $0x10,%esi
    ks->gdt[CPU_GDT_TSS >> 3] =
  105075:	66 89 48 28          	mov    %cx,0x28(%eax)
        SEGDESC16(STS_T32A, (uint32_t) &proc_kstack[pid].tss, sizeof(tss_t) - 1, 0);
  105079:	89 d1                	mov    %edx,%ecx
    ks->tss.ts_ss0 = CPU_GDT_KDATA;
  10507b:	66 89 70 38          	mov    %si,0x38(%eax)
        SEGDESC16(STS_T32A, (uint32_t) &proc_kstack[pid].tss, sizeof(tss_t) - 1, 0);
  10507f:	c1 e9 10             	shr    $0x10,%ecx
    ks->gdt[CPU_GDT_TSS >> 3] =
  105082:	be 89 40 00 00       	mov    $0x4089,%esi
  105087:	66 89 50 2a          	mov    %dx,0x2a(%eax)
        SEGDESC16(STS_T32A, (uint32_t) &proc_kstack[pid].tss, sizeof(tss_t) - 1, 0);
  10508b:	c1 ea 18             	shr    $0x18,%edx
    ks->gdt[CPU_GDT_TSS >> 3] =
  10508e:	66 89 70 2d          	mov    %si,0x2d(%eax)
  105092:	88 48 2c             	mov    %cl,0x2c(%eax)
  105095:	88 50 2f             	mov    %dl,0x2f(%eax)
    ks->gdt[CPU_GDT_TSS >> 3].sd_s = 0;
    ltr(CPU_GDT_TSS);
  105098:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  10509f:	e8 dc 04 00 00       	call   105580 <ltr>
}
  1050a4:	83 c4 14             	add    $0x14,%esp
  1050a7:	5b                   	pop    %ebx
  1050a8:	5e                   	pop    %esi
  1050a9:	c3                   	ret
  1050aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001050b0 <seg_init>:

void seg_init(int cpu_idx)
{
  1050b0:	55                   	push   %ebp
  1050b1:	57                   	push   %edi
  1050b2:	56                   	push   %esi
  1050b3:	53                   	push   %ebx
  1050b4:	e8 e9 b2 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1050b9:	81 c3 3b 1f 01 00    	add    $0x11f3b,%ebx
  1050bf:	83 ec 1c             	sub    $0x1c,%esp
  1050c2:	8b 7c 24 30          	mov    0x30(%esp),%edi
    /* clear BSS */
    if (cpu_idx == 0) {
  1050c6:	85 ff                	test   %edi,%edi
  1050c8:	0f 84 0a 01 00 00    	je     1051d8 <seg_init+0x128>
  1050ce:	c7 c6 00 20 1e 00    	mov    $0x1e2000,%esi
        memzero(edata, ((uint8_t *) &bsp_kstack[0]) - edata);
        memzero(((uint8_t *) &bsp_kstack[0]) + 4096, end - ((uint8_t *) &bsp_kstack[0]) - 4096);
    }

    /* setup GDT */
    bsp_kstack[cpu_idx].gdt[0] = SEGDESC_NULL;
  1050d4:	89 fa                	mov    %edi,%edx
  1050d6:	8d 4f 01             	lea    0x1(%edi),%ecx
  1050d9:	c1 e2 0c             	shl    $0xc,%edx
  1050dc:	c1 e1 0c             	shl    $0xc,%ecx
  1050df:	8d 04 16             	lea    (%esi,%edx,1),%eax
    /* 0x20: user data */
    bsp_kstack[cpu_idx].gdt[CPU_GDT_UDATA >> 3] =
        SEGDESC32(STA_W, 0x00000000, 0xffffffff, 3);

    /* setup TSS */
    bsp_kstack[cpu_idx].tss.ts_esp0 = (uint32_t) bsp_kstack[cpu_idx].kstack_hi;
  1050e2:	8d 2c 0e             	lea    (%esi,%ecx,1),%ebp
    bsp_kstack[cpu_idx].gdt[0] = SEGDESC_NULL;
  1050e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  1050eb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    bsp_kstack[cpu_idx].gdt[CPU_GDT_KCODE >> 3] =
  1050f2:	c7 44 16 08 ff ff 00 	movl   $0xffff,0x8(%esi,%edx,1)
  1050f9:	00 
    bsp_kstack[cpu_idx].gdt[CPU_GDT_KDATA >> 3] =
  1050fa:	c7 44 16 10 ff ff 00 	movl   $0xffff,0x10(%esi,%edx,1)
  105101:	00 
    bsp_kstack[cpu_idx].gdt[CPU_GDT_UCODE >> 3] =
  105102:	c7 44 16 18 ff ff 00 	movl   $0xffff,0x18(%esi,%edx,1)
  105109:	00 
    bsp_kstack[cpu_idx].gdt[CPU_GDT_UDATA >> 3] =
  10510a:	c7 44 16 20 ff ff 00 	movl   $0xffff,0x20(%esi,%edx,1)
  105111:	00 
    bsp_kstack[cpu_idx].gdt[CPU_GDT_KCODE >> 3] =
  105112:	c7 44 16 0c 00 9a cf 	movl   $0xcf9a00,0xc(%esi,%edx,1)
  105119:	00 
    bsp_kstack[cpu_idx].gdt[CPU_GDT_KDATA >> 3] =
  10511a:	c7 44 16 14 00 92 cf 	movl   $0xcf9200,0x14(%esi,%edx,1)
  105121:	00 
    bsp_kstack[cpu_idx].gdt[CPU_GDT_UCODE >> 3] =
  105122:	c7 44 16 1c 00 fa cf 	movl   $0xcffa00,0x1c(%esi,%edx,1)
  105129:	00 
    bsp_kstack[cpu_idx].tss.ts_esp0 = (uint32_t) bsp_kstack[cpu_idx].kstack_hi;
  10512a:	89 68 34             	mov    %ebp,0x34(%eax)
    bsp_kstack[cpu_idx].tss.ts_ss0 = CPU_GDT_KDATA;
  10512d:	bd 10 00 00 00       	mov    $0x10,%ebp
  105132:	66 89 68 38          	mov    %bp,0x38(%eax)
    bsp_kstack[cpu_idx].gdt[CPU_GDT_TSS >> 3] =
        SEGDESC16(STS_T32A, (uint32_t) &bsp_kstack[cpu_idx].tss, sizeof(tss_t) - 1, 0);
  105136:	8d ac 0e 30 f0 ff ff 	lea    -0xfd0(%esi,%ecx,1),%ebp
    bsp_kstack[cpu_idx].gdt[CPU_GDT_UDATA >> 3] =
  10513d:	c7 44 16 24 00 f2 cf 	movl   $0xcff200,0x24(%esi,%edx,1)
  105144:	00 
    bsp_kstack[cpu_idx].gdt[CPU_GDT_TSS >> 3] =
  105145:	ba eb 00 00 00       	mov    $0xeb,%edx
  10514a:	66 89 50 28          	mov    %dx,0x28(%eax)
        SEGDESC16(STS_T32A, (uint32_t) &bsp_kstack[cpu_idx].tss, sizeof(tss_t) - 1, 0);
  10514e:	89 ea                	mov    %ebp,%edx
  105150:	c1 ea 10             	shr    $0x10,%edx
    bsp_kstack[cpu_idx].gdt[CPU_GDT_TSS >> 3] =
  105153:	66 89 68 2a          	mov    %bp,0x2a(%eax)
  105157:	88 50 2c             	mov    %dl,0x2c(%eax)
        SEGDESC16(STS_T32A, (uint32_t) &bsp_kstack[cpu_idx].tss, sizeof(tss_t) - 1, 0);
  10515a:	89 ea                	mov    %ebp,%edx
    bsp_kstack[cpu_idx].gdt[CPU_GDT_TSS >> 3] =
  10515c:	bd 89 40 00 00       	mov    $0x4089,%ebp
        SEGDESC16(STS_T32A, (uint32_t) &bsp_kstack[cpu_idx].tss, sizeof(tss_t) - 1, 0);
  105161:	c1 ea 18             	shr    $0x18,%edx
    bsp_kstack[cpu_idx].gdt[CPU_GDT_TSS >> 3] =
  105164:	66 89 68 2d          	mov    %bp,0x2d(%eax)
  105168:	88 50 2f             	mov    %dl,0x2f(%eax)
    bsp_kstack[cpu_idx].gdt[CPU_GDT_TSS >> 3].sd_s = 0;

    /* other fields */
    /* Set the KSTACK_MAGIC value when we initialize the kstack */
    bsp_kstack[cpu_idx].magic = KSTACK_MAGIC;
  10516b:	c7 80 20 01 00 00 32 	movl   $0x98765432,0x120(%eax)
  105172:	54 76 98 

    pseudodesc_t gdt_desc = {
  105175:	b8 2f 00 00 00       	mov    $0x2f,%eax
  10517a:	66 89 44 24 0a       	mov    %ax,0xa(%esp)
        .pd_lim   = sizeof(bsp_kstack[cpu_idx].gdt) - 1,
        .pd_base  = (uint32_t) bsp_kstack[cpu_idx].gdt
  10517f:	8d 84 0e 00 f0 ff ff 	lea    -0x1000(%esi,%ecx,1),%eax
  105186:	89 44 24 0c          	mov    %eax,0xc(%esp)
    };
    asm volatile ("lgdt %0" :: "m" (gdt_desc));
  10518a:	0f 01 54 24 0a       	lgdtl  0xa(%esp)
    asm volatile ("movw %%ax,%%gs" :: "a" (CPU_GDT_KDATA));
  10518f:	b8 10 00 00 00       	mov    $0x10,%eax
  105194:	8e e8                	mov    %eax,%gs
    asm volatile ("movw %%ax,%%fs" :: "a" (CPU_GDT_KDATA));
  105196:	8e e0                	mov    %eax,%fs
    asm volatile ("movw %%ax,%%es" :: "a" (CPU_GDT_KDATA));
  105198:	8e c0                	mov    %eax,%es
    asm volatile ("movw %%ax,%%ds" :: "a" (CPU_GDT_KDATA));
  10519a:	8e d8                	mov    %eax,%ds
    asm volatile ("movw %%ax,%%ss" :: "a" (CPU_GDT_KDATA));
  10519c:	8e d0                	mov    %eax,%ss
    /* reload %cs */
    asm volatile ("ljmp %0,$1f\n 1:\n" :: "i" (CPU_GDT_KCODE));
  10519e:	ea a5 51 10 00 08 00 	ljmp   $0x8,$0x1051a5

    /*
     * Load a null LDT.
     */
    lldt(0);
  1051a5:	83 ec 0c             	sub    $0xc,%esp
  1051a8:	6a 00                	push   $0x0
  1051aa:	e8 31 02 00 00       	call   1053e0 <lldt>

    /*
     * Load the bootstrap TSS.
     */
    ltr(CPU_GDT_TSS);
  1051af:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  1051b6:	e8 c5 03 00 00       	call   105580 <ltr>

    /*
     * Load IDT.
     */
    extern pseudodesc_t idt_pd;
    asm volatile ("lidt %0" :: "m" (idt_pd));
  1051bb:	c7 c0 00 73 11 00    	mov    $0x117300,%eax
  1051c1:	0f 01 18             	lidtl  (%eax)

    /*
     * Initialize all TSS structures for processes.
     */
    if (cpu_idx == 0) {
  1051c4:	83 c4 10             	add    $0x10,%esp
  1051c7:	85 ff                	test   %edi,%edi
  1051c9:	74 55                	je     105220 <seg_init+0x170>
        memzero(&bsp_kstack[1], sizeof(struct kstack) * 7);
        memzero(proc_kstack, sizeof(struct kstack) * 64);
    }
}
  1051cb:	83 c4 1c             	add    $0x1c,%esp
  1051ce:	5b                   	pop    %ebx
  1051cf:	5e                   	pop    %esi
  1051d0:	5f                   	pop    %edi
  1051d1:	5d                   	pop    %ebp
  1051d2:	c3                   	ret
  1051d3:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        memzero(edata, ((uint8_t *) &bsp_kstack[0]) - edata);
  1051d8:	c7 c6 00 20 1e 00    	mov    $0x1e2000,%esi
  1051de:	c7 c0 d2 f3 19 00    	mov    $0x19f3d2,%eax
  1051e4:	83 ec 08             	sub    $0x8,%esp
  1051e7:	89 f2                	mov    %esi,%edx
  1051e9:	29 c2                	sub    %eax,%edx
  1051eb:	52                   	push   %edx
  1051ec:	50                   	push   %eax
  1051ed:	e8 0e f4 ff ff       	call   104600 <memzero>
        memzero(((uint8_t *) &bsp_kstack[0]) + 4096, end - ((uint8_t *) &bsp_kstack[0]) - 4096);
  1051f2:	58                   	pop    %eax
  1051f3:	c7 c0 c0 c8 e7 00    	mov    $0xe7c8c0,%eax
  1051f9:	5a                   	pop    %edx
  1051fa:	29 f0                	sub    %esi,%eax
  1051fc:	2d 00 10 00 00       	sub    $0x1000,%eax
  105201:	50                   	push   %eax
  105202:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
  105208:	50                   	push   %eax
  105209:	e8 f2 f3 ff ff       	call   104600 <memzero>
  10520e:	83 c4 10             	add    $0x10,%esp
  105211:	e9 be fe ff ff       	jmp    1050d4 <seg_init+0x24>
  105216:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10521d:	00 
  10521e:	66 90                	xchg   %ax,%ax
        memzero(&bsp_kstack[1], sizeof(struct kstack) * 7);
  105220:	83 ec 08             	sub    $0x8,%esp
  105223:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
  105229:	68 00 70 00 00       	push   $0x7000
  10522e:	50                   	push   %eax
  10522f:	e8 cc f3 ff ff       	call   104600 <memzero>
        memzero(proc_kstack, sizeof(struct kstack) * 64);
  105234:	58                   	pop    %eax
  105235:	5a                   	pop    %edx
  105236:	68 00 00 04 00       	push   $0x40000
  10523b:	ff b3 f4 ff ff ff    	push   -0xc(%ebx)
  105241:	e8 ba f3 ff ff       	call   104600 <memzero>
  105246:	83 c4 10             	add    $0x10,%esp
}
  105249:	83 c4 1c             	add    $0x1c,%esp
  10524c:	5b                   	pop    %ebx
  10524d:	5e                   	pop    %esi
  10524e:	5f                   	pop    %edi
  10524f:	5d                   	pop    %ebp
  105250:	c3                   	ret
  105251:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105258:	00 
  105259:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00105260 <seg_init_proc>:

/* initialize the kernel stack for each process */
void seg_init_proc(int cpu_idx, int pid)
{
  105260:	55                   	push   %ebp
        SEGDESC32(STA_W, 0x00000000, 0xffffffff, 3);

    /* setup TSS */
    proc_kstack[pid].tss.ts_esp0 = (uint32_t) proc_kstack[pid].kstack_hi;
    proc_kstack[pid].tss.ts_ss0 = CPU_GDT_KDATA;
    proc_kstack[pid].tss.ts_iomb = offsetof(tss_t, ts_iopm);
  105261:	ba 68 00 00 00       	mov    $0x68,%edx
{
  105266:	57                   	push   %edi
  105267:	56                   	push   %esi
  105268:	53                   	push   %ebx
  105269:	e8 34 b1 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10526e:	81 c3 86 1d 01 00    	add    $0x11d86,%ebx
  105274:	83 ec 14             	sub    $0x14,%esp
  105277:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
    proc_kstack[pid].gdt[0] = SEGDESC_NULL;
  10527b:	89 e8                	mov    %ebp,%eax
  10527d:	83 c5 01             	add    $0x1,%ebp
  105280:	c7 c7 00 20 1a 00    	mov    $0x1a2000,%edi
  105286:	c1 e0 0c             	shl    $0xc,%eax
  105289:	c1 e5 0c             	shl    $0xc,%ebp
  10528c:	8d 34 07             	lea    (%edi,%eax,1),%esi
  10528f:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  105295:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    proc_kstack[pid].gdt[CPU_GDT_KCODE >> 3] =
  10529c:	c7 44 07 08 ff ff 00 	movl   $0xffff,0x8(%edi,%eax,1)
  1052a3:	00 
  1052a4:	c7 44 38 0c 00 9a cf 	movl   $0xcf9a00,0xc(%eax,%edi,1)
  1052ab:	00 
    proc_kstack[pid].gdt[CPU_GDT_KDATA >> 3] =
  1052ac:	c7 44 07 10 ff ff 00 	movl   $0xffff,0x10(%edi,%eax,1)
  1052b3:	00 
  1052b4:	c7 44 38 14 00 92 cf 	movl   $0xcf9200,0x14(%eax,%edi,1)
  1052bb:	00 
    proc_kstack[pid].gdt[CPU_GDT_UCODE >> 3] =
  1052bc:	c7 44 07 18 ff ff 00 	movl   $0xffff,0x18(%edi,%eax,1)
  1052c3:	00 
  1052c4:	c7 44 38 1c 00 fa cf 	movl   $0xcffa00,0x1c(%eax,%edi,1)
  1052cb:	00 
    proc_kstack[pid].gdt[CPU_GDT_UDATA >> 3] =
  1052cc:	c7 44 07 20 ff ff 00 	movl   $0xffff,0x20(%edi,%eax,1)
  1052d3:	00 
  1052d4:	c7 44 38 24 00 f2 cf 	movl   $0xcff200,0x24(%eax,%edi,1)
  1052db:	00 
    proc_kstack[pid].tss.ts_esp0 = (uint32_t) proc_kstack[pid].kstack_hi;
  1052dc:	8d 44 3d 00          	lea    0x0(%ebp,%edi,1),%eax
  1052e0:	89 46 34             	mov    %eax,0x34(%esi)
    proc_kstack[pid].tss.ts_ss0 = CPU_GDT_KDATA;
  1052e3:	b8 10 00 00 00       	mov    $0x10,%eax
  1052e8:	66 89 46 38          	mov    %ax,0x38(%esi)
    memzero (proc_kstack[pid].tss.ts_iopm, sizeof(uint8_t) * 128);
  1052ec:	8d 84 2f 98 f0 ff ff 	lea    -0xf68(%edi,%ebp,1),%eax
    proc_kstack[pid].tss.ts_iomb = offsetof(tss_t, ts_iopm);
  1052f3:	66 89 96 96 00 00 00 	mov    %dx,0x96(%esi)
    memzero (proc_kstack[pid].tss.ts_iopm, sizeof(uint8_t) * 128);
  1052fa:	68 80 00 00 00       	push   $0x80
  1052ff:	50                   	push   %eax
  105300:	e8 fb f2 ff ff       	call   104600 <memzero>
    proc_kstack[pid].tss.ts_iopm[128] = 0xff;

    proc_kstack[pid].gdt[CPU_GDT_TSS >> 3] =
  105305:	bb 89 40 00 00       	mov    $0x4089,%ebx
        SEGDESC16(STS_T32A, (uint32_t) &proc_kstack[pid].tss, sizeof(tss_t) - 1, 0);
  10530a:	8d 84 2f 30 f0 ff ff 	lea    -0xfd0(%edi,%ebp,1),%eax
    proc_kstack[pid].gdt[CPU_GDT_TSS >> 3] =
  105311:	b9 eb 00 00 00       	mov    $0xeb,%ecx
  105316:	66 89 46 2a          	mov    %ax,0x2a(%esi)
        SEGDESC16(STS_T32A, (uint32_t) &proc_kstack[pid].tss, sizeof(tss_t) - 1, 0);
  10531a:	89 c2                	mov    %eax,%edx
  10531c:	c1 e8 18             	shr    $0x18,%eax
    proc_kstack[pid].gdt[CPU_GDT_TSS >> 3] =
  10531f:	88 46 2f             	mov    %al,0x2f(%esi)
    proc_kstack[pid].gdt[CPU_GDT_TSS >> 3].sd_s = 0;

    /* other fields */
    proc_kstack[pid].magic = KSTACK_MAGIC;
    proc_kstack[pid].cpu_idx = cpu_idx;
  105322:	8b 44 24 30          	mov    0x30(%esp),%eax
        SEGDESC16(STS_T32A, (uint32_t) &proc_kstack[pid].tss, sizeof(tss_t) - 1, 0);
  105326:	c1 ea 10             	shr    $0x10,%edx
    proc_kstack[pid].tss.ts_iopm[128] = 0xff;
  105329:	c6 86 18 01 00 00 ff 	movb   $0xff,0x118(%esi)
    proc_kstack[pid].gdt[CPU_GDT_TSS >> 3] =
  105330:	66 89 4e 28          	mov    %cx,0x28(%esi)
  105334:	88 56 2c             	mov    %dl,0x2c(%esi)
  105337:	66 89 5e 2d          	mov    %bx,0x2d(%esi)
    proc_kstack[pid].magic = KSTACK_MAGIC;
  10533b:	c7 86 20 01 00 00 32 	movl   $0x98765432,0x120(%esi)
  105342:	54 76 98 
    proc_kstack[pid].cpu_idx = cpu_idx;
  105345:	89 86 1c 01 00 00    	mov    %eax,0x11c(%esi)
}
  10534b:	83 c4 1c             	add    $0x1c,%esp
  10534e:	5b                   	pop    %ebx
  10534f:	5e                   	pop    %esi
  105350:	5f                   	pop    %edi
  105351:	5d                   	pop    %ebp
  105352:	c3                   	ret
  105353:	66 90                	xchg   %ax,%ax
  105355:	66 90                	xchg   %ax,%ax
  105357:	66 90                	xchg   %ax,%ax
  105359:	66 90                	xchg   %ax,%ax
  10535b:	66 90                	xchg   %ax,%ax
  10535d:	66 90                	xchg   %ax,%ax
  10535f:	90                   	nop

00105360 <max>:
#include "types.h"

uint32_t max(uint32_t a, uint32_t b)
{
  105360:	8b 44 24 08          	mov    0x8(%esp),%eax
    return (a > b) ? a : b;
  105364:	8b 54 24 04          	mov    0x4(%esp),%edx
  105368:	39 d0                	cmp    %edx,%eax
  10536a:	0f 42 c2             	cmovb  %edx,%eax
}
  10536d:	c3                   	ret
  10536e:	66 90                	xchg   %ax,%ax

00105370 <min>:

uint32_t min(uint32_t a, uint32_t b)
{
  105370:	8b 44 24 08          	mov    0x8(%esp),%eax
    return (a < b) ? a : b;
  105374:	8b 54 24 04          	mov    0x4(%esp),%edx
  105378:	39 d0                	cmp    %edx,%eax
  10537a:	0f 47 c2             	cmova  %edx,%eax
}
  10537d:	c3                   	ret
  10537e:	66 90                	xchg   %ax,%ax

00105380 <rounddown>:

uint32_t rounddown(uint32_t a, uint32_t n)
{
  105380:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    return a - a % n;
  105384:	31 d2                	xor    %edx,%edx
  105386:	89 c8                	mov    %ecx,%eax
  105388:	f7 74 24 08          	divl   0x8(%esp)
  10538c:	89 c8                	mov    %ecx,%eax
  10538e:	29 d0                	sub    %edx,%eax
}
  105390:	c3                   	ret
  105391:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105398:	00 
  105399:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001053a0 <roundup>:

uint32_t roundup(uint32_t a, uint32_t n)
{
  1053a0:	53                   	push   %ebx
  1053a1:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
    return a - a % n;
  1053a5:	31 d2                	xor    %edx,%edx
    return rounddown(a + n - 1, n);
  1053a7:	8d 4b ff             	lea    -0x1(%ebx),%ecx
  1053aa:	03 4c 24 08          	add    0x8(%esp),%ecx
    return a - a % n;
  1053ae:	89 c8                	mov    %ecx,%eax
  1053b0:	f7 f3                	div    %ebx
  1053b2:	89 c8                	mov    %ecx,%eax
}
  1053b4:	5b                   	pop    %ebx
    return a - a % n;
  1053b5:	29 d0                	sub    %edx,%eax
}
  1053b7:	c3                   	ret
  1053b8:	66 90                	xchg   %ax,%ax
  1053ba:	66 90                	xchg   %ax,%ax
  1053bc:	66 90                	xchg   %ax,%ax
  1053be:	66 90                	xchg   %ax,%ax

001053c0 <read_esp>:
#include "x86.h"

gcc_inline uintptr_t read_esp(void)
{
    uint32_t esp;
    __asm __volatile ("movl %%esp,%0" : "=rm" (esp));
  1053c0:	89 e0                	mov    %esp,%eax
    return esp;
}
  1053c2:	c3                   	ret
  1053c3:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1053ca:	00 
  1053cb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

001053d0 <read_ebp>:

gcc_inline uint32_t read_ebp(void)
{
    uint32_t ebp;
    __asm __volatile ("movl %%ebp,%0" : "=rm" (ebp));
  1053d0:	89 e8                	mov    %ebp,%eax
    return ebp;
}
  1053d2:	c3                   	ret
  1053d3:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1053da:	00 
  1053db:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

001053e0 <lldt>:

gcc_inline void lldt(uint16_t sel)
{
    __asm __volatile ("lldt %0" :: "r" (sel));
  1053e0:	0f b7 44 24 04       	movzwl 0x4(%esp),%eax
  1053e5:	0f 00 d0             	lldt   %eax
}
  1053e8:	c3                   	ret
  1053e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001053f0 <cli>:

gcc_inline void cli(void)
{
    __asm __volatile ("cli" ::: "memory");
  1053f0:	fa                   	cli
}
  1053f1:	c3                   	ret
  1053f2:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1053f9:	00 
  1053fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00105400 <sti>:

gcc_inline void sti(void)
{
    __asm __volatile ("sti; nop");
  105400:	fb                   	sti
  105401:	90                   	nop
}
  105402:	c3                   	ret
  105403:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10540a:	00 
  10540b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00105410 <rdmsr>:

gcc_inline uint64_t rdmsr(uint32_t msr)
{
    uint64_t rv;
    __asm __volatile ("rdmsr"
  105410:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  105414:	0f 32                	rdmsr
                      : "=A" (rv)
                      : "c" (msr));
    return rv;
}
  105416:	c3                   	ret
  105417:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10541e:	00 
  10541f:	90                   	nop

00105420 <wrmsr>:

gcc_inline void wrmsr(uint32_t msr, uint64_t newval)
{
    __asm __volatile ("wrmsr" :: "A" (newval), "c" (msr));
  105420:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  105424:	8b 44 24 08          	mov    0x8(%esp),%eax
  105428:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10542c:	0f 30                	wrmsr
}
  10542e:	c3                   	ret
  10542f:	90                   	nop

00105430 <halt>:

gcc_inline void halt(void)
{
    __asm __volatile ("hlt");
  105430:	f4                   	hlt
}
  105431:	c3                   	ret
  105432:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105439:	00 
  10543a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00105440 <pause>:

gcc_inline void pause(void)
{
    __asm __volatile ("pause" ::: "memory");
  105440:	f3 90                	pause
}
  105442:	c3                   	ret
  105443:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10544a:	00 
  10544b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00105450 <xchg>:

gcc_inline uint32_t xchg(volatile uint32_t *addr, uint32_t newval)
{
  105450:	8b 54 24 04          	mov    0x4(%esp),%edx
    uint32_t result;

    __asm __volatile ("lock; xchgl %0, %1"
  105454:	8b 44 24 08          	mov    0x8(%esp),%eax
  105458:	f0 87 02             	lock xchg %eax,(%edx)
                      : "+m" (*addr), "=a" (result)
                      : "1" (newval)
                      : "cc");

    return result;
}
  10545b:	c3                   	ret
  10545c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00105460 <cmpxchg>:

gcc_inline uint32_t cmpxchg(volatile uint32_t *addr, uint32_t oldval, uint32_t newval)
{
  105460:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    uint32_t result;

    __asm __volatile ("lock; cmpxchgl %2, %0"
  105464:	8b 44 24 08          	mov    0x8(%esp),%eax
  105468:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10546c:	f0 0f b1 11          	lock cmpxchg %edx,(%ecx)
                      : "+m" (*addr), "=a" (result)
                      : "r" (newval), "a" (oldval)
                      : "memory", "cc");

    return result;
}
  105470:	c3                   	ret
  105471:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105478:	00 
  105479:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00105480 <rdtsc>:

gcc_inline uint64_t rdtsc(void)
{
    uint64_t rv;

    __asm __volatile ("rdtsc" : "=A" (rv));
  105480:	0f 31                	rdtsc
    return (rv);
}
  105482:	c3                   	ret
  105483:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10548a:	00 
  10548b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00105490 <enable_sse>:
    asm volatile ("xsetbv"::"A"(newval), "c"(xcr));
}

gcc_inline void x86_fninit(void)
{
    asm volatile ("fninit");
  105490:	db e3                	fninit
}

gcc_inline uint32_t rcr4(void)
{
    uint32_t cr4;
    __asm __volatile ("movl %%cr4,%0" : "=r" (cr4));
  105492:	0f 20 e0             	mov    %cr4,%eax
    FENCE();
  105495:	0f ae f0             	mfence
    cr4 = rcr4() | CR4_OSFXSR | CR4_OSXMMEXCPT | CR4_OSXSAVE;
  105498:	0d 00 06 04 00       	or     $0x40600,%eax
    __asm __volatile ("movl %0,%%cr4" :: "r" (val));
  10549d:	0f 22 e0             	mov    %eax,%cr4
    __asm __volatile ("movl %%cr0,%0" : "=r" (val));
  1054a0:	0f 20 c0             	mov    %cr0,%eax
    FENCE();
  1054a3:	0f ae f0             	mfence
    cr0 &= ~(CR0_EM | CR0_TS);
  1054a6:	83 e0 f3             	and    $0xfffffff3,%eax
  1054a9:	83 c8 02             	or     $0x2,%eax
    __asm __volatile ("movl %0,%%cr0" :: "r" (val));
  1054ac:	0f 22 c0             	mov    %eax,%cr0
    FENCE();
  1054af:	0f ae f0             	mfence
}
  1054b2:	c3                   	ret
  1054b3:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1054ba:	00 
  1054bb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

001054c0 <cpuid>:
{
  1054c0:	55                   	push   %ebp
  1054c1:	57                   	push   %edi
  1054c2:	56                   	push   %esi
  1054c3:	53                   	push   %ebx
  1054c4:	8b 44 24 14          	mov    0x14(%esp),%eax
  1054c8:	8b 74 24 18          	mov    0x18(%esp),%esi
  1054cc:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  1054d0:	8b 6c 24 20          	mov    0x20(%esp),%ebp
    __asm __volatile ("cpuid"
  1054d4:	0f a2                	cpuid
    if (eaxp)
  1054d6:	85 f6                	test   %esi,%esi
  1054d8:	74 02                	je     1054dc <cpuid+0x1c>
        *eaxp = eax;
  1054da:	89 06                	mov    %eax,(%esi)
    if (ebxp)
  1054dc:	85 ff                	test   %edi,%edi
  1054de:	74 02                	je     1054e2 <cpuid+0x22>
        *ebxp = ebx;
  1054e0:	89 1f                	mov    %ebx,(%edi)
    if (ecxp)
  1054e2:	85 ed                	test   %ebp,%ebp
  1054e4:	74 03                	je     1054e9 <cpuid+0x29>
        *ecxp = ecx;
  1054e6:	89 4d 00             	mov    %ecx,0x0(%ebp)
    if (edxp)
  1054e9:	8b 44 24 24          	mov    0x24(%esp),%eax
  1054ed:	85 c0                	test   %eax,%eax
  1054ef:	74 06                	je     1054f7 <cpuid+0x37>
        *edxp = edx;
  1054f1:	8b 44 24 24          	mov    0x24(%esp),%eax
  1054f5:	89 10                	mov    %edx,(%eax)
}
  1054f7:	5b                   	pop    %ebx
  1054f8:	5e                   	pop    %esi
  1054f9:	5f                   	pop    %edi
  1054fa:	5d                   	pop    %ebp
  1054fb:	c3                   	ret
  1054fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00105500 <cpuid_subleaf>:
{
  105500:	55                   	push   %ebp
  105501:	57                   	push   %edi
  105502:	56                   	push   %esi
  105503:	53                   	push   %ebx
  105504:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  105508:	8b 7c 24 20          	mov    0x20(%esp),%edi
  10550c:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    asm volatile ("cpuid"
  105510:	8b 44 24 14          	mov    0x14(%esp),%eax
  105514:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  105518:	0f a2                	cpuid
    if (eaxp)
  10551a:	85 f6                	test   %esi,%esi
  10551c:	74 02                	je     105520 <cpuid_subleaf+0x20>
        *eaxp = eax;
  10551e:	89 06                	mov    %eax,(%esi)
    if (ebxp)
  105520:	85 ff                	test   %edi,%edi
  105522:	74 02                	je     105526 <cpuid_subleaf+0x26>
        *ebxp = ebx;
  105524:	89 1f                	mov    %ebx,(%edi)
    if (ecxp)
  105526:	85 ed                	test   %ebp,%ebp
  105528:	74 03                	je     10552d <cpuid_subleaf+0x2d>
        *ecxp = ecx;
  10552a:	89 4d 00             	mov    %ecx,0x0(%ebp)
    if (edxp)
  10552d:	8b 44 24 28          	mov    0x28(%esp),%eax
  105531:	85 c0                	test   %eax,%eax
  105533:	74 06                	je     10553b <cpuid_subleaf+0x3b>
        *edxp = edx;
  105535:	8b 44 24 28          	mov    0x28(%esp),%eax
  105539:	89 10                	mov    %edx,(%eax)
}
  10553b:	5b                   	pop    %ebx
  10553c:	5e                   	pop    %esi
  10553d:	5f                   	pop    %edi
  10553e:	5d                   	pop    %ebp
  10553f:	c3                   	ret

00105540 <rcr3>:
    __asm __volatile ("movl %%cr3,%0" : "=r" (val));
  105540:	0f 20 d8             	mov    %cr3,%eax
}
  105543:	c3                   	ret
  105544:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10554b:	00 
  10554c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00105550 <outl>:
    __asm __volatile ("outl %0,%w1" :: "a" (data), "d" (port));
  105550:	8b 54 24 04          	mov    0x4(%esp),%edx
  105554:	8b 44 24 08          	mov    0x8(%esp),%eax
  105558:	ef                   	out    %eax,(%dx)
}
  105559:	c3                   	ret
  10555a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00105560 <inl>:
    __asm __volatile ("inl %w1,%0" : "=a" (data) : "d" (port));
  105560:	8b 54 24 04          	mov    0x4(%esp),%edx
  105564:	ed                   	in     (%dx),%eax
}
  105565:	c3                   	ret
  105566:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10556d:	00 
  10556e:	66 90                	xchg   %ax,%ax

00105570 <smp_wmb>:
}
  105570:	c3                   	ret
  105571:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105578:	00 
  105579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00105580 <ltr>:
    __asm __volatile ("ltr %0" :: "r" (sel));
  105580:	0f b7 44 24 04       	movzwl 0x4(%esp),%eax
  105585:	0f 00 d8             	ltr    %eax
}
  105588:	c3                   	ret
  105589:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00105590 <lcr0>:
    __asm __volatile ("movl %0,%%cr0" :: "r" (val));
  105590:	8b 44 24 04          	mov    0x4(%esp),%eax
  105594:	0f 22 c0             	mov    %eax,%cr0
}
  105597:	c3                   	ret
  105598:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10559f:	00 

001055a0 <rcr0>:
    __asm __volatile ("movl %%cr0,%0" : "=r" (val));
  1055a0:	0f 20 c0             	mov    %cr0,%eax
}
  1055a3:	c3                   	ret
  1055a4:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1055ab:	00 
  1055ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001055b0 <rcr2>:
    __asm __volatile ("movl %%cr2,%0" : "=r" (val));
  1055b0:	0f 20 d0             	mov    %cr2,%eax
}
  1055b3:	c3                   	ret
  1055b4:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1055bb:	00 
  1055bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001055c0 <lcr3>:
    __asm __volatile ("movl %0,%%cr3" :: "r" (val));
  1055c0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1055c4:	0f 22 d8             	mov    %eax,%cr3
}
  1055c7:	c3                   	ret
  1055c8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1055cf:	00 

001055d0 <lcr4>:
    __asm __volatile ("movl %0,%%cr4" :: "r" (val));
  1055d0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1055d4:	0f 22 e0             	mov    %eax,%cr4
}
  1055d7:	c3                   	ret
  1055d8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1055df:	00 

001055e0 <rcr4>:
    __asm __volatile ("movl %%cr4,%0" : "=r" (cr4));
  1055e0:	0f 20 e0             	mov    %cr4,%eax
    return cr4;
}
  1055e3:	c3                   	ret
  1055e4:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1055eb:	00 
  1055ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001055f0 <inb>:

gcc_inline uint8_t inb(int port)
{
    uint8_t data;
    __asm __volatile ("inb %w1,%0"
  1055f0:	8b 54 24 04          	mov    0x4(%esp),%edx
  1055f4:	ec                   	in     (%dx),%al
                      : "=a" (data)
                      : "d" (port));
    return data;
}
  1055f5:	c3                   	ret
  1055f6:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1055fd:	00 
  1055fe:	66 90                	xchg   %ax,%ax

00105600 <insl>:

gcc_inline void insl(int port, void *addr, int cnt)
{
  105600:	57                   	push   %edi
    __asm __volatile ("cld\n\trepne\n\tinsl"
  105601:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  105605:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  105609:	8b 54 24 08          	mov    0x8(%esp),%edx
  10560d:	fc                   	cld
  10560e:	f2 6d                	repnz insl (%dx),%es:(%edi)
                      : "=D" (addr), "=c" (cnt)
                      : "d" (port), "0" (addr), "1" (cnt)
                      : "memory", "cc");
}
  105610:	5f                   	pop    %edi
  105611:	c3                   	ret
  105612:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105619:	00 
  10561a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00105620 <outb>:

gcc_inline void outb(int port, uint8_t data)
{
    __asm __volatile ("outb %0,%w1" :: "a" (data), "d" (port));
  105620:	8b 54 24 04          	mov    0x4(%esp),%edx
  105624:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
  105629:	ee                   	out    %al,(%dx)
}
  10562a:	c3                   	ret
  10562b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00105630 <outsw>:

gcc_inline void outsw(int port, const void *addr, int cnt)
{
  105630:	56                   	push   %esi
    __asm __volatile ("cld\n\trepne\n\toutsw"
  105631:	8b 74 24 0c          	mov    0xc(%esp),%esi
  105635:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  105639:	8b 54 24 08          	mov    0x8(%esp),%edx
  10563d:	fc                   	cld
  10563e:	f2 66 6f             	repnz outsw %ds:(%esi),(%dx)
                      : "=S" (addr), "=c" (cnt)
                      : "d" (port), "0" (addr), "1" (cnt)
                      : "cc");
}
  105641:	5e                   	pop    %esi
  105642:	c3                   	ret
  105643:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10564a:	00 
  10564b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00105650 <outsl>:

gcc_inline void outsl(int port, const void *addr, int cnt)
{
  105650:	56                   	push   %esi
    __asm __volatile ("cld\n\trepne\n\toutsl"
  105651:	8b 74 24 0c          	mov    0xc(%esp),%esi
  105655:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  105659:	8b 54 24 08          	mov    0x8(%esp),%edx
  10565d:	fc                   	cld
  10565e:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
                      : "=S" (addr), "=c" (cnt)
                      : "d" (port), "0" (addr), "1" (cnt)
                      : "cc");
}
  105660:	5e                   	pop    %esi
  105661:	c3                   	ret
  105662:	66 90                	xchg   %ax,%ax
  105664:	66 90                	xchg   %ax,%ax
  105666:	66 90                	xchg   %ax,%ax
  105668:	66 90                	xchg   %ax,%ax
  10566a:	66 90                	xchg   %ax,%ax
  10566c:	66 90                	xchg   %ax,%ax
  10566e:	66 90                	xchg   %ax,%ax

00105670 <mon_help>:

#define NCOMMANDS (sizeof(commands) / sizeof(commands[0]))

/***** Implementations of basic kernel monitor commands *****/
int mon_help(int argc, char **argv, struct Trapframe *tf)
{
  105670:	56                   	push   %esi
  105671:	53                   	push   %ebx
  105672:	e8 2b ad ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105677:	81 c3 7d 19 01 00    	add    $0x1197d,%ebx
  10567d:	83 ec 08             	sub    $0x8,%esp
    int i;

    for (i = 0; i < NCOMMANDS; i++)
        dprintf("%s - %s\n", commands[i].name, commands[i].desc);
  105680:	8d 83 55 64 ff ff    	lea    -0x9bab(%ebx),%eax
  105686:	8d b3 78 64 ff ff    	lea    -0x9b88(%ebx),%esi
  10568c:	50                   	push   %eax
  10568d:	8d 83 73 64 ff ff    	lea    -0x9b8d(%ebx),%eax
  105693:	50                   	push   %eax
  105694:	56                   	push   %esi
  105695:	e8 c6 f3 ff ff       	call   104a60 <dprintf>
  10569a:	83 c4 0c             	add    $0xc,%esp
  10569d:	8d 83 d4 70 ff ff    	lea    -0x8f2c(%ebx),%eax
  1056a3:	50                   	push   %eax
  1056a4:	8d 83 81 64 ff ff    	lea    -0x9b7f(%ebx),%eax
  1056aa:	50                   	push   %eax
  1056ab:	56                   	push   %esi
  1056ac:	e8 af f3 ff ff       	call   104a60 <dprintf>
    return 0;
}
  1056b1:	83 c4 14             	add    $0x14,%esp
  1056b4:	31 c0                	xor    %eax,%eax
  1056b6:	5b                   	pop    %ebx
  1056b7:	5e                   	pop    %esi
  1056b8:	c3                   	ret
  1056b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001056c0 <mon_kerninfo>:

int mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  1056c0:	57                   	push   %edi
  1056c1:	56                   	push   %esi
  1056c2:	53                   	push   %ebx
  1056c3:	e8 da ac ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1056c8:	81 c3 2c 19 01 00    	add    $0x1192c,%ebx
    extern uint8_t start[], etext[], edata[], end[];

    dprintf("Special kernel symbols:\n");
  1056ce:	83 ec 0c             	sub    $0xc,%esp
  1056d1:	8d 83 8a 64 ff ff    	lea    -0x9b76(%ebx),%eax
  1056d7:	50                   	push   %eax
  1056d8:	e8 83 f3 ff ff       	call   104a60 <dprintf>
    dprintf("  start  %08x\n", start);
  1056dd:	c7 c7 60 65 10 00    	mov    $0x106560,%edi
  1056e3:	58                   	pop    %eax
  1056e4:	8d 83 a3 64 ff ff    	lea    -0x9b5d(%ebx),%eax
  1056ea:	5a                   	pop    %edx
  1056eb:	57                   	push   %edi
  1056ec:	50                   	push   %eax
  1056ed:	e8 6e f3 ff ff       	call   104a60 <dprintf>
    dprintf("  etext  %08x\n", etext);
  1056f2:	8d 83 b2 64 ff ff    	lea    -0x9b4e(%ebx),%eax
  1056f8:	59                   	pop    %ecx
  1056f9:	5e                   	pop    %esi
  1056fa:	ff b3 f8 ff ff ff    	push   -0x8(%ebx)
  105700:	50                   	push   %eax
  105701:	e8 5a f3 ff ff       	call   104a60 <dprintf>
    dprintf("  edata  %08x\n", edata);
  105706:	58                   	pop    %eax
  105707:	8d 83 c1 64 ff ff    	lea    -0x9b3f(%ebx),%eax
  10570d:	5a                   	pop    %edx
  10570e:	ff b3 f0 ff ff ff    	push   -0x10(%ebx)
  105714:	50                   	push   %eax
  105715:	e8 46 f3 ff ff       	call   104a60 <dprintf>
    dprintf("  end    %08x\n", end);
  10571a:	59                   	pop    %ecx
  10571b:	5e                   	pop    %esi
  10571c:	8d 83 d0 64 ff ff    	lea    -0x9b30(%ebx),%eax
  105722:	c7 c6 c0 c8 e7 00    	mov    $0xe7c8c0,%esi
  105728:	56                   	push   %esi
    dprintf("Kernel executable memory footprint: %dKB\n",
            ROUNDUP(end - start, 1024) / 1024);
  105729:	29 fe                	sub    %edi,%esi
    dprintf("  end    %08x\n", end);
  10572b:	50                   	push   %eax
  10572c:	e8 2f f3 ff ff       	call   104a60 <dprintf>
            ROUNDUP(end - start, 1024) / 1024);
  105731:	8d 86 ff 03 00 00    	lea    0x3ff(%esi),%eax
    dprintf("Kernel executable memory footprint: %dKB\n",
  105737:	5f                   	pop    %edi
  105738:	5a                   	pop    %edx
            ROUNDUP(end - start, 1024) / 1024);
  105739:	89 c1                	mov    %eax,%ecx
  10573b:	c1 f9 1f             	sar    $0x1f,%ecx
  10573e:	c1 e9 16             	shr    $0x16,%ecx
  105741:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  105744:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  10574a:	29 ca                	sub    %ecx,%edx
  10574c:	29 d0                	sub    %edx,%eax
    dprintf("Kernel executable memory footprint: %dKB\n",
  10574e:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
  105754:	0f 48 c2             	cmovs  %edx,%eax
  105757:	c1 f8 0a             	sar    $0xa,%eax
  10575a:	50                   	push   %eax
  10575b:	8d 83 fc 70 ff ff    	lea    -0x8f04(%ebx),%eax
  105761:	50                   	push   %eax
  105762:	e8 f9 f2 ff ff       	call   104a60 <dprintf>
    return 0;
  105767:	83 c4 10             	add    $0x10,%esp
}
  10576a:	31 c0                	xor    %eax,%eax
  10576c:	5b                   	pop    %ebx
  10576d:	5e                   	pop    %esi
  10576e:	5f                   	pop    %edi
  10576f:	c3                   	ret

00105770 <monitor>:
    dprintf("Unknown command '%s'\n", argv[0]);
    return 0;
}

void monitor(struct Trapframe *tf)
{
  105770:	55                   	push   %ebp
  105771:	57                   	push   %edi
  105772:	56                   	push   %esi
  105773:	53                   	push   %ebx
  105774:	e8 29 ac ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105779:	81 c3 7b 18 01 00    	add    $0x1187b,%ebx
  10577f:	83 ec 68             	sub    $0x68,%esp
    char *buf;

    dprintf("\n****************************************\n\n");
  105782:	8d b3 28 71 ff ff    	lea    -0x8ed8(%ebx),%esi
  105788:	8d ab df 64 ff ff    	lea    -0x9b21(%ebx),%ebp
  10578e:	56                   	push   %esi
        while (*buf && strchr(WHITESPACE, *buf))
  10578f:	8d bb e3 64 ff ff    	lea    -0x9b1d(%ebx),%edi
    dprintf("\n****************************************\n\n");
  105795:	e8 c6 f2 ff ff       	call   104a60 <dprintf>
    dprintf("Welcome to the mCertiKOS kernel monitor!\n");
  10579a:	8d 83 54 71 ff ff    	lea    -0x8eac(%ebx),%eax
  1057a0:	89 04 24             	mov    %eax,(%esp)
  1057a3:	e8 b8 f2 ff ff       	call   104a60 <dprintf>
    dprintf("\n****************************************\n\n");
  1057a8:	89 34 24             	mov    %esi,(%esp)
  1057ab:	e8 b0 f2 ff ff       	call   104a60 <dprintf>
    dprintf("Type 'help' for a list of commands.\n");
  1057b0:	8d 83 80 71 ff ff    	lea    -0x8e80(%ebx),%eax
  1057b6:	89 04 24             	mov    %eax,(%esp)
  1057b9:	e8 a2 f2 ff ff       	call   104a60 <dprintf>
  1057be:	83 c4 10             	add    $0x10,%esp
  1057c1:	8d 83 73 64 ff ff    	lea    -0x9b8d(%ebx),%eax
  1057c7:	89 44 24 08          	mov    %eax,0x8(%esp)
  1057cb:	8d 44 24 10          	lea    0x10(%esp),%eax
  1057cf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1057d3:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

    while (1) {
        buf = (char *) readline("$> ");
  1057d8:	83 ec 0c             	sub    $0xc,%esp
  1057db:	55                   	push   %ebp
  1057dc:	e8 af ad ff ff       	call   100590 <readline>
        if (buf != NULL)
  1057e1:	83 c4 10             	add    $0x10,%esp
        buf = (char *) readline("$> ");
  1057e4:	89 c6                	mov    %eax,%esi
        if (buf != NULL)
  1057e6:	85 c0                	test   %eax,%eax
  1057e8:	74 ee                	je     1057d8 <monitor+0x68>
    argv[argc] = 0;
  1057ea:	89 2c 24             	mov    %ebp,(%esp)
    argc = 0;
  1057ed:	31 d2                	xor    %edx,%edx
    argv[argc] = 0;
  1057ef:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1057f6:	00 
  1057f7:	0f be 00             	movsbl (%eax),%eax
  1057fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        while (*buf && strchr(WHITESPACE, *buf))
  105800:	84 c0                	test   %al,%al
  105802:	75 6c                	jne    105870 <monitor+0x100>
    if (argc == 0)
  105804:	85 d2                	test   %edx,%edx
    argv[argc] = 0;
  105806:	8b 2c 24             	mov    (%esp),%ebp
  105809:	c7 44 94 10 00 00 00 	movl   $0x0,0x10(%esp,%edx,4)
  105810:	00 
    if (argc == 0)
  105811:	89 14 24             	mov    %edx,(%esp)
  105814:	74 c2                	je     1057d8 <monitor+0x68>
        if (strcmp(argv[0], commands[i].name) == 0)
  105816:	83 ec 08             	sub    $0x8,%esp
  105819:	ff 74 24 10          	push   0x10(%esp)
  10581d:	ff 74 24 1c          	push   0x1c(%esp)
  105821:	e8 4a ed ff ff       	call   104570 <strcmp>
  105826:	83 c4 10             	add    $0x10,%esp
  105829:	8b 14 24             	mov    (%esp),%edx
  10582c:	85 c0                	test   %eax,%eax
  10582e:	0f 84 cd 00 00 00    	je     105901 <monitor+0x191>
  105834:	83 ec 08             	sub    $0x8,%esp
  105837:	8d 83 81 64 ff ff    	lea    -0x9b7f(%ebx),%eax
  10583d:	50                   	push   %eax
  10583e:	ff 74 24 1c          	push   0x1c(%esp)
  105842:	e8 29 ed ff ff       	call   104570 <strcmp>
  105847:	83 c4 10             	add    $0x10,%esp
  10584a:	8b 14 24             	mov    (%esp),%edx
  10584d:	85 c0                	test   %eax,%eax
  10584f:	0f 84 d3 00 00 00    	je     105928 <monitor+0x1b8>
    dprintf("Unknown command '%s'\n", argv[0]);
  105855:	83 ec 08             	sub    $0x8,%esp
  105858:	8d 83 05 65 ff ff    	lea    -0x9afb(%ebx),%eax
  10585e:	ff 74 24 18          	push   0x18(%esp)
  105862:	50                   	push   %eax
  105863:	e8 f8 f1 ff ff       	call   104a60 <dprintf>
    return 0;
  105868:	83 c4 10             	add    $0x10,%esp
  10586b:	e9 68 ff ff ff       	jmp    1057d8 <monitor+0x68>
  105870:	89 54 24 04          	mov    %edx,0x4(%esp)
        while (*buf && strchr(WHITESPACE, *buf))
  105874:	83 ec 08             	sub    $0x8,%esp
  105877:	50                   	push   %eax
  105878:	57                   	push   %edi
  105879:	e8 42 ed ff ff       	call   1045c0 <strchr>
  10587e:	83 c4 10             	add    $0x10,%esp
  105881:	8b 54 24 04          	mov    0x4(%esp),%edx
  105885:	85 c0                	test   %eax,%eax
  105887:	74 17                	je     1058a0 <monitor+0x130>
            *buf++ = 0;
  105889:	8d 46 01             	lea    0x1(%esi),%eax
  10588c:	c6 06 00             	movb   $0x0,(%esi)
  10588f:	89 d5                	mov    %edx,%ebp
  105891:	89 c6                	mov    %eax,%esi
  105893:	0f be 06             	movsbl (%esi),%eax
  105896:	89 ea                	mov    %ebp,%edx
  105898:	e9 63 ff ff ff       	jmp    105800 <monitor+0x90>
  10589d:	8d 76 00             	lea    0x0(%esi),%esi
        if (*buf == 0)
  1058a0:	80 3e 00             	cmpb   $0x0,(%esi)
  1058a3:	0f 84 5b ff ff ff    	je     105804 <monitor+0x94>
        if (argc == MAXARGS - 1) {
  1058a9:	83 fa 0f             	cmp    $0xf,%edx
  1058ac:	74 37                	je     1058e5 <monitor+0x175>
        argv[argc++] = buf;
  1058ae:	89 74 94 10          	mov    %esi,0x10(%esp,%edx,4)
        while (*buf && !strchr(WHITESPACE, *buf))
  1058b2:	0f be 06             	movsbl (%esi),%eax
        argv[argc++] = buf;
  1058b5:	8d 6a 01             	lea    0x1(%edx),%ebp
        while (*buf && !strchr(WHITESPACE, *buf))
  1058b8:	0f be d0             	movsbl %al,%edx
  1058bb:	84 c0                	test   %al,%al
  1058bd:	74 d7                	je     105896 <monitor+0x126>
  1058bf:	90                   	nop
  1058c0:	83 ec 08             	sub    $0x8,%esp
  1058c3:	52                   	push   %edx
  1058c4:	57                   	push   %edi
  1058c5:	e8 f6 ec ff ff       	call   1045c0 <strchr>
  1058ca:	83 c4 10             	add    $0x10,%esp
  1058cd:	85 c0                	test   %eax,%eax
  1058cf:	75 c2                	jne    105893 <monitor+0x123>
  1058d1:	0f be 56 01          	movsbl 0x1(%esi),%edx
            buf++;
  1058d5:	83 c6 01             	add    $0x1,%esi
        while (*buf && !strchr(WHITESPACE, *buf))
  1058d8:	84 d2                	test   %dl,%dl
  1058da:	75 e4                	jne    1058c0 <monitor+0x150>
  1058dc:	31 c0                	xor    %eax,%eax
            *buf++ = 0;
  1058de:	89 ea                	mov    %ebp,%edx
  1058e0:	e9 1b ff ff ff       	jmp    105800 <monitor+0x90>
            dprintf("Too many arguments (max %d)\n", MAXARGS);
  1058e5:	8b 2c 24             	mov    (%esp),%ebp
  1058e8:	8d 83 e8 64 ff ff    	lea    -0x9b18(%ebx),%eax
  1058ee:	83 ec 08             	sub    $0x8,%esp
  1058f1:	6a 10                	push   $0x10
  1058f3:	50                   	push   %eax
  1058f4:	e8 67 f1 ff ff       	call   104a60 <dprintf>
            return 0;
  1058f9:	83 c4 10             	add    $0x10,%esp
  1058fc:	e9 d7 fe ff ff       	jmp    1057d8 <monitor+0x68>
        if (strcmp(argv[0], commands[i].name) == 0)
  105901:	8d 83 7c e6 fe ff    	lea    -0x11984(%ebx),%eax
            return commands[i].func(argc, argv, tf);
  105907:	83 ec 04             	sub    $0x4,%esp
  10590a:	ff 74 24 74          	push   0x74(%esp)
  10590e:	ff 74 24 14          	push   0x14(%esp)
  105912:	52                   	push   %edx
  105913:	ff d0                	call   *%eax
            if (runcmd(buf, tf) < 0)
  105915:	83 c4 10             	add    $0x10,%esp
  105918:	85 c0                	test   %eax,%eax
  10591a:	0f 89 b8 fe ff ff    	jns    1057d8 <monitor+0x68>
                break;
    }
}
  105920:	83 c4 5c             	add    $0x5c,%esp
  105923:	5b                   	pop    %ebx
  105924:	5e                   	pop    %esi
  105925:	5f                   	pop    %edi
  105926:	5d                   	pop    %ebp
  105927:	c3                   	ret
        if (strcmp(argv[0], commands[i].name) == 0)
  105928:	8d 83 cc e6 fe ff    	lea    -0x11934(%ebx),%eax
  10592e:	eb d7                	jmp    105907 <monitor+0x197>

00105930 <pt_copyin>:
extern unsigned int get_ptbl_entry_by_va(unsigned int pid,
                                         unsigned int vaddr);

size_t pt_copyin(uint32_t pmap_id, uintptr_t uva, void *kva, size_t len)
{
    if (!(VM_USERLO <= uva && uva + len <= VM_USERHI))
  105930:	e8 65 aa ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  105935:	05 bf 16 01 00       	add    $0x116bf,%eax
{
  10593a:	55                   	push   %ebp
        return 0;
  10593b:	31 c9                	xor    %ecx,%ecx
{
  10593d:	57                   	push   %edi
  10593e:	56                   	push   %esi
  10593f:	53                   	push   %ebx
  105940:	83 ec 1c             	sub    $0x1c,%esp
  105943:	8b 7c 24 34          	mov    0x34(%esp),%edi
  105947:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  10594b:	89 44 24 04          	mov    %eax,0x4(%esp)
    if (!(VM_USERLO <= uva && uva + len <= VM_USERHI))
  10594f:	81 ff ff ff ff 3f    	cmp    $0x3fffffff,%edi
  105955:	0f 86 b9 00 00 00    	jbe    105a14 <pt_copyin+0xe4>
  10595b:	8d 04 2f             	lea    (%edi,%ebp,1),%eax
  10595e:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  105963:	0f 87 ab 00 00 00    	ja     105a14 <pt_copyin+0xe4>

    if ((uintptr_t) kva + len > VM_USERHI)
  105969:	8b 44 24 38          	mov    0x38(%esp),%eax
  10596d:	01 e8                	add    %ebp,%eax
  10596f:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  105974:	0f 87 9a 00 00 00    	ja     105a14 <pt_copyin+0xe4>
        return 0;

    size_t copied = 0;

    while (len) {
  10597a:	85 ed                	test   %ebp,%ebp
  10597c:	0f 84 92 00 00 00    	je     105a14 <pt_copyin+0xe4>
            uva_pa = get_ptbl_entry_by_va(pmap_id, uva);
        }

        uva_pa = (uva_pa & 0xfffff000) + (uva % PAGESIZE);

        size_t size = (len < PAGESIZE - uva_pa % PAGESIZE) ?
  105982:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  105986:	8b 74 24 38          	mov    0x38(%esp),%esi
  10598a:	eb 45                	jmp    1059d1 <pt_copyin+0xa1>
  10598c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        uva_pa = (uva_pa & 0xfffff000) + (uva % PAGESIZE);
  105990:	89 f9                	mov    %edi,%ecx
        size_t size = (len < PAGESIZE - uva_pa % PAGESIZE) ?
  105992:	ba 00 10 00 00       	mov    $0x1000,%edx
        uva_pa = (uva_pa & 0xfffff000) + (uva % PAGESIZE);
  105997:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10599c:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
        size_t size = (len < PAGESIZE - uva_pa % PAGESIZE) ?
  1059a2:	29 ca                	sub    %ecx,%edx
        uva_pa = (uva_pa & 0xfffff000) + (uva % PAGESIZE);
  1059a4:	09 c8                	or     %ecx,%eax
        size_t size = (len < PAGESIZE - uva_pa % PAGESIZE) ?
  1059a6:	39 ea                	cmp    %ebp,%edx
  1059a8:	0f 47 d5             	cmova  %ebp,%edx
            len : PAGESIZE - uva_pa % PAGESIZE;

        memcpy(kva, (void *) uva_pa, size);
  1059ab:	83 ec 04             	sub    $0x4,%esp
  1059ae:	52                   	push   %edx
  1059af:	89 54 24 10          	mov    %edx,0x10(%esp)
  1059b3:	50                   	push   %eax
  1059b4:	56                   	push   %esi
  1059b5:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  1059b9:	e8 22 eb ff ff       	call   1044e0 <memcpy>

        len -= size;
        uva += size;
  1059be:	8b 54 24 18          	mov    0x18(%esp),%edx
        kva += size;
        copied += size;
  1059c2:	01 54 24 1c          	add    %edx,0x1c(%esp)
    while (len) {
  1059c6:	83 c4 10             	add    $0x10,%esp
        uva += size;
  1059c9:	01 d7                	add    %edx,%edi
        kva += size;
  1059cb:	01 d6                	add    %edx,%esi
    while (len) {
  1059cd:	29 d5                	sub    %edx,%ebp
  1059cf:	74 3f                	je     105a10 <pt_copyin+0xe0>
        uintptr_t uva_pa = get_ptbl_entry_by_va(pmap_id, uva);
  1059d1:	83 ec 08             	sub    $0x8,%esp
  1059d4:	57                   	push   %edi
  1059d5:	ff 74 24 3c          	push   0x3c(%esp)
  1059d9:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  1059dd:	e8 5e 14 00 00       	call   106e40 <get_ptbl_entry_by_va>
        if ((uva_pa & PTE_P) == 0) {
  1059e2:	83 c4 10             	add    $0x10,%esp
  1059e5:	a8 01                	test   $0x1,%al
  1059e7:	75 a7                	jne    105990 <pt_copyin+0x60>
            alloc_page(pmap_id, uva, PTE_P | PTE_U | PTE_W);
  1059e9:	83 ec 04             	sub    $0x4,%esp
  1059ec:	6a 07                	push   $0x7
  1059ee:	57                   	push   %edi
  1059ef:	ff 74 24 3c          	push   0x3c(%esp)
  1059f3:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  1059f7:	e8 f4 18 00 00       	call   1072f0 <alloc_page>
            uva_pa = get_ptbl_entry_by_va(pmap_id, uva);
  1059fc:	58                   	pop    %eax
  1059fd:	5a                   	pop    %edx
  1059fe:	57                   	push   %edi
  1059ff:	ff 74 24 3c          	push   0x3c(%esp)
  105a03:	e8 38 14 00 00       	call   106e40 <get_ptbl_entry_by_va>
  105a08:	83 c4 10             	add    $0x10,%esp
  105a0b:	eb 83                	jmp    105990 <pt_copyin+0x60>
  105a0d:	8d 76 00             	lea    0x0(%esi),%esi
  105a10:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    }

    return copied;
}
  105a14:	83 c4 1c             	add    $0x1c,%esp
  105a17:	89 c8                	mov    %ecx,%eax
  105a19:	5b                   	pop    %ebx
  105a1a:	5e                   	pop    %esi
  105a1b:	5f                   	pop    %edi
  105a1c:	5d                   	pop    %ebp
  105a1d:	c3                   	ret
  105a1e:	66 90                	xchg   %ax,%ax

00105a20 <pt_copyout>:

size_t pt_copyout(void *kva, uint32_t pmap_id, uintptr_t uva, size_t len)
{
    if (!(VM_USERLO <= uva && uva + len <= VM_USERHI))
  105a20:	e8 75 a9 ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  105a25:	05 cf 15 01 00       	add    $0x115cf,%eax
{
  105a2a:	55                   	push   %ebp
        return 0;
  105a2b:	31 c9                	xor    %ecx,%ecx
{
  105a2d:	57                   	push   %edi
  105a2e:	56                   	push   %esi
  105a2f:	53                   	push   %ebx
  105a30:	83 ec 1c             	sub    $0x1c,%esp
  105a33:	8b 7c 24 38          	mov    0x38(%esp),%edi
  105a37:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  105a3b:	89 44 24 04          	mov    %eax,0x4(%esp)
    if (!(VM_USERLO <= uva && uva + len <= VM_USERHI))
  105a3f:	81 ff ff ff ff 3f    	cmp    $0x3fffffff,%edi
  105a45:	0f 86 b9 00 00 00    	jbe    105b04 <pt_copyout+0xe4>
  105a4b:	8d 04 2f             	lea    (%edi,%ebp,1),%eax
  105a4e:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  105a53:	0f 87 ab 00 00 00    	ja     105b04 <pt_copyout+0xe4>

    if ((uintptr_t) kva + len > VM_USERHI)
  105a59:	8b 44 24 30          	mov    0x30(%esp),%eax
  105a5d:	01 e8                	add    %ebp,%eax
  105a5f:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  105a64:	0f 87 9a 00 00 00    	ja     105b04 <pt_copyout+0xe4>
        return 0;

    size_t copied = 0;

    while (len) {
  105a6a:	85 ed                	test   %ebp,%ebp
  105a6c:	0f 84 92 00 00 00    	je     105b04 <pt_copyout+0xe4>
            uva_pa = get_ptbl_entry_by_va(pmap_id, uva);
        }

        uva_pa = (uva_pa & 0xfffff000) + (uva % PAGESIZE);

        size_t size = (len < PAGESIZE - uva_pa % PAGESIZE) ?
  105a72:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  105a76:	8b 74 24 30          	mov    0x30(%esp),%esi
  105a7a:	eb 45                	jmp    105ac1 <pt_copyout+0xa1>
  105a7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        uva_pa = (uva_pa & 0xfffff000) + (uva % PAGESIZE);
  105a80:	89 f9                	mov    %edi,%ecx
        size_t size = (len < PAGESIZE - uva_pa % PAGESIZE) ?
  105a82:	ba 00 10 00 00       	mov    $0x1000,%edx
        uva_pa = (uva_pa & 0xfffff000) + (uva % PAGESIZE);
  105a87:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105a8c:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
        size_t size = (len < PAGESIZE - uva_pa % PAGESIZE) ?
  105a92:	29 ca                	sub    %ecx,%edx
        uva_pa = (uva_pa & 0xfffff000) + (uva % PAGESIZE);
  105a94:	09 c8                	or     %ecx,%eax
        size_t size = (len < PAGESIZE - uva_pa % PAGESIZE) ?
  105a96:	39 ea                	cmp    %ebp,%edx
  105a98:	0f 47 d5             	cmova  %ebp,%edx
            len : PAGESIZE - uva_pa % PAGESIZE;

        memcpy((void *) uva_pa, kva, size);
  105a9b:	83 ec 04             	sub    $0x4,%esp
  105a9e:	52                   	push   %edx
  105a9f:	89 54 24 10          	mov    %edx,0x10(%esp)
  105aa3:	56                   	push   %esi
  105aa4:	50                   	push   %eax
  105aa5:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  105aa9:	e8 32 ea ff ff       	call   1044e0 <memcpy>

        len -= size;
        uva += size;
  105aae:	8b 54 24 18          	mov    0x18(%esp),%edx
        kva += size;
        copied += size;
  105ab2:	01 54 24 1c          	add    %edx,0x1c(%esp)
    while (len) {
  105ab6:	83 c4 10             	add    $0x10,%esp
        uva += size;
  105ab9:	01 d7                	add    %edx,%edi
        kva += size;
  105abb:	01 d6                	add    %edx,%esi
    while (len) {
  105abd:	29 d5                	sub    %edx,%ebp
  105abf:	74 3f                	je     105b00 <pt_copyout+0xe0>
        uintptr_t uva_pa = get_ptbl_entry_by_va(pmap_id, uva);
  105ac1:	83 ec 08             	sub    $0x8,%esp
  105ac4:	57                   	push   %edi
  105ac5:	ff 74 24 40          	push   0x40(%esp)
  105ac9:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  105acd:	e8 6e 13 00 00       	call   106e40 <get_ptbl_entry_by_va>
        if ((uva_pa & PTE_P) == 0) {
  105ad2:	83 c4 10             	add    $0x10,%esp
  105ad5:	a8 01                	test   $0x1,%al
  105ad7:	75 a7                	jne    105a80 <pt_copyout+0x60>
            alloc_page(pmap_id, uva, PTE_P | PTE_U | PTE_W);
  105ad9:	83 ec 04             	sub    $0x4,%esp
  105adc:	6a 07                	push   $0x7
  105ade:	57                   	push   %edi
  105adf:	ff 74 24 40          	push   0x40(%esp)
  105ae3:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  105ae7:	e8 04 18 00 00       	call   1072f0 <alloc_page>
            uva_pa = get_ptbl_entry_by_va(pmap_id, uva);
  105aec:	58                   	pop    %eax
  105aed:	5a                   	pop    %edx
  105aee:	57                   	push   %edi
  105aef:	ff 74 24 40          	push   0x40(%esp)
  105af3:	e8 48 13 00 00       	call   106e40 <get_ptbl_entry_by_va>
  105af8:	83 c4 10             	add    $0x10,%esp
  105afb:	eb 83                	jmp    105a80 <pt_copyout+0x60>
  105afd:	8d 76 00             	lea    0x0(%esi),%esi
  105b00:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    }

    return copied;
}
  105b04:	83 c4 1c             	add    $0x1c,%esp
  105b07:	89 c8                	mov    %ecx,%eax
  105b09:	5b                   	pop    %ebx
  105b0a:	5e                   	pop    %esi
  105b0b:	5f                   	pop    %edi
  105b0c:	5d                   	pop    %ebp
  105b0d:	c3                   	ret
  105b0e:	66 90                	xchg   %ax,%ax

00105b10 <pt_memset>:

size_t pt_memset(uint32_t pmap_id, uintptr_t va, char c, size_t len)
{
  105b10:	55                   	push   %ebp
  105b11:	57                   	push   %edi
  105b12:	56                   	push   %esi
  105b13:	53                   	push   %ebx
  105b14:	e8 89 a8 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105b19:	81 c3 db 14 01 00    	add    $0x114db,%ebx
  105b1f:	83 ec 1c             	sub    $0x1c,%esp
  105b22:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  105b26:	8b 7c 24 34          	mov    0x34(%esp),%edi
  105b2a:	8b 44 24 38          	mov    0x38(%esp),%eax
    size_t set = 0;

    while (len) {
  105b2e:	85 f6                	test   %esi,%esi
  105b30:	0f 84 8a 00 00 00    	je     105bc0 <pt_memset+0xb0>
        pa = (pa & 0xfffff000) + (va % PAGESIZE);

        size_t size = (len < PAGESIZE - pa % PAGESIZE) ?
            len : PAGESIZE - pa % PAGESIZE;

        memset((void *) pa, c, size);
  105b36:	0f be c0             	movsbl %al,%eax
    size_t set = 0;
  105b39:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105b40:	00 
        memset((void *) pa, c, size);
  105b41:	89 44 24 0c          	mov    %eax,0xc(%esp)
  105b45:	eb 41                	jmp    105b88 <pt_memset+0x78>
  105b47:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105b4e:	00 
  105b4f:	90                   	nop
        pa = (pa & 0xfffff000) + (va % PAGESIZE);
  105b50:	89 f9                	mov    %edi,%ecx
        size_t size = (len < PAGESIZE - pa % PAGESIZE) ?
  105b52:	ba 00 10 00 00       	mov    $0x1000,%edx
        pa = (pa & 0xfffff000) + (va % PAGESIZE);
  105b57:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105b5c:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
        size_t size = (len < PAGESIZE - pa % PAGESIZE) ?
  105b62:	29 ca                	sub    %ecx,%edx
        pa = (pa & 0xfffff000) + (va % PAGESIZE);
  105b64:	09 c8                	or     %ecx,%eax
        size_t size = (len < PAGESIZE - pa % PAGESIZE) ?
  105b66:	39 f2                	cmp    %esi,%edx
  105b68:	0f 47 d6             	cmova  %esi,%edx
        memset((void *) pa, c, size);
  105b6b:	83 ec 04             	sub    $0x4,%esp
  105b6e:	52                   	push   %edx
        size_t size = (len < PAGESIZE - pa % PAGESIZE) ?
  105b6f:	89 d5                	mov    %edx,%ebp
        memset((void *) pa, c, size);
  105b71:	ff 74 24 14          	push   0x14(%esp)

        len -= size;
        va += size;
  105b75:	01 ef                	add    %ebp,%edi
        memset((void *) pa, c, size);
  105b77:	50                   	push   %eax
  105b78:	e8 b3 e8 ff ff       	call   104430 <memset>
        set += size;
  105b7d:	01 6c 24 18          	add    %ebp,0x18(%esp)
    while (len) {
  105b81:	83 c4 10             	add    $0x10,%esp
  105b84:	29 ee                	sub    %ebp,%esi
  105b86:	74 40                	je     105bc8 <pt_memset+0xb8>
        uintptr_t pa = get_ptbl_entry_by_va(pmap_id, va);
  105b88:	83 ec 08             	sub    $0x8,%esp
  105b8b:	57                   	push   %edi
  105b8c:	ff 74 24 3c          	push   0x3c(%esp)
  105b90:	e8 ab 12 00 00       	call   106e40 <get_ptbl_entry_by_va>
        if ((pa & PTE_P) == 0) {
  105b95:	83 c4 10             	add    $0x10,%esp
  105b98:	a8 01                	test   $0x1,%al
  105b9a:	75 b4                	jne    105b50 <pt_memset+0x40>
            alloc_page(pmap_id, va, PTE_P | PTE_U | PTE_W);
  105b9c:	83 ec 04             	sub    $0x4,%esp
  105b9f:	6a 07                	push   $0x7
  105ba1:	57                   	push   %edi
  105ba2:	ff 74 24 3c          	push   0x3c(%esp)
  105ba6:	e8 45 17 00 00       	call   1072f0 <alloc_page>
            pa = get_ptbl_entry_by_va(pmap_id, va);
  105bab:	58                   	pop    %eax
  105bac:	5a                   	pop    %edx
  105bad:	57                   	push   %edi
  105bae:	ff 74 24 3c          	push   0x3c(%esp)
  105bb2:	e8 89 12 00 00       	call   106e40 <get_ptbl_entry_by_va>
  105bb7:	83 c4 10             	add    $0x10,%esp
  105bba:	eb 94                	jmp    105b50 <pt_memset+0x40>
  105bbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    size_t set = 0;
  105bc0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105bc7:	00 
    }

    return set;
}
  105bc8:	8b 44 24 08          	mov    0x8(%esp),%eax
  105bcc:	83 c4 1c             	add    $0x1c,%esp
  105bcf:	5b                   	pop    %ebx
  105bd0:	5e                   	pop    %esi
  105bd1:	5f                   	pop    %edi
  105bd2:	5d                   	pop    %ebp
  105bd3:	c3                   	ret
  105bd4:	66 90                	xchg   %ax,%ax
  105bd6:	66 90                	xchg   %ax,%ax
  105bd8:	66 90                	xchg   %ax,%ax
  105bda:	66 90                	xchg   %ax,%ax
  105bdc:	66 90                	xchg   %ax,%ax
  105bde:	66 90                	xchg   %ax,%ax

00105be0 <elf_load>:

/*
 * Load elf execution file exe to the virtual address space pmap.
 */
void elf_load(void *exe_ptr, int pid)
{
  105be0:	55                   	push   %ebp
  105be1:	57                   	push   %edi
  105be2:	56                   	push   %esi
  105be3:	53                   	push   %ebx
  105be4:	e8 b9 a7 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105be9:	81 c3 0b 14 01 00    	add    $0x1140b,%ebx
  105bef:	83 ec 2c             	sub    $0x2c,%esp
    char *strtab __attribute__((unused));
    uintptr_t exe = (uintptr_t) exe_ptr;

    eh = (elfhdr *) exe;

    KERN_ASSERT(eh->e_magic == ELF_MAGIC);
  105bf2:	8b 44 24 40          	mov    0x40(%esp),%eax
{
  105bf6:	8b 6c 24 44          	mov    0x44(%esp),%ebp
    KERN_ASSERT(eh->e_magic == ELF_MAGIC);
  105bfa:	81 38 7f 45 4c 46    	cmpl   $0x464c457f,(%eax)
  105c00:	74 1f                	je     105c21 <elf_load+0x41>
  105c02:	8d 83 1b 65 ff ff    	lea    -0x9ae5(%ebx),%eax
  105c08:	50                   	push   %eax
  105c09:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  105c0f:	50                   	push   %eax
  105c10:	8d 83 34 65 ff ff    	lea    -0x9acc(%ebx),%eax
  105c16:	6a 1e                	push   $0x1e
  105c18:	50                   	push   %eax
  105c19:	e8 d2 eb ff ff       	call   1047f0 <debug_panic>
  105c1e:	83 c4 10             	add    $0x10,%esp
    KERN_ASSERT(eh->e_shstrndx != ELF_SHN_UNDEF);
  105c21:	8b 44 24 40          	mov    0x40(%esp),%eax
  105c25:	0f b7 40 32          	movzwl 0x32(%eax),%eax
  105c29:	66 85 c0             	test   %ax,%ax
  105c2c:	0f 84 b6 01 00 00    	je     105de8 <elf_load+0x208>

    sh = (sechdr *) ((uintptr_t) eh + eh->e_shoff);
    esh = sh + eh->e_shnum;

    strtab = (char *) (exe + sh[eh->e_shstrndx].sh_offset);
    KERN_ASSERT(sh[eh->e_shstrndx].sh_type == ELF_SHT_STRTAB);
  105c32:	8b 4c 24 40          	mov    0x40(%esp),%ecx
  105c36:	8d 04 80             	lea    (%eax,%eax,4),%eax
  105c39:	8d 04 c1             	lea    (%ecx,%eax,8),%eax
  105c3c:	03 41 20             	add    0x20(%ecx),%eax
  105c3f:	83 78 04 03          	cmpl   $0x3,0x4(%eax)
  105c43:	74 1f                	je     105c64 <elf_load+0x84>
  105c45:	8d 83 c8 71 ff ff    	lea    -0x8e38(%ebx),%eax
  105c4b:	50                   	push   %eax
  105c4c:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  105c52:	50                   	push   %eax
  105c53:	8d 83 34 65 ff ff    	lea    -0x9acc(%ebx),%eax
  105c59:	6a 25                	push   $0x25
  105c5b:	50                   	push   %eax
  105c5c:	e8 8f eb ff ff       	call   1047f0 <debug_panic>
  105c61:	83 c4 10             	add    $0x10,%esp

    ph = (proghdr *) ((uintptr_t) eh + eh->e_phoff);
  105c64:	8b 44 24 40          	mov    0x40(%esp),%eax
  105c68:	8b 50 1c             	mov    0x1c(%eax),%edx
  105c6b:	01 c2                	add    %eax,%edx
    eph = ph + eh->e_phnum;
  105c6d:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  105c71:	c1 e0 05             	shl    $0x5,%eax
  105c74:	8d 0c 02             	lea    (%edx,%eax,1),%ecx

    for (; ph < eph; ph++) {
  105c77:	39 ca                	cmp    %ecx,%edx
  105c79:	0f 83 5c 01 00 00    	jae    105ddb <elf_load+0x1fb>
  105c7f:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  105c83:	eb 12                	jmp    105c97 <elf_load+0xb7>
  105c85:	8d 76 00             	lea    0x0(%esi),%esi
  105c88:	8b 44 24 18          	mov    0x18(%esp),%eax
  105c8c:	83 c2 20             	add    $0x20,%edx
  105c8f:	39 c2                	cmp    %eax,%edx
  105c91:	0f 83 44 01 00 00    	jae    105ddb <elf_load+0x1fb>
        uintptr_t fa;
        uint32_t va, zva, eva, perm;

        if (ph->p_type != ELF_PROG_LOAD)
  105c97:	83 3a 01             	cmpl   $0x1,(%edx)
  105c9a:	75 ec                	jne    105c88 <elf_load+0xa8>
            continue;

        fa = (uintptr_t) eh + rounddown(ph->p_offset, PAGESIZE);
  105c9c:	83 ec 08             	sub    $0x8,%esp
  105c9f:	68 00 10 00 00       	push   $0x1000
  105ca4:	ff 72 04             	push   0x4(%edx)
  105ca7:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  105cab:	e8 d0 f6 ff ff       	call   105380 <rounddown>
  105cb0:	03 44 24 50          	add    0x50(%esp),%eax
        va = rounddown(ph->p_va, PAGESIZE);
  105cb4:	5f                   	pop    %edi
        fa = (uintptr_t) eh + rounddown(ph->p_offset, PAGESIZE);
  105cb5:	89 c6                	mov    %eax,%esi
        va = rounddown(ph->p_va, PAGESIZE);
  105cb7:	58                   	pop    %eax
  105cb8:	68 00 10 00 00       	push   $0x1000
  105cbd:	8b 54 24 18          	mov    0x18(%esp),%edx
  105cc1:	ff 72 08             	push   0x8(%edx)
  105cc4:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  105cc8:	e8 b3 f6 ff ff       	call   105380 <rounddown>
        zva = ph->p_va + ph->p_filesz;
  105ccd:	8b 54 24 1c          	mov    0x1c(%esp),%edx
        va = rounddown(ph->p_va, PAGESIZE);
  105cd1:	89 c7                	mov    %eax,%edi
        zva = ph->p_va + ph->p_filesz;
  105cd3:	8b 4a 10             	mov    0x10(%edx),%ecx
  105cd6:	8b 42 08             	mov    0x8(%edx),%eax
  105cd9:	01 c1                	add    %eax,%ecx
  105cdb:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
        eva = roundup(ph->p_va + ph->p_memsz, PAGESIZE);
  105cdf:	83 c4 08             	add    $0x8,%esp
  105ce2:	68 00 10 00 00       	push   $0x1000
  105ce7:	03 42 14             	add    0x14(%edx),%eax
  105cea:	89 54 24 20          	mov    %edx,0x20(%esp)
  105cee:	50                   	push   %eax
  105cef:	e8 ac f6 ff ff       	call   1053a0 <roundup>

        perm = PTE_U | PTE_P;
        if (ph->p_flags & ELF_PROG_FLAG_WRITE)
  105cf4:	8b 54 24 24          	mov    0x24(%esp),%edx
        eva = roundup(ph->p_va + ph->p_memsz, PAGESIZE);
  105cf8:	89 44 24 20          	mov    %eax,0x20(%esp)
        if (ph->p_flags & ELF_PROG_FLAG_WRITE)
  105cfc:	83 c4 10             	add    $0x10,%esp
  105cff:	8b 42 18             	mov    0x18(%edx),%eax
  105d02:	83 e0 02             	and    $0x2,%eax
        perm = PTE_U | PTE_P;
  105d05:	83 f8 01             	cmp    $0x1,%eax
            perm |= PTE_W;

        for (; va < eva; va += PAGESIZE, fa += PAGESIZE) {
  105d08:	8b 44 24 10          	mov    0x10(%esp),%eax
        perm = PTE_U | PTE_P;
  105d0c:	19 c9                	sbb    %ecx,%ecx
  105d0e:	83 e1 fe             	and    $0xfffffffe,%ecx
  105d11:	83 c1 07             	add    $0x7,%ecx
        for (; va < eva; va += PAGESIZE, fa += PAGESIZE) {
  105d14:	39 c7                	cmp    %eax,%edi
  105d16:	0f 83 6c ff ff ff    	jae    105c88 <elf_load+0xa8>
  105d1c:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  105d20:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  105d24:	eb 42                	jmp    105d68 <elf_load+0x188>
  105d26:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105d2d:	00 
  105d2e:	66 90                	xchg   %ax,%ax
            alloc_page(pid, va, perm);

            if (va < rounddown(zva, PAGESIZE)) {
                /* copy a complete page */
                pt_copyout((void *) fa, pid, va, PAGESIZE);
            } else if (va < zva && ph->p_filesz) {
  105d30:	8b 44 24 0c          	mov    0xc(%esp),%eax
  105d34:	39 c7                	cmp    %eax,%edi
  105d36:	73 0b                	jae    105d43 <elf_load+0x163>
  105d38:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  105d3c:	8b 40 10             	mov    0x10(%eax),%eax
  105d3f:	85 c0                	test   %eax,%eax
  105d41:	75 5d                	jne    105da0 <elf_load+0x1c0>
                /* copy a partial page */
                pt_memset(pid, va, 0, PAGESIZE);
                pt_copyout((void *) fa, pid, va, zva - va);
            } else {
                /* zero a page */
                pt_memset(pid, va, 0, PAGESIZE);
  105d43:	68 00 10 00 00       	push   $0x1000
  105d48:	6a 00                	push   $0x0
  105d4a:	57                   	push   %edi
  105d4b:	55                   	push   %ebp
  105d4c:	e8 bf fd ff ff       	call   105b10 <pt_memset>
  105d51:	83 c4 10             	add    $0x10,%esp
        for (; va < eva; va += PAGESIZE, fa += PAGESIZE) {
  105d54:	8b 44 24 10          	mov    0x10(%esp),%eax
  105d58:	81 c7 00 10 00 00    	add    $0x1000,%edi
  105d5e:	81 c6 00 10 00 00    	add    $0x1000,%esi
  105d64:	39 c7                	cmp    %eax,%edi
  105d66:	73 60                	jae    105dc8 <elf_load+0x1e8>
            alloc_page(pid, va, perm);
  105d68:	83 ec 04             	sub    $0x4,%esp
  105d6b:	ff 74 24 18          	push   0x18(%esp)
  105d6f:	57                   	push   %edi
  105d70:	55                   	push   %ebp
  105d71:	e8 7a 15 00 00       	call   1072f0 <alloc_page>
            if (va < rounddown(zva, PAGESIZE)) {
  105d76:	5a                   	pop    %edx
  105d77:	59                   	pop    %ecx
  105d78:	68 00 10 00 00       	push   $0x1000
  105d7d:	ff 74 24 18          	push   0x18(%esp)
  105d81:	e8 fa f5 ff ff       	call   105380 <rounddown>
  105d86:	83 c4 10             	add    $0x10,%esp
  105d89:	39 c7                	cmp    %eax,%edi
  105d8b:	73 a3                	jae    105d30 <elf_load+0x150>
                pt_copyout((void *) fa, pid, va, PAGESIZE);
  105d8d:	68 00 10 00 00       	push   $0x1000
  105d92:	57                   	push   %edi
  105d93:	55                   	push   %ebp
  105d94:	56                   	push   %esi
  105d95:	e8 86 fc ff ff       	call   105a20 <pt_copyout>
  105d9a:	83 c4 10             	add    $0x10,%esp
  105d9d:	eb b5                	jmp    105d54 <elf_load+0x174>
  105d9f:	90                   	nop
                pt_memset(pid, va, 0, PAGESIZE);
  105da0:	68 00 10 00 00       	push   $0x1000
  105da5:	6a 00                	push   $0x0
  105da7:	57                   	push   %edi
  105da8:	55                   	push   %ebp
  105da9:	e8 62 fd ff ff       	call   105b10 <pt_memset>
                pt_copyout((void *) fa, pid, va, zva - va);
  105dae:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  105db2:	29 f8                	sub    %edi,%eax
  105db4:	50                   	push   %eax
  105db5:	57                   	push   %edi
  105db6:	55                   	push   %ebp
  105db7:	56                   	push   %esi
  105db8:	e8 63 fc ff ff       	call   105a20 <pt_copyout>
  105dbd:	83 c4 20             	add    $0x20,%esp
  105dc0:	eb 92                	jmp    105d54 <elf_load+0x174>
  105dc2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  105dc8:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    for (; ph < eph; ph++) {
  105dcc:	8b 44 24 18          	mov    0x18(%esp),%eax
  105dd0:	83 c2 20             	add    $0x20,%edx
  105dd3:	39 c2                	cmp    %eax,%edx
  105dd5:	0f 82 bc fe ff ff    	jb     105c97 <elf_load+0xb7>
            }
        }
    }
}
  105ddb:	83 c4 2c             	add    $0x2c,%esp
  105dde:	5b                   	pop    %ebx
  105ddf:	5e                   	pop    %esi
  105de0:	5f                   	pop    %edi
  105de1:	5d                   	pop    %ebp
  105de2:	c3                   	ret
  105de3:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    KERN_ASSERT(eh->e_shstrndx != ELF_SHN_UNDEF);
  105de8:	8d 83 a8 71 ff ff    	lea    -0x8e58(%ebx),%eax
  105dee:	50                   	push   %eax
  105def:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  105df5:	50                   	push   %eax
  105df6:	8d 83 34 65 ff ff    	lea    -0x9acc(%ebx),%eax
  105dfc:	6a 1f                	push   $0x1f
  105dfe:	50                   	push   %eax
  105dff:	e8 ec e9 ff ff       	call   1047f0 <debug_panic>
    strtab = (char *) (exe + sh[eh->e_shstrndx].sh_offset);
  105e04:	8b 44 24 50          	mov    0x50(%esp),%eax
  105e08:	83 c4 10             	add    $0x10,%esp
  105e0b:	0f b7 40 32          	movzwl 0x32(%eax),%eax
  105e0f:	e9 1e fe ff ff       	jmp    105c32 <elf_load+0x52>
  105e14:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105e1b:	00 
  105e1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00105e20 <elf_entry>:

uintptr_t elf_entry(void *exe_ptr)
{
  105e20:	56                   	push   %esi
  105e21:	53                   	push   %ebx
  105e22:	e8 7b a5 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105e27:	81 c3 cd 11 01 00    	add    $0x111cd,%ebx
  105e2d:	83 ec 04             	sub    $0x4,%esp
  105e30:	8b 74 24 10          	mov    0x10(%esp),%esi
    uintptr_t exe = (uintptr_t) exe_ptr;
    elfhdr *eh = (elfhdr *) exe;
    KERN_ASSERT(eh->e_magic == ELF_MAGIC);
  105e34:	81 3e 7f 45 4c 46    	cmpl   $0x464c457f,(%esi)
  105e3a:	74 1f                	je     105e5b <elf_entry+0x3b>
  105e3c:	8d 83 1b 65 ff ff    	lea    -0x9ae5(%ebx),%eax
  105e42:	50                   	push   %eax
  105e43:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  105e49:	50                   	push   %eax
  105e4a:	8d 83 34 65 ff ff    	lea    -0x9acc(%ebx),%eax
  105e50:	6a 50                	push   $0x50
  105e52:	50                   	push   %eax
  105e53:	e8 98 e9 ff ff       	call   1047f0 <debug_panic>
  105e58:	83 c4 10             	add    $0x10,%esp
    return (uintptr_t) eh->e_entry;
  105e5b:	8b 46 18             	mov    0x18(%esi),%eax
}
  105e5e:	83 c4 04             	add    $0x4,%esp
  105e61:	5b                   	pop    %ebx
  105e62:	5e                   	pop    %esi
  105e63:	c3                   	ret
  105e64:	66 90                	xchg   %ax,%ax
  105e66:	66 90                	xchg   %ax,%ax
  105e68:	66 90                	xchg   %ax,%ax
  105e6a:	66 90                	xchg   %ax,%ax
  105e6c:	66 90                	xchg   %ax,%ax
  105e6e:	66 90                	xchg   %ax,%ax

00105e70 <get_kstack_pointer>:

struct kstack bsp_kstack[NUM_CPUS];
struct kstack proc_kstack[NUM_IDS];

uintptr_t *get_kstack_pointer(void)
{
  105e70:	53                   	push   %ebx
  105e71:	e8 2c a5 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105e76:	81 c3 7e 11 01 00    	add    $0x1117e,%ebx
  105e7c:	83 ec 08             	sub    $0x8,%esp
    return (uintptr_t *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  105e7f:	e8 3c f5 ff ff       	call   1053c0 <read_esp>
}
  105e84:	83 c4 08             	add    $0x8,%esp
    return (uintptr_t *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  105e87:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
  105e8c:	5b                   	pop    %ebx
  105e8d:	c3                   	ret
  105e8e:	66 90                	xchg   %ax,%ax

00105e90 <get_kstack_cpu_idx>:

int get_kstack_cpu_idx(void)
{
  105e90:	53                   	push   %ebx
  105e91:	e8 0c a5 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105e96:	81 c3 5e 11 01 00    	add    $0x1115e,%ebx
  105e9c:	83 ec 08             	sub    $0x8,%esp
    return (uintptr_t *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  105e9f:	e8 1c f5 ff ff       	call   1053c0 <read_esp>
  105ea4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    struct kstack *ks = (struct kstack *) get_kstack_pointer();
    return ks->cpu_idx;
  105ea9:	8b 80 1c 01 00 00    	mov    0x11c(%eax),%eax
}
  105eaf:	83 c4 08             	add    $0x8,%esp
  105eb2:	5b                   	pop    %ebx
  105eb3:	c3                   	ret
  105eb4:	66 90                	xchg   %ax,%ax
  105eb6:	66 90                	xchg   %ax,%ax
  105eb8:	66 90                	xchg   %ax,%ax
  105eba:	66 90                	xchg   %ax,%ax
  105ebc:	66 90                	xchg   %ax,%ax
  105ebe:	66 90                	xchg   %ax,%ax

00105ec0 <spinlock_init>:
#include "spinlock.h"

extern volatile uint64_t tsc_per_ms;

void gcc_inline spinlock_init(spinlock_t *lk)
{
  105ec0:	8b 44 24 04          	mov    0x4(%esp),%eax
    lk->lock_holder = NUM_CPUS + 1;
  105ec4:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    lk->lock = 0;
  105eca:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
  105ed1:	c3                   	ret
  105ed2:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105ed9:	00 
  105eda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00105ee0 <spinlock_holding>:

bool gcc_inline spinlock_holding(spinlock_t *lk)
{
  105ee0:	57                   	push   %edi
  105ee1:	31 c0                	xor    %eax,%eax
  105ee3:	56                   	push   %esi
  105ee4:	53                   	push   %ebx
  105ee5:	8b 74 24 10          	mov    0x10(%esp),%esi
  105ee9:	e8 b4 a4 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105eee:	81 c3 06 11 01 00    	add    $0x11106,%ebx
    if (!lk->lock)
  105ef4:	8b 56 04             	mov    0x4(%esi),%edx
  105ef7:	85 d2                	test   %edx,%edx
  105ef9:	75 05                	jne    105f00 <spinlock_holding+0x20>
        return FALSE;

    struct kstack *kstack = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
    KERN_ASSERT(kstack->magic == KSTACK_MAGIC);
    return lk->lock_holder == kstack->cpu_idx;
}
  105efb:	5b                   	pop    %ebx
  105efc:	5e                   	pop    %esi
  105efd:	5f                   	pop    %edi
  105efe:	c3                   	ret
  105eff:	90                   	nop
    struct kstack *kstack = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  105f00:	e8 bb f4 ff ff       	call   1053c0 <read_esp>
  105f05:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    KERN_ASSERT(kstack->magic == KSTACK_MAGIC);
  105f0a:	81 b8 20 01 00 00 32 	cmpl   $0x98765432,0x120(%eax)
  105f11:	54 76 98 
    struct kstack *kstack = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  105f14:	89 c7                	mov    %eax,%edi
    KERN_ASSERT(kstack->magic == KSTACK_MAGIC);
  105f16:	74 1f                	je     105f37 <spinlock_holding+0x57>
  105f18:	8d 83 43 65 ff ff    	lea    -0x9abd(%ebx),%eax
  105f1e:	50                   	push   %eax
  105f1f:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  105f25:	50                   	push   %eax
  105f26:	8d 83 61 65 ff ff    	lea    -0x9a9f(%ebx),%eax
  105f2c:	6a 16                	push   $0x16
  105f2e:	50                   	push   %eax
  105f2f:	e8 bc e8 ff ff       	call   1047f0 <debug_panic>
  105f34:	83 c4 10             	add    $0x10,%esp
    return lk->lock_holder == kstack->cpu_idx;
  105f37:	8b 87 1c 01 00 00    	mov    0x11c(%edi),%eax
  105f3d:	39 06                	cmp    %eax,(%esi)
}
  105f3f:	5b                   	pop    %ebx
    return lk->lock_holder == kstack->cpu_idx;
  105f40:	0f 94 c0             	sete   %al
}
  105f43:	5e                   	pop    %esi
  105f44:	5f                   	pop    %edi
  105f45:	c3                   	ret
  105f46:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105f4d:	00 
  105f4e:	66 90                	xchg   %ax,%ax

00105f50 <spinlock_acquire>:

    return spinlock_try_acquire_A(lk);
}
#else   /* DEBUG_LOCKHOLDING */
void gcc_inline spinlock_acquire(spinlock_t *lk)
{
  105f50:	57                   	push   %edi
  105f51:	56                   	push   %esi
  105f52:	53                   	push   %ebx
  105f53:	8b 7c 24 10          	mov    0x10(%esp),%edi
    while (xchg(&lk->lock, 1) != 0)
  105f57:	e8 46 a4 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105f5c:	81 c3 98 10 01 00    	add    $0x11098,%ebx
  105f62:	8d 77 04             	lea    0x4(%edi),%esi
  105f65:	eb 0e                	jmp    105f75 <spinlock_acquire+0x25>
  105f67:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  105f6e:	00 
  105f6f:	90                   	nop
        pause();
  105f70:	e8 cb f4 ff ff       	call   105440 <pause>
    while (xchg(&lk->lock, 1) != 0)
  105f75:	83 ec 08             	sub    $0x8,%esp
  105f78:	6a 01                	push   $0x1
  105f7a:	56                   	push   %esi
  105f7b:	e8 d0 f4 ff ff       	call   105450 <xchg>
  105f80:	83 c4 10             	add    $0x10,%esp
  105f83:	85 c0                	test   %eax,%eax
  105f85:	75 e9                	jne    105f70 <spinlock_acquire+0x20>
    struct kstack *kstack = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  105f87:	e8 34 f4 ff ff       	call   1053c0 <read_esp>
  105f8c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    KERN_ASSERT(kstack->magic == KSTACK_MAGIC);
  105f91:	81 b8 20 01 00 00 32 	cmpl   $0x98765432,0x120(%eax)
  105f98:	54 76 98 
    struct kstack *kstack = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  105f9b:	89 c6                	mov    %eax,%esi
    KERN_ASSERT(kstack->magic == KSTACK_MAGIC);
  105f9d:	74 1f                	je     105fbe <spinlock_acquire+0x6e>
  105f9f:	8d 83 43 65 ff ff    	lea    -0x9abd(%ebx),%eax
  105fa5:	50                   	push   %eax
  105fa6:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  105fac:	50                   	push   %eax
  105fad:	8d 83 61 65 ff ff    	lea    -0x9a9f(%ebx),%eax
  105fb3:	6a 2f                	push   $0x2f
  105fb5:	50                   	push   %eax
  105fb6:	e8 35 e8 ff ff       	call   1047f0 <debug_panic>
  105fbb:	83 c4 10             	add    $0x10,%esp
    lk->lock_holder = kstack->cpu_idx;
  105fbe:	8b 86 1c 01 00 00    	mov    0x11c(%esi),%eax
  105fc4:	89 07                	mov    %eax,(%edi)
    spinlock_acquire_A(lk);
}
  105fc6:	5b                   	pop    %ebx
  105fc7:	5e                   	pop    %esi
  105fc8:	5f                   	pop    %edi
  105fc9:	c3                   	ret
  105fca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00105fd0 <spinlock_release>:

void gcc_inline spinlock_release(spinlock_t *lk)
{
  105fd0:	53                   	push   %ebx
  105fd1:	e8 cc a3 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  105fd6:	81 c3 1e 10 01 00    	add    $0x1101e,%ebx
  105fdc:	83 ec 10             	sub    $0x10,%esp
  105fdf:	8b 44 24 18          	mov    0x18(%esp),%eax
    lk->lock_holder = NUM_CPUS + 1;
  105fe3:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    xchg(&lk->lock, 0);
  105fe9:	83 c0 04             	add    $0x4,%eax
  105fec:	6a 00                	push   $0x0
  105fee:	50                   	push   %eax
  105fef:	e8 5c f4 ff ff       	call   105450 <xchg>
    spinlock_release_A(lk);
}
  105ff4:	83 c4 18             	add    $0x18,%esp
  105ff7:	5b                   	pop    %ebx
  105ff8:	c3                   	ret
  105ff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00106000 <spinlock_try_acquire>:

int gcc_inline spinlock_try_acquire(spinlock_t *lk)
{
  106000:	55                   	push   %ebp
  106001:	57                   	push   %edi
  106002:	56                   	push   %esi
  106003:	53                   	push   %ebx
  106004:	e8 99 a3 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106009:	81 c3 eb 0f 01 00    	add    $0x10feb,%ebx
  10600f:	83 ec 14             	sub    $0x14,%esp
  106012:	8b 7c 24 28          	mov    0x28(%esp),%edi
    uint32_t old_val = xchg(&lk->lock, 1);
  106016:	6a 01                	push   $0x1
  106018:	8d 47 04             	lea    0x4(%edi),%eax
  10601b:	50                   	push   %eax
  10601c:	e8 2f f4 ff ff       	call   105450 <xchg>
    if (old_val == 0) {
  106021:	83 c4 10             	add    $0x10,%esp
    uint32_t old_val = xchg(&lk->lock, 1);
  106024:	89 c6                	mov    %eax,%esi
    if (old_val == 0) {
  106026:	85 c0                	test   %eax,%eax
  106028:	74 0e                	je     106038 <spinlock_try_acquire+0x38>
    return spinlock_try_acquire_A(lk);
}
  10602a:	83 c4 0c             	add    $0xc,%esp
  10602d:	89 f0                	mov    %esi,%eax
  10602f:	5b                   	pop    %ebx
  106030:	5e                   	pop    %esi
  106031:	5f                   	pop    %edi
  106032:	5d                   	pop    %ebp
  106033:	c3                   	ret
  106034:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        struct kstack *kstack = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  106038:	e8 83 f3 ff ff       	call   1053c0 <read_esp>
  10603d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
        KERN_ASSERT(kstack->magic == KSTACK_MAGIC);
  106042:	81 b8 20 01 00 00 32 	cmpl   $0x98765432,0x120(%eax)
  106049:	54 76 98 
        struct kstack *kstack = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  10604c:	89 c5                	mov    %eax,%ebp
        KERN_ASSERT(kstack->magic == KSTACK_MAGIC);
  10604e:	75 18                	jne    106068 <spinlock_try_acquire+0x68>
        lk->lock_holder = kstack->cpu_idx;
  106050:	8b 85 1c 01 00 00    	mov    0x11c(%ebp),%eax
  106056:	89 07                	mov    %eax,(%edi)
}
  106058:	83 c4 0c             	add    $0xc,%esp
  10605b:	89 f0                	mov    %esi,%eax
  10605d:	5b                   	pop    %ebx
  10605e:	5e                   	pop    %esi
  10605f:	5f                   	pop    %edi
  106060:	5d                   	pop    %ebp
  106061:	c3                   	ret
  106062:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        KERN_ASSERT(kstack->magic == KSTACK_MAGIC);
  106068:	8d 83 43 65 ff ff    	lea    -0x9abd(%ebx),%eax
  10606e:	50                   	push   %eax
  10606f:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  106075:	50                   	push   %eax
  106076:	8d 83 61 65 ff ff    	lea    -0x9a9f(%ebx),%eax
  10607c:	6a 39                	push   $0x39
  10607e:	50                   	push   %eax
  10607f:	e8 6c e7 ff ff       	call   1047f0 <debug_panic>
        lk->lock_holder = kstack->cpu_idx;
  106084:	8b 85 1c 01 00 00    	mov    0x11c(%ebp),%eax
        KERN_ASSERT(kstack->magic == KSTACK_MAGIC);
  10608a:	83 c4 10             	add    $0x10,%esp
        lk->lock_holder = kstack->cpu_idx;
  10608d:	89 07                	mov    %eax,(%edi)
  10608f:	eb c7                	jmp    106058 <spinlock_try_acquire+0x58>
  106091:	66 90                	xchg   %ax,%ax
  106093:	66 90                	xchg   %ax,%ax
  106095:	66 90                	xchg   %ax,%ax
  106097:	66 90                	xchg   %ax,%ax
  106099:	66 90                	xchg   %ax,%ax
  10609b:	66 90                	xchg   %ax,%ax
  10609d:	66 90                	xchg   %ax,%ax
  10609f:	90                   	nop

001060a0 <reentrantlock_init>:
#include "reentrant_lock.h"

#define UNLOCKED    0xFFFFFFFF

void reentrantlock_init(reentrantlock *lk)
{
  1060a0:	8b 44 24 04          	mov    0x4(%esp),%eax
    lk->lock = UNLOCKED;
  1060a4:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    lk->count = 0u;
  1060aa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
  1060b1:	c3                   	ret
  1060b2:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1060b9:	00 
  1060ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001060c0 <reentrantlock_holding>:

bool reentrantlock_holding(reentrantlock *lk)
{
    if (lk->count > 0u)
  1060c0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1060c4:	8b 40 04             	mov    0x4(%eax),%eax
  1060c7:	85 c0                	test   %eax,%eax
  1060c9:	0f 95 c0             	setne  %al
        return TRUE;
    else
        return FALSE;
}
  1060cc:	c3                   	ret
  1060cd:	8d 76 00             	lea    0x0(%esi),%esi

001060d0 <reentrantlock_acquire>:

void reentrantlock_acquire(reentrantlock *lk)
{
  1060d0:	57                   	push   %edi
  1060d1:	56                   	push   %esi
  1060d2:	53                   	push   %ebx
  1060d3:	8b 7c 24 10          	mov    0x10(%esp),%edi
  1060d7:	e8 c6 a2 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1060dc:	81 c3 18 0f 01 00    	add    $0x10f18,%ebx
    uint32_t cpuid = get_kstack_cpu_idx();
  1060e2:	e8 a9 fd ff ff       	call   105e90 <get_kstack_cpu_idx>
  1060e7:	89 c6                	mov    %eax,%esi
  1060e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    uint32_t lv;

    do {
        lv = cmpxchg(&lk->lock, UNLOCKED, cpuid);
  1060f0:	83 ec 04             	sub    $0x4,%esp
  1060f3:	56                   	push   %esi
  1060f4:	6a ff                	push   $0xffffffff
  1060f6:	57                   	push   %edi
  1060f7:	e8 64 f3 ff ff       	call   105460 <cmpxchg>
    } while (lv != cpuid && lv != UNLOCKED);
  1060fc:	83 c4 10             	add    $0x10,%esp
  1060ff:	39 c6                	cmp    %eax,%esi
  106101:	74 05                	je     106108 <reentrantlock_acquire+0x38>
  106103:	83 f8 ff             	cmp    $0xffffffff,%eax
  106106:	75 e8                	jne    1060f0 <reentrantlock_acquire+0x20>
    lk->count++;
  106108:	8b 47 04             	mov    0x4(%edi),%eax
  10610b:	83 c0 01             	add    $0x1,%eax
  10610e:	89 47 04             	mov    %eax,0x4(%edi)
}
  106111:	5b                   	pop    %ebx
  106112:	5e                   	pop    %esi
  106113:	5f                   	pop    %edi
  106114:	c3                   	ret
  106115:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10611c:	00 
  10611d:	8d 76 00             	lea    0x0(%esi),%esi

00106120 <reentrantlock_try_acquire>:

int reentrantlock_try_acquire(reentrantlock *lk)
{
  106120:	57                   	push   %edi
  106121:	56                   	push   %esi
  106122:	53                   	push   %ebx
  106123:	8b 7c 24 10          	mov    0x10(%esp),%edi
  106127:	e8 76 a2 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10612c:	81 c3 c8 0e 01 00    	add    $0x10ec8,%ebx
    uint32_t cpuid = get_kstack_cpu_idx();
  106132:	e8 59 fd ff ff       	call   105e90 <get_kstack_cpu_idx>
    uint32_t lv;

    lv = cmpxchg(&lk->lock, UNLOCKED, cpuid);
  106137:	83 ec 04             	sub    $0x4,%esp
  10613a:	50                   	push   %eax
    uint32_t cpuid = get_kstack_cpu_idx();
  10613b:	89 c6                	mov    %eax,%esi
    lv = cmpxchg(&lk->lock, UNLOCKED, cpuid);
  10613d:	6a ff                	push   $0xffffffff
  10613f:	57                   	push   %edi
  106140:	e8 1b f3 ff ff       	call   105460 <cmpxchg>

    if (lv == cpuid || lv == UNLOCKED) {
  106145:	83 c4 10             	add    $0x10,%esp
  106148:	39 c6                	cmp    %eax,%esi
  10614a:	74 14                	je     106160 <reentrantlock_try_acquire+0x40>
        lk->count++;
        return 1;
    } else
        return 0;
  10614c:	31 d2                	xor    %edx,%edx
    if (lv == cpuid || lv == UNLOCKED) {
  10614e:	83 f8 ff             	cmp    $0xffffffff,%eax
  106151:	74 0d                	je     106160 <reentrantlock_try_acquire+0x40>
}
  106153:	5b                   	pop    %ebx
  106154:	89 d0                	mov    %edx,%eax
  106156:	5e                   	pop    %esi
  106157:	5f                   	pop    %edi
  106158:	c3                   	ret
  106159:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        lk->count++;
  106160:	8b 47 04             	mov    0x4(%edi),%eax
        return 1;
  106163:	ba 01 00 00 00       	mov    $0x1,%edx
        lk->count++;
  106168:	83 c0 01             	add    $0x1,%eax
  10616b:	89 47 04             	mov    %eax,0x4(%edi)
}
  10616e:	89 d0                	mov    %edx,%eax
  106170:	5b                   	pop    %ebx
  106171:	5e                   	pop    %esi
  106172:	5f                   	pop    %edi
  106173:	c3                   	ret
  106174:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10617b:	00 
  10617c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00106180 <reentrantlock_release>:

void reentrantlock_release(reentrantlock *lk)
{
  106180:	53                   	push   %ebx
  106181:	e8 1c a2 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106186:	81 c3 6e 0e 01 00    	add    $0x10e6e,%ebx
  10618c:	83 ec 08             	sub    $0x8,%esp
  10618f:	8b 44 24 10          	mov    0x10(%esp),%eax
    lk->count--;
  106193:	8b 50 04             	mov    0x4(%eax),%edx
  106196:	83 ea 01             	sub    $0x1,%edx
  106199:	89 50 04             	mov    %edx,0x4(%eax)
    if (lk->count == 0u) {
  10619c:	8b 50 04             	mov    0x4(%eax),%edx
  10619f:	85 d2                	test   %edx,%edx
  1061a1:	74 0d                	je     1061b0 <reentrantlock_release+0x30>
        xchg(&lk->lock, UNLOCKED);
    }
}
  1061a3:	83 c4 08             	add    $0x8,%esp
  1061a6:	5b                   	pop    %ebx
  1061a7:	c3                   	ret
  1061a8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1061af:	00 
        xchg(&lk->lock, UNLOCKED);
  1061b0:	83 ec 08             	sub    $0x8,%esp
  1061b3:	6a ff                	push   $0xffffffff
  1061b5:	50                   	push   %eax
  1061b6:	e8 95 f2 ff ff       	call   105450 <xchg>
  1061bb:	83 c4 10             	add    $0x10,%esp
}
  1061be:	83 c4 08             	add    $0x8,%esp
  1061c1:	5b                   	pop    %ebx
  1061c2:	c3                   	ret
  1061c3:	66 90                	xchg   %ax,%ax
  1061c5:	66 90                	xchg   %ax,%ax
  1061c7:	66 90                	xchg   %ax,%ax
  1061c9:	66 90                	xchg   %ax,%ax
  1061cb:	66 90                	xchg   %ax,%ax
  1061cd:	66 90                	xchg   %ax,%ax
  1061cf:	90                   	nop

001061d0 <pcpu_set_zero>:
struct pcpu pcpu[NUM_CPUS];

extern int get_kstack_cpu_idx(void);

void pcpu_set_zero()
{
  1061d0:	53                   	push   %ebx
  1061d1:	e8 cc a1 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1061d6:	81 c3 1e 0e 01 00    	add    $0x10e1e,%ebx
  1061dc:	83 ec 10             	sub    $0x10,%esp
    memzero(pcpu, sizeof(struct pcpu) * NUM_CPUS);
  1061df:	68 80 02 00 00       	push   $0x280
  1061e4:	8d 83 0c 30 0d 00    	lea    0xd300c(%ebx),%eax
  1061ea:	50                   	push   %eax
  1061eb:	e8 10 e4 ff ff       	call   104600 <memzero>
}
  1061f0:	83 c4 18             	add    $0x18,%esp
  1061f3:	5b                   	pop    %ebx
  1061f4:	c3                   	ret
  1061f5:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1061fc:	00 
  1061fd:	8d 76 00             	lea    0x0(%esi),%esi

00106200 <pcpu_fields_init>:

void pcpu_fields_init(int cpu_idx)
{
    pcpu[cpu_idx].inited = TRUE;
  106200:	e8 ee cb ff ff       	call   102df3 <__x86.get_pc_thunk.cx>
  106205:	81 c1 ef 0d 01 00    	add    $0x10def,%ecx
{
  10620b:	8b 54 24 04          	mov    0x4(%esp),%edx
    pcpu[cpu_idx].inited = TRUE;
  10620f:	8d 04 92             	lea    (%edx,%edx,4),%eax
  106212:	c1 e0 04             	shl    $0x4,%eax
  106215:	c6 84 01 0c 30 0d 00 	movb   $0x1,0xd300c(%ecx,%eax,1)
  10621c:	01 
    pcpu[cpu_idx].cpu_idx = cpu_idx;
  10621d:	89 94 01 58 30 0d 00 	mov    %edx,0xd3058(%ecx,%eax,1)
}
  106224:	c3                   	ret
  106225:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10622c:	00 
  10622d:	8d 76 00             	lea    0x0(%esi),%esi

00106230 <pcpu_cur>:

struct pcpu *pcpu_cur(void)
{
  106230:	53                   	push   %ebx
  106231:	e8 6c a1 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106236:	81 c3 be 0d 01 00    	add    $0x10dbe,%ebx
  10623c:	83 ec 08             	sub    $0x8,%esp
    int cpu_idx = get_kstack_cpu_idx();
  10623f:	e8 4c fc ff ff       	call   105e90 <get_kstack_cpu_idx>
    return &pcpu[cpu_idx];
}
  106244:	83 c4 08             	add    $0x8,%esp
    return &pcpu[cpu_idx];
  106247:	8d 04 80             	lea    (%eax,%eax,4),%eax
  10624a:	c1 e0 04             	shl    $0x4,%eax
  10624d:	8d 84 03 0c 30 0d 00 	lea    0xd300c(%ebx,%eax,1),%eax
}
  106254:	5b                   	pop    %ebx
  106255:	c3                   	ret
  106256:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10625d:	00 
  10625e:	66 90                	xchg   %ax,%ax

00106260 <get_pcpu_idx>:

int get_pcpu_idx(void)
{
  106260:	53                   	push   %ebx
  106261:	e8 3c a1 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106266:	81 c3 8e 0d 01 00    	add    $0x10d8e,%ebx
  10626c:	83 ec 08             	sub    $0x8,%esp
    int cpu_idx = get_kstack_cpu_idx();
  10626f:	e8 1c fc ff ff       	call   105e90 <get_kstack_cpu_idx>
    return pcpu_cur()->cpu_idx;
  106274:	8d 04 80             	lea    (%eax,%eax,4),%eax
  106277:	c1 e0 04             	shl    $0x4,%eax
  10627a:	8b 84 03 58 30 0d 00 	mov    0xd3058(%ebx,%eax,1),%eax
}
  106281:	83 c4 08             	add    $0x8,%esp
  106284:	5b                   	pop    %ebx
  106285:	c3                   	ret
  106286:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10628d:	00 
  10628e:	66 90                	xchg   %ax,%ax

00106290 <set_pcpu_idx>:

void set_pcpu_idx(int index, int cpu_idx)
{
    pcpu[index].cpu_idx = cpu_idx;
  106290:	e8 09 a1 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106295:	81 c2 5f 0d 01 00    	add    $0x10d5f,%edx
{
  10629b:	8b 44 24 04          	mov    0x4(%esp),%eax
    pcpu[index].cpu_idx = cpu_idx;
  10629f:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1062a3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  1062a6:	c1 e0 04             	shl    $0x4,%eax
  1062a9:	89 8c 02 58 30 0d 00 	mov    %ecx,0xd3058(%edx,%eax,1)
}
  1062b0:	c3                   	ret
  1062b1:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1062b8:	00 
  1062b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001062c0 <get_pcpu_kstack_pointer>:

uintptr_t *get_pcpu_kstack_pointer(int cpu_idx)
{
    return pcpu[cpu_idx].kstack;
  1062c0:	e8 d9 a0 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  1062c5:	81 c2 2f 0d 01 00    	add    $0x10d2f,%edx
{
  1062cb:	8b 44 24 04          	mov    0x4(%esp),%eax
    return pcpu[cpu_idx].kstack;
  1062cf:	8d 04 80             	lea    (%eax,%eax,4),%eax
  1062d2:	c1 e0 04             	shl    $0x4,%eax
  1062d5:	8b 84 02 10 30 0d 00 	mov    0xd3010(%edx,%eax,1),%eax
}
  1062dc:	c3                   	ret
  1062dd:	8d 76 00             	lea    0x0(%esi),%esi

001062e0 <set_pcpu_kstack_pointer>:

void set_pcpu_kstack_pointer(int cpu_idx, uintptr_t *ks)
{
    pcpu[cpu_idx].kstack = ks;
  1062e0:	e8 b9 a0 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  1062e5:	81 c2 0f 0d 01 00    	add    $0x10d0f,%edx
{
  1062eb:	8b 44 24 04          	mov    0x4(%esp),%eax
    pcpu[cpu_idx].kstack = ks;
  1062ef:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1062f3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  1062f6:	c1 e0 04             	shl    $0x4,%eax
  1062f9:	89 8c 02 10 30 0d 00 	mov    %ecx,0xd3010(%edx,%eax,1)
}
  106300:	c3                   	ret
  106301:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106308:	00 
  106309:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00106310 <get_pcpu_boot_info>:

volatile bool get_pcpu_boot_info(int cpu_idx)
{
    return pcpu[cpu_idx].booted;
  106310:	e8 89 a0 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106315:	81 c2 df 0c 01 00    	add    $0x10cdf,%edx
{
  10631b:	8b 44 24 04          	mov    0x4(%esp),%eax
    return pcpu[cpu_idx].booted;
  10631f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  106322:	c1 e0 04             	shl    $0x4,%eax
  106325:	8d 84 02 0c 30 0d 00 	lea    0xd300c(%edx,%eax,1),%eax
  10632c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
}
  106330:	c3                   	ret
  106331:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106338:	00 
  106339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00106340 <set_pcpu_boot_info>:

void set_pcpu_boot_info(int cpu_idx, volatile bool boot_info)
{
    pcpu[cpu_idx].booted = boot_info;
  106340:	e8 ae ca ff ff       	call   102df3 <__x86.get_pc_thunk.cx>
  106345:	81 c1 af 0c 01 00    	add    $0x10caf,%ecx
{
  10634b:	83 ec 04             	sub    $0x4,%esp
  10634e:	8b 44 24 08          	mov    0x8(%esp),%eax
  106352:	8b 54 24 0c          	mov    0xc(%esp),%edx
    pcpu[cpu_idx].booted = boot_info;
  106356:	8d 04 80             	lea    (%eax,%eax,4),%eax
{
  106359:	88 14 24             	mov    %dl,(%esp)
    pcpu[cpu_idx].booted = boot_info;
  10635c:	0f b6 14 24          	movzbl (%esp),%edx
  106360:	c1 e0 04             	shl    $0x4,%eax
  106363:	8d 84 01 0c 30 0d 00 	lea    0xd300c(%ecx,%eax,1),%eax
  10636a:	88 50 01             	mov    %dl,0x1(%eax)
}
  10636d:	83 c4 04             	add    $0x4,%esp
  106370:	c3                   	ret
  106371:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106378:	00 
  106379:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00106380 <get_pcpu_cpu_vendor>:

cpu_vendor get_pcpu_cpu_vendor(int cpu_idx)
{
    return pcpu[cpu_idx].arch_info.cpu_vendor;
  106380:	e8 19 a0 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106385:	81 c2 6f 0c 01 00    	add    $0x10c6f,%edx
{
  10638b:	8b 44 24 04          	mov    0x4(%esp),%eax
    return pcpu[cpu_idx].arch_info.cpu_vendor;
  10638f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  106392:	c1 e0 04             	shl    $0x4,%eax
  106395:	8b 84 02 34 30 0d 00 	mov    0xd3034(%edx,%eax,1),%eax
}
  10639c:	c3                   	ret
  10639d:	8d 76 00             	lea    0x0(%esi),%esi

001063a0 <get_pcpu_arch_info_pointer>:

uintptr_t *get_pcpu_arch_info_pointer(int cpu_idx)
{
    return (uintptr_t *) &pcpu[cpu_idx].arch_info;
  1063a0:	e8 f9 9f ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  1063a5:	81 c2 4f 0c 01 00    	add    $0x10c4f,%edx
{
  1063ab:	8b 44 24 04          	mov    0x4(%esp),%eax
    return (uintptr_t *) &pcpu[cpu_idx].arch_info;
  1063af:	8d 04 80             	lea    (%eax,%eax,4),%eax
  1063b2:	c1 e0 04             	shl    $0x4,%eax
  1063b5:	8d 84 02 14 30 0d 00 	lea    0xd3014(%edx,%eax,1),%eax
}
  1063bc:	c3                   	ret
  1063bd:	8d 76 00             	lea    0x0(%esi),%esi

001063c0 <get_pcpu_inited_info>:

bool get_pcpu_inited_info(int cpu_idx)
{
    return pcpu[cpu_idx].inited;
  1063c0:	e8 d9 9f ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  1063c5:	81 c2 2f 0c 01 00    	add    $0x10c2f,%edx
{
  1063cb:	8b 44 24 04          	mov    0x4(%esp),%eax
    return pcpu[cpu_idx].inited;
  1063cf:	8d 04 80             	lea    (%eax,%eax,4),%eax
  1063d2:	c1 e0 04             	shl    $0x4,%eax
  1063d5:	0f b6 84 02 0c 30 0d 	movzbl 0xd300c(%edx,%eax,1),%eax
  1063dc:	00 
}
  1063dd:	c3                   	ret
  1063de:	66 90                	xchg   %ax,%ax

001063e0 <pcpu_init>:
#include "import.h"

static bool pcpu_inited = FALSE;

void pcpu_init(void)
{
  1063e0:	55                   	push   %ebp
  1063e1:	57                   	push   %edi
  1063e2:	56                   	push   %esi
  1063e3:	53                   	push   %ebx
  1063e4:	e8 b9 9f ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1063e9:	81 c3 0b 0c 01 00    	add    $0x10c0b,%ebx
  1063ef:	83 ec 0c             	sub    $0xc,%esp
    struct kstack *ks = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  1063f2:	e8 c9 ef ff ff       	call   1053c0 <read_esp>
  1063f7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    int cpu_idx = ks->cpu_idx;
  1063fc:	8b b8 1c 01 00 00    	mov    0x11c(%eax),%edi
    struct kstack *ks = (struct kstack *) ROUNDDOWN(read_esp(), KSTACK_SIZE);
  106402:	89 c5                	mov    %eax,%ebp
    int i;

    if (cpu_idx == 0) {
  106404:	85 ff                	test   %edi,%edi
  106406:	75 33                	jne    10643b <pcpu_init+0x5b>
        if (pcpu_inited == TRUE)
  106408:	80 bb 8c 32 0d 00 01 	cmpb   $0x1,0xd328c(%ebx)
  10640f:	74 4f                	je     106460 <pcpu_init+0x80>
            return;

        pcpu_set_zero();
  106411:	e8 ba fd ff ff       	call   1061d0 <pcpu_set_zero>

        /* Probe SMP. */
        pcpu_mp_init();

        for (i = 0; i < NUM_CPUS; i++) {
  106416:	31 f6                	xor    %esi,%esi
        pcpu_mp_init();
  106418:	e8 73 ca ff ff       	call   102e90 <pcpu_mp_init>
        for (i = 0; i < NUM_CPUS; i++) {
  10641d:	8d 76 00             	lea    0x0(%esi),%esi
            pcpu_fields_init(i);
  106420:	83 ec 0c             	sub    $0xc,%esp
  106423:	56                   	push   %esi
        for (i = 0; i < NUM_CPUS; i++) {
  106424:	83 c6 01             	add    $0x1,%esi
            pcpu_fields_init(i);
  106427:	e8 d4 fd ff ff       	call   106200 <pcpu_fields_init>
        for (i = 0; i < NUM_CPUS; i++) {
  10642c:	83 c4 10             	add    $0x10,%esp
  10642f:	83 fe 08             	cmp    $0x8,%esi
  106432:	75 ec                	jne    106420 <pcpu_init+0x40>
        }

        pcpu_inited = TRUE;
  106434:	c6 83 8c 32 0d 00 01 	movb   $0x1,0xd328c(%ebx)
    }

    set_pcpu_idx(cpu_idx, cpu_idx);
  10643b:	83 ec 08             	sub    $0x8,%esp
  10643e:	57                   	push   %edi
  10643f:	57                   	push   %edi
  106440:	e8 4b fe ff ff       	call   106290 <set_pcpu_idx>
    set_pcpu_kstack_pointer(cpu_idx, (uintptr_t *) ks);
  106445:	58                   	pop    %eax
  106446:	5a                   	pop    %edx
  106447:	55                   	push   %ebp
  106448:	57                   	push   %edi
  106449:	e8 92 fe ff ff       	call   1062e0 <set_pcpu_kstack_pointer>
    set_pcpu_boot_info(cpu_idx, TRUE);
  10644e:	59                   	pop    %ecx
  10644f:	5e                   	pop    %esi
  106450:	6a 01                	push   $0x1
  106452:	57                   	push   %edi
  106453:	e8 e8 fe ff ff       	call   106340 <set_pcpu_boot_info>
    pcpu_init_cpu();
  106458:	e8 43 d2 ff ff       	call   1036a0 <pcpu_init_cpu>
  10645d:	83 c4 10             	add    $0x10,%esp
}
  106460:	83 c4 0c             	add    $0xc,%esp
  106463:	5b                   	pop    %ebx
  106464:	5e                   	pop    %esi
  106465:	5f                   	pop    %edi
  106466:	5d                   	pop    %ebp
  106467:	c3                   	ret
  106468:	66 90                	xchg   %ax,%ax
  10646a:	66 90                	xchg   %ax,%ax
  10646c:	66 90                	xchg   %ax,%ax
  10646e:	66 90                	xchg   %ax,%ax

00106470 <kern_init>:

    cpu_booted++;
}

void kern_init(uintptr_t mbi_addr)
{
  106470:	57                   	push   %edi
  106471:	56                   	push   %esi
  106472:	53                   	push   %ebx
  106473:	e8 2a 9f ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106478:	81 c3 7c 0b 01 00    	add    $0x10b7c,%ebx
    thread_init(mbi_addr);
  10647e:	83 ec 0c             	sub    $0xc,%esp
  106481:	ff 74 24 1c          	push   0x1c(%esp)
  106485:	e8 e6 15 00 00       	call   107a70 <thread_init>
    KERN_INFO("[BSP KERN] Kernel initialized.\n");
  10648a:	8d 83 f8 71 ff ff    	lea    -0x8e08(%ebx),%eax
  106490:	89 04 24             	mov    %eax,(%esp)
  106493:	e8 b8 e2 ff ff       	call   104750 <debug_info>
    KERN_INFO("[BSP KERN] In kernel main.\n\n");
  106498:	8d 83 75 65 ff ff    	lea    -0x9a8b(%ebx),%eax
  10649e:	89 04 24             	mov    %eax,(%esp)
  1064a1:	e8 aa e2 ff ff       	call   104750 <debug_info>
    KERN_INFO("[BSP KERN] Number of CPUs in this system: %d. \n", pcpu_ncpu());
  1064a6:	e8 25 d6 ff ff       	call   103ad0 <pcpu_ncpu>
  1064ab:	5a                   	pop    %edx
  1064ac:	59                   	pop    %ecx
  1064ad:	50                   	push   %eax
  1064ae:	8d 83 18 72 ff ff    	lea    -0x8de8(%ebx),%eax
  1064b4:	50                   	push   %eax
  1064b5:	e8 96 e2 ff ff       	call   104750 <debug_info>
    int cpu_idx = get_pcpu_idx();
  1064ba:	e8 a1 fd ff ff       	call   106260 <get_pcpu_idx>
    pid = proc_create(_binary___obj_user_idle_idle_start, 10000);
  1064bf:	5e                   	pop    %esi
    int cpu_idx = get_pcpu_idx();
  1064c0:	89 c7                	mov    %eax,%edi
    pid = proc_create(_binary___obj_user_idle_idle_start, 10000);
  1064c2:	58                   	pop    %eax
  1064c3:	68 10 27 00 00       	push   $0x2710
  1064c8:	ff b3 ec ff ff ff    	push   -0x14(%ebx)
  1064ce:	e8 ed 1a 00 00       	call   107fc0 <proc_create>
    KERN_INFO("CPU%d: process idle %d is created.\n", cpu_idx, pid);
  1064d3:	83 c4 0c             	add    $0xc,%esp
  1064d6:	50                   	push   %eax
    pid = proc_create(_binary___obj_user_idle_idle_start, 10000);
  1064d7:	89 c6                	mov    %eax,%esi
    KERN_INFO("CPU%d: process idle %d is created.\n", cpu_idx, pid);
  1064d9:	8d 83 48 72 ff ff    	lea    -0x8db8(%ebx),%eax
  1064df:	57                   	push   %edi
  1064e0:	50                   	push   %eax
  1064e1:	e8 6a e2 ff ff       	call   104750 <debug_info>
    tqueue_remove(NUM_IDS, pid);
  1064e6:	58                   	pop    %eax
  1064e7:	5a                   	pop    %edx
  1064e8:	56                   	push   %esi
  1064e9:	6a 40                	push   $0x40
  1064eb:	e8 40 14 00 00       	call   107930 <tqueue_remove>
    tcb_set_state(pid, TSTATE_RUN);
  1064f0:	59                   	pop    %ecx
  1064f1:	5f                   	pop    %edi
  1064f2:	6a 01                	push   $0x1
  1064f4:	56                   	push   %esi
  1064f5:	e8 d6 0f 00 00       	call   1074d0 <tcb_set_state>
    set_curid(pid);
  1064fa:	89 34 24             	mov    %esi,(%esp)
  1064fd:	e8 3e 15 00 00       	call   107a40 <set_curid>
    kctx_switch(0, pid);
  106502:	58                   	pop    %eax
  106503:	5a                   	pop    %edx
  106504:	56                   	push   %esi
  106505:	6a 00                	push   $0x0
  106507:	e8 a4 0e 00 00       	call   1073b0 <kctx_switch>
    KERN_PANIC("kern_main() should never reach here.\n");
  10650c:	83 c4 0c             	add    $0xc,%esp
  10650f:	8d 83 6c 72 ff ff    	lea    -0x8d94(%ebx),%eax
  106515:	50                   	push   %eax
  106516:	8d 83 92 65 ff ff    	lea    -0x9a6e(%ebx),%eax
  10651c:	6a 27                	push   $0x27
  10651e:	50                   	push   %eax
  10651f:	e8 cc e2 ff ff       	call   1047f0 <debug_panic>
    kern_main();
}
  106524:	83 c4 10             	add    $0x10,%esp
  106527:	5b                   	pop    %ebx
  106528:	5e                   	pop    %esi
  106529:	5f                   	pop    %edi
  10652a:	c3                   	ret
  10652b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00106530 <kern_init_ap>:

void kern_init_ap(void (*f)(void))
{
  106530:	56                   	push   %esi
  106531:	53                   	push   %ebx
  106532:	e8 6b 9e ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106537:	81 c3 bd 0a 01 00    	add    $0x10abd,%ebx
  10653d:	83 ec 04             	sub    $0x4,%esp
  106540:	8b 74 24 10          	mov    0x10(%esp),%esi
    devinit_ap();
  106544:	e8 07 a6 ff ff       	call   100b50 <devinit_ap>
    f();
}
  106549:	83 c4 04             	add    $0x4,%esp
    f();
  10654c:	89 f0                	mov    %esi,%eax
}
  10654e:	5b                   	pop    %ebx
  10654f:	5e                   	pop    %esi
    f();
  106550:	ff e0                	jmp    *%eax
  106552:	66 90                	xchg   %ax,%ax
  106554:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  10655a:	00 00                	add    %al,(%eax)
  10655c:	fb                   	sti
  10655d:	4f                   	dec    %edi
  10655e:	52                   	push   %edx
  10655f:	e4                   	.byte 0xe4

00106560 <start>:
	.long CHECKSUM

	/* this is the entry of the kernel */
	.globl start
start:
	cli
  106560:	fa                   	cli

	/* check whether the bootloader provide multiboot information */
	cmpl	$MULTIBOOT_BOOTLOADER_MAGIC, %eax
  106561:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
	jne	spin
  106566:	75 27                	jne    10658f <spin>
	movl	%ebx, multiboot_ptr
  106568:	89 1d 90 65 10 00    	mov    %ebx,0x106590

	/* tell BIOS to warmboot next time */
	movw	$0x1234, 0x472
  10656e:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
  106575:	34 12 

	/* clear EFLAGS */
	pushl	$0x2
  106577:	6a 02                	push   $0x2
	popfl
  106579:	9d                   	popf

	/* prepare the kernel stack */
	movl	$0x0, %ebp
  10657a:	bd 00 00 00 00       	mov    $0x0,%ebp
	movl	$(bsp_kstack + 4096), %esp
  10657f:	bc 00 30 1e 00       	mov    $0x1e3000,%esp

	/* jump to the C code */
	push	multiboot_ptr
  106584:	ff 35 90 65 10 00    	push   0x106590
	call	kern_init
  10658a:	e8 e1 fe ff ff       	call   106470 <kern_init>

0010658f <spin>:

	/* should not be here */
spin:
	hlt
  10658f:	f4                   	hlt

00106590 <multiboot_ptr>:
  106590:	00 00                	add    %al,(%eax)
  106592:	00 00                	add    %al,(%eax)
  106594:	66 90                	xchg   %ax,%ax
  106596:	66 90                	xchg   %ax,%ax
  106598:	66 90                	xchg   %ax,%ax
  10659a:	66 90                	xchg   %ax,%ax
  10659c:	66 90                	xchg   %ax,%ax
  10659e:	66 90                	xchg   %ax,%ax

001065a0 <mem_spinlock_init>:
 * So it may have up to 2^20 physical pages,
 * with the page size being 4KB.
 */
static struct ATStruct AT[1 << 20];

void mem_spinlock_init(void) {
  1065a0:	53                   	push   %ebx
  1065a1:	e8 fc 9d ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1065a6:	81 c3 4e 0a 01 00    	add    $0x10a4e,%ebx
  1065ac:	83 ec 14             	sub    $0x14,%esp
    spinlock_init(&mem_lk);
  1065af:	8d 83 b0 32 8d 00    	lea    0x8d32b0(%ebx),%eax
  1065b5:	50                   	push   %eax
  1065b6:	e8 05 f9 ff ff       	call   105ec0 <spinlock_init>
}
  1065bb:	83 c4 18             	add    $0x18,%esp
  1065be:	5b                   	pop    %ebx
  1065bf:	c3                   	ret

001065c0 <mem_lock>:

void mem_lock(void) {
  1065c0:	53                   	push   %ebx
  1065c1:	e8 dc 9d ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1065c6:	81 c3 2e 0a 01 00    	add    $0x10a2e,%ebx
  1065cc:	83 ec 14             	sub    $0x14,%esp
    spinlock_acquire(&mem_lk);
  1065cf:	8d 83 b0 32 8d 00    	lea    0x8d32b0(%ebx),%eax
  1065d5:	50                   	push   %eax
  1065d6:	e8 75 f9 ff ff       	call   105f50 <spinlock_acquire>
}
  1065db:	83 c4 18             	add    $0x18,%esp
  1065de:	5b                   	pop    %ebx
  1065df:	c3                   	ret

001065e0 <mem_unlock>:

void mem_unlock(void) {
  1065e0:	53                   	push   %ebx
  1065e1:	e8 bc 9d ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1065e6:	81 c3 0e 0a 01 00    	add    $0x10a0e,%ebx
  1065ec:	83 ec 14             	sub    $0x14,%esp
    spinlock_release(&mem_lk);
  1065ef:	8d 83 b0 32 8d 00    	lea    0x8d32b0(%ebx),%eax
  1065f5:	50                   	push   %eax
  1065f6:	e8 d5 f9 ff ff       	call   105fd0 <spinlock_release>
}
  1065fb:	83 c4 18             	add    $0x18,%esp
  1065fe:	5b                   	pop    %ebx
  1065ff:	c3                   	ret

00106600 <get_nps>:

// The getter function for NUM_PAGES.
unsigned int get_nps(void)
{
    return NUM_PAGES;
  106600:	e8 95 9d ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  106605:	05 ef 09 01 00       	add    $0x109ef,%eax
  10660a:	8b 80 ac 32 8d 00    	mov    0x8d32ac(%eax),%eax
}
  106610:	c3                   	ret
  106611:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106618:	00 
  106619:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00106620 <set_nps>:

// The setter function for NUM_PAGES.
void set_nps(unsigned int nps)
{
    NUM_PAGES = nps;
  106620:	e8 75 9d ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  106625:	05 cf 09 01 00       	add    $0x109cf,%eax
  10662a:	8b 54 24 04          	mov    0x4(%esp),%edx
  10662e:	89 90 ac 32 8d 00    	mov    %edx,0x8d32ac(%eax)
}
  106634:	c3                   	ret
  106635:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10663c:	00 
  10663d:	8d 76 00             	lea    0x0(%esi),%esi

00106640 <at_is_norm>:
        perm = 1;
    } else {
        perm = 0;
    }

    return perm;
  106640:	e8 55 9d ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  106645:	05 af 09 01 00       	add    $0x109af,%eax
    if (perm > 1) {
  10664a:	8b 54 24 04          	mov    0x4(%esp),%edx
  10664e:	83 bc d0 ac 32 0d 00 	cmpl   $0x1,0xd32ac(%eax,%edx,8)
  106655:	01 
  106656:	0f 97 c0             	seta   %al
  106659:	0f b6 c0             	movzbl %al,%eax
}
  10665c:	c3                   	ret
  10665d:	8d 76 00             	lea    0x0(%esi),%esi

00106660 <at_set_perm>:
 * Sets the permission of the page with given index.
 * It also marks the page as unallocated.
 */
void at_set_perm(unsigned int page_index, unsigned int perm)
{
    AT[page_index].perm = perm;
  106660:	e8 35 9d ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  106665:	05 8f 09 01 00       	add    $0x1098f,%eax
{
  10666a:	8b 54 24 04          	mov    0x4(%esp),%edx
    AT[page_index].perm = perm;
  10666e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    AT[page_index].allocated = 0;
  106672:	c7 84 d0 b0 32 0d 00 	movl   $0x0,0xd32b0(%eax,%edx,8)
  106679:	00 00 00 00 
    AT[page_index].perm = perm;
  10667d:	89 8c d0 ac 32 0d 00 	mov    %ecx,0xd32ac(%eax,%edx,8)
}
  106684:	c3                   	ret
  106685:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10668c:	00 
  10668d:	8d 76 00             	lea    0x0(%esi),%esi

00106690 <at_is_allocated>:
    allocated = AT[page_index].allocated;
    if (allocated > 0) {
        allocated = 1;
    }

    return allocated;
  106690:	e8 05 9d ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  106695:	05 5f 09 01 00       	add    $0x1095f,%eax
    if (allocated > 0) {
  10669a:	8b 54 24 04          	mov    0x4(%esp),%edx
  10669e:	8b 84 d0 b0 32 0d 00 	mov    0xd32b0(%eax,%edx,8),%eax
  1066a5:	85 c0                	test   %eax,%eax
  1066a7:	0f 95 c0             	setne  %al
  1066aa:	0f b6 c0             	movzbl %al,%eax
}
  1066ad:	c3                   	ret
  1066ae:	66 90                	xchg   %ax,%ax

001066b0 <at_set_allocated>:
 * The setter function for the physical page allocation flag.
 * Set the flag of the page with given index to the given value.
 */
void at_set_allocated(unsigned int page_index, unsigned int allocated)
{
    AT[page_index].allocated = allocated;
  1066b0:	e8 e5 9c ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  1066b5:	05 3f 09 01 00       	add    $0x1093f,%eax
  1066ba:	8b 54 24 04          	mov    0x4(%esp),%edx
  1066be:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1066c2:	89 8c d0 b0 32 0d 00 	mov    %ecx,0xd32b0(%eax,%edx,8)
}
  1066c9:	c3                   	ret
  1066ca:	66 90                	xchg   %ax,%ax
  1066cc:	66 90                	xchg   %ax,%ax
  1066ce:	66 90                	xchg   %ax,%ax

001066d0 <pmem_init>:
 *    based on the information available in the physical memory map table.
 *    Review import.h in the current directory for the list of available
 *    getter and setter functions.
 */
void pmem_init(unsigned int mbi_addr)
{
  1066d0:	55                   	push   %ebp
  1066d1:	57                   	push   %edi
  1066d2:	56                   	push   %esi
  1066d3:	53                   	push   %ebx
  1066d4:	e8 c9 9c ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1066d9:	81 c3 1b 09 01 00    	add    $0x1091b,%ebx
  1066df:	83 ec 38             	sub    $0x38,%esp
    unsigned int pg_idx, pmmap_size, cur_addr, highest_addr;
    unsigned int entry_idx, flag, isnorm, start, len;

    // Calls the lower layer initialization primitive.
    // The parameter mbi_addr should not be used in the further code.
    devinit(mbi_addr);
  1066e2:	ff 74 24 4c          	push   0x4c(%esp)
  1066e6:	e8 95 a3 ff ff       	call   100a80 <devinit>
    mem_spinlock_init();
  1066eb:	e8 b0 fe ff ff       	call   1065a0 <mem_spinlock_init>
     * Hint: Think of it as the highest address in the ranges of the memory map table,
     *       divided by the page size.
     */
    nps = 0;
    entry_idx = 0;
    pmmap_size = get_size();
  1066f0:	e8 8b a9 ff ff       	call   101080 <get_size>
    while (entry_idx < pmmap_size) {
  1066f5:	83 c4 10             	add    $0x10,%esp
  1066f8:	85 c0                	test   %eax,%eax
  1066fa:	0f 84 63 01 00 00    	je     106863 <pmem_init+0x193>
    nps = 0;
  106700:	89 44 24 08          	mov    %eax,0x8(%esp)
    entry_idx = 0;
  106704:	31 ff                	xor    %edi,%edi
    nps = 0;
  106706:	31 f6                	xor    %esi,%esi
  106708:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10670f:	00 
        cur_addr = get_mms(entry_idx) + get_mml(entry_idx);
  106710:	83 ec 0c             	sub    $0xc,%esp
  106713:	57                   	push   %edi
  106714:	e8 87 a9 ff ff       	call   1010a0 <get_mms>
  106719:	89 3c 24             	mov    %edi,(%esp)
  10671c:	89 c5                	mov    %eax,%ebp
  10671e:	e8 cd a9 ff ff       	call   1010f0 <get_mml>
        if (nps < cur_addr) {
  106723:	89 fa                	mov    %edi,%edx
            nps = cur_addr;
        }
        entry_idx++;
  106725:	8d 7f 01             	lea    0x1(%edi),%edi
        cur_addr = get_mms(entry_idx) + get_mml(entry_idx);
  106728:	01 e8                	add    %ebp,%eax
        if (nps < cur_addr) {
  10672a:	39 c6                	cmp    %eax,%esi
  10672c:	0f 42 f0             	cmovb  %eax,%esi
    while (entry_idx < pmmap_size) {
  10672f:	83 c4 10             	add    $0x10,%esp
  106732:	39 7c 24 08          	cmp    %edi,0x8(%esp)
  106736:	75 d8                	jne    106710 <pmem_init+0x40>
  106738:	89 f5                	mov    %esi,%ebp
  10673a:	89 54 24 08          	mov    %edx,0x8(%esp)
    }

    nps = ROUNDDOWN(nps, PAGESIZE) / PAGESIZE;
    set_nps(nps);  // Setting the value computed above to NUM_PAGES.
  10673e:	83 ec 0c             	sub    $0xc,%esp
    nps = ROUNDDOWN(nps, PAGESIZE) / PAGESIZE;
  106741:	c1 ed 0c             	shr    $0xc,%ebp
  106744:	89 6c 24 20          	mov    %ebp,0x20(%esp)
  106748:	89 ee                	mov    %ebp,%esi
    set_nps(nps);  // Setting the value computed above to NUM_PAGES.
  10674a:	55                   	push   %ebp
     *    Otherwise, it should be set to 0. Note that the ranges in the memory map are
     *    not aligned by pages, so it may be possible that for some pages, only some of
     *    the addresses are in a usable range. Currently, we do not utilize partial pages,
     *    so in that case, you should consider those pages as unavailable.
     */
    pg_idx = 0;
  10674b:	31 ed                	xor    %ebp,%ebp
    set_nps(nps);  // Setting the value computed above to NUM_PAGES.
  10674d:	e8 ce fe ff ff       	call   106620 <set_nps>
    while (pg_idx < nps) {
  106752:	83 c4 10             	add    $0x10,%esp
  106755:	85 f6                	test   %esi,%esi
  106757:	0f 84 ca 00 00 00    	je     106827 <pmem_init+0x157>
  10675d:	8b 54 24 08          	mov    0x8(%esp),%edx
  106761:	89 e9                	mov    %ebp,%ecx
  106763:	89 54 24 0c          	mov    %edx,0xc(%esp)
  106767:	eb 2d                	jmp    106796 <pmem_init+0xc6>
  106769:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  106770:	89 4c 24 08          	mov    %ecx,0x8(%esp)
        if (pg_idx < VM_USERLO_PI || VM_USERHI_PI <= pg_idx) {
            at_set_perm(pg_idx, 1);
  106774:	83 ec 08             	sub    $0x8,%esp
  106777:	6a 01                	push   $0x1
  106779:	52                   	push   %edx
  10677a:	e8 e1 fe ff ff       	call   106660 <at_set_perm>
  10677f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  106783:	83 c4 10             	add    $0x10,%esp
    while (pg_idx < nps) {
  106786:	81 c5 00 10 00 00    	add    $0x1000,%ebp
  10678c:	39 4c 24 14          	cmp    %ecx,0x14(%esp)
  106790:	0f 84 91 00 00 00    	je     106827 <pmem_init+0x157>
        if (pg_idx < VM_USERLO_PI || VM_USERHI_PI <= pg_idx) {
  106796:	89 ca                	mov    %ecx,%edx
                at_set_perm(pg_idx, 2);
            } else {
                at_set_perm(pg_idx, 0);
            }
        }
        pg_idx++;
  106798:	83 c1 01             	add    $0x1,%ecx
        if (pg_idx < VM_USERLO_PI || VM_USERHI_PI <= pg_idx) {
  10679b:	8d 82 00 00 fc ff    	lea    -0x40000(%edx),%eax
  1067a1:	3d ff ff 0a 00       	cmp    $0xaffff,%eax
  1067a6:	77 c8                	ja     106770 <pmem_init+0xa0>
  1067a8:	89 c8                	mov    %ecx,%eax
  1067aa:	89 54 24 18          	mov    %edx,0x18(%esp)
            entry_idx = 0;
  1067ae:	31 f6                	xor    %esi,%esi
  1067b0:	c1 e0 0c             	shl    $0xc,%eax
  1067b3:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  1067b7:	89 44 24 10          	mov    %eax,0x10(%esp)
  1067bb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
                isnorm = is_usable(entry_idx);
  1067c0:	83 ec 0c             	sub    $0xc,%esp
  1067c3:	56                   	push   %esi
  1067c4:	e8 87 a9 ff ff       	call   101150 <is_usable>
                start = get_mms(entry_idx);
  1067c9:	89 34 24             	mov    %esi,(%esp)
                isnorm = is_usable(entry_idx);
  1067cc:	89 44 24 18          	mov    %eax,0x18(%esp)
                start = get_mms(entry_idx);
  1067d0:	e8 cb a8 ff ff       	call   1010a0 <get_mms>
                len = get_mml(entry_idx);
  1067d5:	89 34 24             	mov    %esi,(%esp)
                start = get_mms(entry_idx);
  1067d8:	89 c7                	mov    %eax,%edi
                len = get_mml(entry_idx);
  1067da:	e8 11 a9 ff ff       	call   1010f0 <get_mml>
                if (start <= pg_idx * PAGESIZE && (pg_idx + 1) * PAGESIZE <= start + len) {
  1067df:	83 c4 10             	add    $0x10,%esp
  1067e2:	39 fd                	cmp    %edi,%ebp
  1067e4:	72 4a                	jb     106830 <pmem_init+0x160>
  1067e6:	8d 14 07             	lea    (%edi,%eax,1),%edx
  1067e9:	8b 44 24 10          	mov    0x10(%esp),%eax
  1067ed:	39 c2                	cmp    %eax,%edx
  1067ef:	72 3f                	jb     106830 <pmem_init+0x160>
            if (flag && isnorm) {
  1067f1:	8b 44 24 08          	mov    0x8(%esp),%eax
  1067f5:	8b 54 24 18          	mov    0x18(%esp),%edx
  1067f9:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  1067fd:	85 c0                	test   %eax,%eax
  1067ff:	74 47                	je     106848 <pmem_init+0x178>
  106801:	89 4c 24 08          	mov    %ecx,0x8(%esp)
                at_set_perm(pg_idx, 2);
  106805:	83 ec 08             	sub    $0x8,%esp
    while (pg_idx < nps) {
  106808:	81 c5 00 10 00 00    	add    $0x1000,%ebp
                at_set_perm(pg_idx, 2);
  10680e:	6a 02                	push   $0x2
  106810:	52                   	push   %edx
  106811:	e8 4a fe ff ff       	call   106660 <at_set_perm>
  106816:	83 c4 10             	add    $0x10,%esp
  106819:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    while (pg_idx < nps) {
  10681d:	39 4c 24 14          	cmp    %ecx,0x14(%esp)
  106821:	0f 85 6f ff ff ff    	jne    106796 <pmem_init+0xc6>
    }
}
  106827:	83 c4 2c             	add    $0x2c,%esp
  10682a:	5b                   	pop    %ebx
  10682b:	5e                   	pop    %esi
  10682c:	5f                   	pop    %edi
  10682d:	5d                   	pop    %ebp
  10682e:	c3                   	ret
  10682f:	90                   	nop
                entry_idx++;
  106830:	8d 46 01             	lea    0x1(%esi),%eax
            while (entry_idx < pmmap_size && !flag) {
  106833:	39 74 24 0c          	cmp    %esi,0xc(%esp)
  106837:	74 07                	je     106840 <pmem_init+0x170>
  106839:	89 c6                	mov    %eax,%esi
  10683b:	eb 83                	jmp    1067c0 <pmem_init+0xf0>
  10683d:	8d 76 00             	lea    0x0(%esi),%esi
  106840:	8b 54 24 18          	mov    0x18(%esp),%edx
  106844:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  106848:	89 4c 24 08          	mov    %ecx,0x8(%esp)
                at_set_perm(pg_idx, 0);
  10684c:	83 ec 08             	sub    $0x8,%esp
  10684f:	6a 00                	push   $0x0
  106851:	52                   	push   %edx
  106852:	e8 09 fe ff ff       	call   106660 <at_set_perm>
  106857:	83 c4 10             	add    $0x10,%esp
  10685a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  10685e:	e9 23 ff ff ff       	jmp    106786 <pmem_init+0xb6>
    set_nps(nps);  // Setting the value computed above to NUM_PAGES.
  106863:	83 ec 0c             	sub    $0xc,%esp
  106866:	6a 00                	push   $0x0
  106868:	e8 b3 fd ff ff       	call   106620 <set_nps>
  10686d:	83 c4 10             	add    $0x10,%esp
}
  106870:	83 c4 2c             	add    $0x2c,%esp
  106873:	5b                   	pop    %ebx
  106874:	5e                   	pop    %esi
  106875:	5f                   	pop    %edi
  106876:	5d                   	pop    %ebp
  106877:	c3                   	ret
  106878:	66 90                	xchg   %ax,%ax
  10687a:	66 90                	xchg   %ax,%ax
  10687c:	66 90                	xchg   %ax,%ax
  10687e:	66 90                	xchg   %ax,%ax

00106880 <palloc>:
 *    return 0.
 * 2. Optimize the code using memoization so that you do not have to
 *    scan the allocation table from scratch every time.
 */
unsigned int palloc()
{
  106880:	55                   	push   %ebp
  106881:	57                   	push   %edi
  106882:	56                   	push   %esi
  106883:	53                   	push   %ebx
  106884:	e8 19 9b ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106889:	81 c3 6b 07 01 00    	add    $0x1076b,%ebx
  10688f:	83 ec 0c             	sub    $0xc,%esp
    unsigned int nps;
    unsigned int palloc_index;
    unsigned int palloc_free_index;
    bool first;

    mem_lock();
  106892:	e8 29 fd ff ff       	call   1065c0 <mem_lock>

    nps = get_nps();
  106897:	e8 64 fd ff ff       	call   106600 <get_nps>
    palloc_index = last_palloc_index;
  10689c:	8b ab 18 03 00 00    	mov    0x318(%ebx),%ebp
    nps = get_nps();
  1068a2:	89 c7                	mov    %eax,%edi
    palloc_index = last_palloc_index;
  1068a4:	89 c6                	mov    %eax,%esi
  1068a6:	eb 0c                	jmp    1068b4 <palloc+0x34>
  1068a8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1068af:	00 
    palloc_free_index = nps;
    first = TRUE;

    while ((palloc_index != last_palloc_index || first) && palloc_free_index == nps) {
  1068b0:	39 fe                	cmp    %edi,%esi
  1068b2:	75 64                	jne    106918 <palloc+0x98>
        first = FALSE;
        if (at_is_norm(palloc_index) && !at_is_allocated(palloc_index)) {
  1068b4:	83 ec 0c             	sub    $0xc,%esp
  1068b7:	55                   	push   %ebp
  1068b8:	e8 83 fd ff ff       	call   106640 <at_is_norm>
  1068bd:	83 c4 10             	add    $0x10,%esp
  1068c0:	85 c0                	test   %eax,%eax
  1068c2:	75 3c                	jne    106900 <palloc+0x80>
            palloc_free_index = palloc_index;
        }
        palloc_index++;
  1068c4:	83 c5 01             	add    $0x1,%ebp
        if (palloc_index >= VM_USERHI_PI) {
            palloc_index = VM_USERLO_PI;
  1068c7:	b8 00 00 04 00       	mov    $0x40000,%eax
  1068cc:	81 fd 00 00 0f 00    	cmp    $0xf0000,%ebp
  1068d2:	0f 43 e8             	cmovae %eax,%ebp
    while ((palloc_index != last_palloc_index || first) && palloc_free_index == nps) {
  1068d5:	3b ab 18 03 00 00    	cmp    0x318(%ebx),%ebp
  1068db:	75 d3                	jne    1068b0 <palloc+0x30>
        }
    }

    if (palloc_free_index == nps) {
  1068dd:	39 fe                	cmp    %edi,%esi
  1068df:	75 37                	jne    106918 <palloc+0x98>
  1068e1:	b8 00 00 04 00       	mov    $0x40000,%eax
        palloc_free_index = 0;
  1068e6:	31 f6                	xor    %esi,%esi
        last_palloc_index = VM_USERLO_PI;
  1068e8:	89 83 18 03 00 00    	mov    %eax,0x318(%ebx)
    } else {
        at_set_allocated(palloc_free_index, 1);
        last_palloc_index = palloc_free_index;
    }

    mem_unlock();
  1068ee:	e8 ed fc ff ff       	call   1065e0 <mem_unlock>

    return palloc_free_index;
}
  1068f3:	83 c4 0c             	add    $0xc,%esp
  1068f6:	89 f0                	mov    %esi,%eax
  1068f8:	5b                   	pop    %ebx
  1068f9:	5e                   	pop    %esi
  1068fa:	5f                   	pop    %edi
  1068fb:	5d                   	pop    %ebp
  1068fc:	c3                   	ret
  1068fd:	8d 76 00             	lea    0x0(%esi),%esi
        if (at_is_norm(palloc_index) && !at_is_allocated(palloc_index)) {
  106900:	83 ec 0c             	sub    $0xc,%esp
  106903:	55                   	push   %ebp
  106904:	e8 87 fd ff ff       	call   106690 <at_is_allocated>
  106909:	83 c4 10             	add    $0x10,%esp
            palloc_free_index = palloc_index;
  10690c:	85 c0                	test   %eax,%eax
  10690e:	0f 44 f5             	cmove  %ebp,%esi
  106911:	eb b1                	jmp    1068c4 <palloc+0x44>
  106913:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        at_set_allocated(palloc_free_index, 1);
  106918:	83 ec 08             	sub    $0x8,%esp
  10691b:	6a 01                	push   $0x1
  10691d:	56                   	push   %esi
  10691e:	e8 8d fd ff ff       	call   1066b0 <at_set_allocated>
  106923:	83 c4 10             	add    $0x10,%esp
  106926:	89 f0                	mov    %esi,%eax
  106928:	eb be                	jmp    1068e8 <palloc+0x68>
  10692a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106930 <pfree>:
 * in the allocation table.
 *
 * Hint: Simple.
 */
void pfree(unsigned int pfree_index)
{
  106930:	53                   	push   %ebx
  106931:	e8 6c 9a ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106936:	81 c3 be 06 01 00    	add    $0x106be,%ebx
  10693c:	83 ec 08             	sub    $0x8,%esp
    mem_lock();
  10693f:	e8 7c fc ff ff       	call   1065c0 <mem_lock>
    at_set_allocated(pfree_index, 0);
  106944:	83 ec 08             	sub    $0x8,%esp
  106947:	6a 00                	push   $0x0
  106949:	ff 74 24 1c          	push   0x1c(%esp)
  10694d:	e8 5e fd ff ff       	call   1066b0 <at_set_allocated>
    mem_unlock();
  106952:	e8 89 fc ff ff       	call   1065e0 <mem_unlock>
}
  106957:	83 c4 18             	add    $0x18,%esp
  10695a:	5b                   	pop    %ebx
  10695b:	c3                   	ret
  10695c:	66 90                	xchg   %ax,%ax
  10695e:	66 90                	xchg   %ax,%ax

00106960 <container_init>:
/**
 * Initializes the container data for the root process (the one with index 0).
 * The root process is the one that gets spawned first by the kernel.
 */
void container_init(unsigned int mbi_addr)
{
  106960:	55                   	push   %ebp
  106961:	57                   	push   %edi
  106962:	56                   	push   %esi
  106963:	53                   	push   %ebx
  106964:	e8 39 9a ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106969:	81 c3 8b 06 01 00    	add    $0x1068b,%ebx
  10696f:	83 ec 18             	sub    $0x18,%esp
    unsigned int real_quota;
    unsigned int nps, idx;

    pmem_init(mbi_addr);
  106972:	ff 74 24 2c          	push   0x2c(%esp)
  106976:	e8 55 fd ff ff       	call   1066d0 <pmem_init>
    /**
     * Compute the available quota and store it into the variable real_quota.
     * It should be the number of the unallocated pages with the normal permission
     * in the physical memory allocation table.
     */
    nps = get_nps();
  10697b:	e8 80 fc ff ff       	call   106600 <get_nps>
    idx = 1;
    while (idx < nps) {
  106980:	83 c4 10             	add    $0x10,%esp
  106983:	83 f8 01             	cmp    $0x1,%eax
  106986:	0f 86 b7 00 00 00    	jbe    106a43 <container_init+0xe3>
  10698c:	89 c6                	mov    %eax,%esi
    idx = 1;
  10698e:	bd 01 00 00 00       	mov    $0x1,%ebp
    real_quota = 0;
  106993:	31 ff                	xor    %edi,%edi
  106995:	eb 10                	jmp    1069a7 <container_init+0x47>
  106997:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10699e:	00 
  10699f:	90                   	nop
        if (at_is_norm(idx) && !at_is_allocated(idx)) {
            real_quota++;
        }
        idx++;
  1069a0:	83 c5 01             	add    $0x1,%ebp
    while (idx < nps) {
  1069a3:	39 ee                	cmp    %ebp,%esi
  1069a5:	74 29                	je     1069d0 <container_init+0x70>
        if (at_is_norm(idx) && !at_is_allocated(idx)) {
  1069a7:	83 ec 0c             	sub    $0xc,%esp
  1069aa:	55                   	push   %ebp
  1069ab:	e8 90 fc ff ff       	call   106640 <at_is_norm>
  1069b0:	83 c4 10             	add    $0x10,%esp
  1069b3:	85 c0                	test   %eax,%eax
  1069b5:	74 e9                	je     1069a0 <container_init+0x40>
  1069b7:	83 ec 0c             	sub    $0xc,%esp
  1069ba:	55                   	push   %ebp
  1069bb:	e8 d0 fc ff ff       	call   106690 <at_is_allocated>
  1069c0:	83 c4 10             	add    $0x10,%esp
            real_quota++;
  1069c3:	83 f8 01             	cmp    $0x1,%eax
  1069c6:	83 d7 00             	adc    $0x0,%edi
        idx++;
  1069c9:	83 c5 01             	add    $0x1,%ebp
    while (idx < nps) {
  1069cc:	39 ee                	cmp    %ebp,%esi
  1069ce:	75 d7                	jne    1069a7 <container_init+0x47>
    }

    KERN_DEBUG("\nreal quota: %d\n\n", real_quota);

    CONTAINER[0].quota = real_quota;
  1069d0:	89 fe                	mov    %edi,%esi
    KERN_DEBUG("\nreal quota: %d\n\n", real_quota);
  1069d2:	8d 83 a3 65 ff ff    	lea    -0x9a5d(%ebx),%eax
  1069d8:	57                   	push   %edi
  1069d9:	50                   	push   %eax
  1069da:	8d 83 94 72 ff ff    	lea    -0x8d6c(%ebx),%eax
  1069e0:	6a 2c                	push   $0x2c
  1069e2:	50                   	push   %eax
  1069e3:	e8 a8 dd ff ff       	call   104790 <debug_normal>
    CONTAINER[0].quota = real_quota;
  1069e8:	89 b3 cc 34 8d 00    	mov    %esi,0x8d34cc(%ebx)
    CONTAINER[0].usage = 0;
  1069ee:	83 c4 10             	add    $0x10,%esp
  1069f1:	8d b3 cc 32 8d 00    	lea    0x8d32cc(%ebx),%esi
  1069f7:	c7 83 d0 34 8d 00 00 	movl   $0x0,0x8d34d0(%ebx)
  1069fe:	00 00 00 
    CONTAINER[0].parent = 0;
  106a01:	8d be 00 02 00 00    	lea    0x200(%esi),%edi
  106a07:	c7 83 d4 34 8d 00 00 	movl   $0x0,0x8d34d4(%ebx)
  106a0e:	00 00 00 
    CONTAINER[0].nchildren = 0;
  106a11:	c7 83 d8 34 8d 00 00 	movl   $0x0,0x8d34d8(%ebx)
  106a18:	00 00 00 
    CONTAINER[0].used = 1;
  106a1b:	c7 83 dc 34 8d 00 01 	movl   $0x1,0x8d34dc(%ebx)
  106a22:	00 00 00 

    for (idx = 0; idx < NUM_IDS; idx++) {
  106a25:	8d 76 00             	lea    0x0(%esi),%esi
        spinlock_init(&container_lks[idx]);
  106a28:	83 ec 0c             	sub    $0xc,%esp
  106a2b:	56                   	push   %esi
    for (idx = 0; idx < NUM_IDS; idx++) {
  106a2c:	83 c6 08             	add    $0x8,%esi
        spinlock_init(&container_lks[idx]);
  106a2f:	e8 8c f4 ff ff       	call   105ec0 <spinlock_init>
    for (idx = 0; idx < NUM_IDS; idx++) {
  106a34:	83 c4 10             	add    $0x10,%esp
  106a37:	39 fe                	cmp    %edi,%esi
  106a39:	75 ed                	jne    106a28 <container_init+0xc8>
    }
}
  106a3b:	83 c4 0c             	add    $0xc,%esp
  106a3e:	5b                   	pop    %ebx
  106a3f:	5e                   	pop    %esi
  106a40:	5f                   	pop    %edi
  106a41:	5d                   	pop    %ebp
  106a42:	c3                   	ret
    while (idx < nps) {
  106a43:	31 f6                	xor    %esi,%esi
    real_quota = 0;
  106a45:	31 ff                	xor    %edi,%edi
  106a47:	eb 89                	jmp    1069d2 <container_init+0x72>
  106a49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00106a50 <container_get_parent>:

// Get the id of parent process of process # [id].
unsigned int container_get_parent(unsigned int id)
{
    return CONTAINER[id].parent;
  106a50:	e8 49 99 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106a55:	81 c2 9f 05 01 00    	add    $0x1059f,%edx
{
  106a5b:	8b 44 24 04          	mov    0x4(%esp),%eax
    return CONTAINER[id].parent;
  106a5f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  106a62:	8b 84 82 d4 34 8d 00 	mov    0x8d34d4(%edx,%eax,4),%eax
}
  106a69:	c3                   	ret
  106a6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106a70 <container_get_nchildren>:

// Get the number of children of process # [id].
unsigned int container_get_nchildren(unsigned int id)
{
    return CONTAINER[id].nchildren;
  106a70:	e8 29 99 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106a75:	81 c2 7f 05 01 00    	add    $0x1057f,%edx
{
  106a7b:	8b 44 24 04          	mov    0x4(%esp),%eax
    return CONTAINER[id].nchildren;
  106a7f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  106a82:	8b 84 82 d8 34 8d 00 	mov    0x8d34d8(%edx,%eax,4),%eax
}
  106a89:	c3                   	ret
  106a8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106a90 <container_get_quota>:

// Get the maximum memory quota of process # [id].
unsigned int container_get_quota(unsigned int id)
{
    return CONTAINER[id].quota;
  106a90:	e8 09 99 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106a95:	81 c2 5f 05 01 00    	add    $0x1055f,%edx
{
  106a9b:	8b 44 24 04          	mov    0x4(%esp),%eax
    return CONTAINER[id].quota;
  106a9f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  106aa2:	8b 84 82 cc 34 8d 00 	mov    0x8d34cc(%edx,%eax,4),%eax
}
  106aa9:	c3                   	ret
  106aaa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106ab0 <container_get_usage>:

// Get the current memory usage of process # [id].
unsigned int container_get_usage(unsigned int id)
{
    return CONTAINER[id].usage;
  106ab0:	e8 e9 98 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106ab5:	81 c2 3f 05 01 00    	add    $0x1053f,%edx
{
  106abb:	8b 44 24 04          	mov    0x4(%esp),%eax
    return CONTAINER[id].usage;
  106abf:	8d 04 80             	lea    (%eax,%eax,4),%eax
  106ac2:	8b 84 82 d0 34 8d 00 	mov    0x8d34d0(%edx,%eax,4),%eax
}
  106ac9:	c3                   	ret
  106aca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106ad0 <container_can_consume>:

// Determines whether the process # [id] can consume an extra
// [n] pages of memory. If so, returns 1, otherwise, returns 0.
unsigned int container_can_consume(unsigned int id, unsigned int n)
{
    return CONTAINER[id].usage + n <= CONTAINER[id].quota;
  106ad0:	e8 1e c3 ff ff       	call   102df3 <__x86.get_pc_thunk.cx>
  106ad5:	81 c1 1f 05 01 00    	add    $0x1051f,%ecx
{
  106adb:	8b 44 24 04          	mov    0x4(%esp),%eax
    return CONTAINER[id].usage + n <= CONTAINER[id].quota;
  106adf:	8d 04 80             	lea    (%eax,%eax,4),%eax
  106ae2:	c1 e0 02             	shl    $0x2,%eax
  106ae5:	8b 94 01 d0 34 8d 00 	mov    0x8d34d0(%ecx,%eax,1),%edx
  106aec:	03 54 24 08          	add    0x8(%esp),%edx
  106af0:	39 94 01 cc 34 8d 00 	cmp    %edx,0x8d34cc(%ecx,%eax,1)
  106af7:	0f 93 c0             	setae  %al
  106afa:	0f b6 c0             	movzbl %al,%eax
}
  106afd:	c3                   	ret
  106afe:	66 90                	xchg   %ax,%ax

00106b00 <container_split>:
 * You can assume it is safe to allocate [quota] pages
 * (the check is already done outside before calling this function).
 * Returns the container index for the new child process.
 */
unsigned int container_split(unsigned int id, unsigned int quota)
{
  106b00:	55                   	push   %ebp
  106b01:	57                   	push   %edi
  106b02:	56                   	push   %esi
  106b03:	53                   	push   %ebx
  106b04:	e8 99 98 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106b09:	81 c3 eb 04 01 00    	add    $0x104eb,%ebx
  106b0f:	83 ec 28             	sub    $0x28,%esp
  106b12:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    unsigned int child, nc;

    spinlock_acquire(&container_lks[id]);

    nc = CONTAINER[id].nchildren;
    child = id * MAX_CHILDREN + 1 + nc;  // container index for the child process
  106b16:	8d 7c 76 01          	lea    0x1(%esi,%esi,2),%edi
    spinlock_acquire(&container_lks[id]);
  106b1a:	8d ac f3 cc 32 8d 00 	lea    0x8d32cc(%ebx,%esi,8),%ebp
  106b21:	55                   	push   %ebp
  106b22:	e8 29 f4 ff ff       	call   105f50 <spinlock_acquire>
    nc = CONTAINER[id].nchildren;
  106b27:	8d 04 b6             	lea    (%esi,%esi,4),%eax

    if (NUM_IDS <= child) {
  106b2a:	83 c4 10             	add    $0x10,%esp
    nc = CONTAINER[id].nchildren;
  106b2d:	8d 84 83 cc 34 8d 00 	lea    0x8d34cc(%ebx,%eax,4),%eax
    child = id * MAX_CHILDREN + 1 + nc;  // container index for the child process
  106b34:	03 78 0c             	add    0xc(%eax),%edi
    if (NUM_IDS <= child) {
  106b37:	83 ff 3f             	cmp    $0x3f,%edi
  106b3a:	77 54                	ja     106b90 <container_split+0x90>
    }

    /**
     * Update the container structure of both parent and child process appropriately.
     */
    CONTAINER[child].used = 1;
  106b3c:	8d 14 bf             	lea    (%edi,%edi,4),%edx
    CONTAINER[child].nchildren = 0;

    CONTAINER[id].usage += quota;
    CONTAINER[id].nchildren++;

    spinlock_release(&container_lks[id]);
  106b3f:	83 ec 0c             	sub    $0xc,%esp
    CONTAINER[child].used = 1;
  106b42:	c1 e2 02             	shl    $0x2,%edx
  106b45:	8d 8c 13 cc 34 8d 00 	lea    0x8d34cc(%ebx,%edx,1),%ecx
  106b4c:	89 54 24 18          	mov    %edx,0x18(%esp)
    CONTAINER[child].quota = quota;
  106b50:	8b 54 24 40          	mov    0x40(%esp),%edx
    CONTAINER[child].usage = 0;
  106b54:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    CONTAINER[child].parent = id;
  106b5b:	89 71 08             	mov    %esi,0x8(%ecx)
    CONTAINER[child].nchildren = 0;
  106b5e:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
    CONTAINER[child].used = 1;
  106b65:	c7 41 10 01 00 00 00 	movl   $0x1,0x10(%ecx)
    CONTAINER[child].quota = quota;
  106b6c:	89 11                	mov    %edx,(%ecx)
    CONTAINER[id].usage += quota;
  106b6e:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    CONTAINER[id].nchildren++;
  106b72:	83 40 0c 01          	addl   $0x1,0xc(%eax)
    CONTAINER[id].usage += quota;
  106b76:	01 48 04             	add    %ecx,0x4(%eax)
    spinlock_release(&container_lks[id]);
  106b79:	55                   	push   %ebp
  106b7a:	e8 51 f4 ff ff       	call   105fd0 <spinlock_release>

    return child;
  106b7f:	83 c4 10             	add    $0x10,%esp
}
  106b82:	89 f8                	mov    %edi,%eax
  106b84:	83 c4 1c             	add    $0x1c,%esp
  106b87:	5b                   	pop    %ebx
  106b88:	5e                   	pop    %esi
  106b89:	5f                   	pop    %edi
  106b8a:	5d                   	pop    %ebp
  106b8b:	c3                   	ret
  106b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  106b90:	83 c4 1c             	add    $0x1c,%esp
        return NUM_IDS;
  106b93:	bf 40 00 00 00       	mov    $0x40,%edi
}
  106b98:	5b                   	pop    %ebx
  106b99:	89 f8                	mov    %edi,%eax
  106b9b:	5e                   	pop    %esi
  106b9c:	5f                   	pop    %edi
  106b9d:	5d                   	pop    %ebp
  106b9e:	c3                   	ret
  106b9f:	90                   	nop

00106ba0 <container_alloc>:
 * Allocates one more page for process # [id], given that this will not exceed the quota.
 * The container structure should be updated accordingly after the allocation.
 * Returns the page index of the allocated page, or 0 in the case of failure.
 */
unsigned int container_alloc(unsigned int id)
{
  106ba0:	57                   	push   %edi
  106ba1:	56                   	push   %esi
  106ba2:	53                   	push   %ebx
  106ba3:	8b 74 24 10          	mov    0x10(%esp),%esi
  106ba7:	e8 f6 97 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106bac:	81 c3 48 04 01 00    	add    $0x10448,%ebx
    unsigned int page_index = 0;

    spinlock_acquire(&container_lks[id]);
  106bb2:	83 ec 0c             	sub    $0xc,%esp
  106bb5:	8d bc f3 cc 32 8d 00 	lea    0x8d32cc(%ebx,%esi,8),%edi
  106bbc:	57                   	push   %edi
  106bbd:	e8 8e f3 ff ff       	call   105f50 <spinlock_acquire>

    if (CONTAINER[id].usage + 1 <= CONTAINER[id].quota) {
  106bc2:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  106bc5:	83 c4 10             	add    $0x10,%esp
  106bc8:	31 f6                	xor    %esi,%esi
  106bca:	c1 e0 02             	shl    $0x2,%eax
  106bcd:	8d 8c 03 cc 34 8d 00 	lea    0x8d34cc(%ebx,%eax,1),%ecx
  106bd4:	8b 51 04             	mov    0x4(%ecx),%edx
  106bd7:	3b 94 03 cc 34 8d 00 	cmp    0x8d34cc(%ebx,%eax,1),%edx
  106bde:	7c 18                	jl     106bf8 <container_alloc+0x58>
        CONTAINER[id].usage++;
        page_index = palloc();
    }

    spinlock_release(&container_lks[id]);
  106be0:	83 ec 0c             	sub    $0xc,%esp
  106be3:	57                   	push   %edi
  106be4:	e8 e7 f3 ff ff       	call   105fd0 <spinlock_release>

    return page_index;
  106be9:	83 c4 10             	add    $0x10,%esp
}
  106bec:	89 f0                	mov    %esi,%eax
  106bee:	5b                   	pop    %ebx
  106bef:	5e                   	pop    %esi
  106bf0:	5f                   	pop    %edi
  106bf1:	c3                   	ret
  106bf2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        CONTAINER[id].usage++;
  106bf8:	83 c2 01             	add    $0x1,%edx
  106bfb:	89 51 04             	mov    %edx,0x4(%ecx)
        page_index = palloc();
  106bfe:	e8 7d fc ff ff       	call   106880 <palloc>
  106c03:	89 c6                	mov    %eax,%esi
  106c05:	eb d9                	jmp    106be0 <container_alloc+0x40>
  106c07:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106c0e:	00 
  106c0f:	90                   	nop

00106c10 <container_free>:

// Frees the physical page and reduces the usage by 1.
void container_free(unsigned int id, unsigned int page_index)
{
  106c10:	55                   	push   %ebp
  106c11:	57                   	push   %edi
  106c12:	56                   	push   %esi
  106c13:	53                   	push   %ebx
  106c14:	e8 89 97 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106c19:	81 c3 db 03 01 00    	add    $0x103db,%ebx
  106c1f:	83 ec 18             	sub    $0x18,%esp
  106c22:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  106c26:	8b 7c 24 30          	mov    0x30(%esp),%edi
    spinlock_acquire(&container_lks[id]);
  106c2a:	8d ac f3 cc 32 8d 00 	lea    0x8d32cc(%ebx,%esi,8),%ebp
  106c31:	55                   	push   %ebp
  106c32:	e8 19 f3 ff ff       	call   105f50 <spinlock_acquire>

    if (at_is_allocated(page_index)) {
  106c37:	89 3c 24             	mov    %edi,(%esp)
  106c3a:	e8 51 fa ff ff       	call   106690 <at_is_allocated>
  106c3f:	83 c4 10             	add    $0x10,%esp
  106c42:	85 c0                	test   %eax,%eax
  106c44:	75 1a                	jne    106c60 <container_free+0x50>
        if (CONTAINER[id].usage > 0) {
            CONTAINER[id].usage--;
        }
    }

    spinlock_release(&container_lks[id]);
  106c46:	83 ec 0c             	sub    $0xc,%esp
  106c49:	55                   	push   %ebp
  106c4a:	e8 81 f3 ff ff       	call   105fd0 <spinlock_release>
}
  106c4f:	83 c4 1c             	add    $0x1c,%esp
  106c52:	5b                   	pop    %ebx
  106c53:	5e                   	pop    %esi
  106c54:	5f                   	pop    %edi
  106c55:	5d                   	pop    %ebp
  106c56:	c3                   	ret
  106c57:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106c5e:	00 
  106c5f:	90                   	nop
        pfree(page_index);
  106c60:	83 ec 0c             	sub    $0xc,%esp
  106c63:	57                   	push   %edi
  106c64:	e8 c7 fc ff ff       	call   106930 <pfree>
        if (CONTAINER[id].usage > 0) {
  106c69:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  106c6c:	83 c4 10             	add    $0x10,%esp
  106c6f:	8d 94 83 cc 34 8d 00 	lea    0x8d34cc(%ebx,%eax,4),%edx
  106c76:	8b 42 04             	mov    0x4(%edx),%eax
  106c79:	85 c0                	test   %eax,%eax
  106c7b:	7e c9                	jle    106c46 <container_free+0x36>
            CONTAINER[id].usage--;
  106c7d:	83 e8 01             	sub    $0x1,%eax
  106c80:	89 42 04             	mov    %eax,0x4(%edx)
  106c83:	eb c1                	jmp    106c46 <container_free+0x36>
  106c85:	66 90                	xchg   %ax,%ax
  106c87:	66 90                	xchg   %ax,%ax
  106c89:	66 90                	xchg   %ax,%ax
  106c8b:	66 90                	xchg   %ax,%ax
  106c8d:	66 90                	xchg   %ax,%ax
  106c8f:	90                   	nop

00106c90 <set_pdir_base>:
 */
unsigned int IDPTbl[1024][1024] gcc_aligned(PAGESIZE);

// Sets the CR3 register with the start address of the page structure for process # [index].
void set_pdir_base(unsigned int index)
{
  106c90:	53                   	push   %ebx
  106c91:	e8 0c 97 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106c96:	81 c3 5e 03 01 00    	add    $0x1035e,%ebx
  106c9c:	83 ec 14             	sub    $0x14,%esp
    set_cr3(PDirPool[index]);
  106c9f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  106ca3:	c1 e0 0c             	shl    $0xc,%eax
  106ca6:	8d 84 03 0c 40 cd 00 	lea    0xcd400c(%ebx,%eax,1),%eax
  106cad:	50                   	push   %eax
  106cae:	e8 fd a4 ff ff       	call   1011b0 <set_cr3>
}
  106cb3:	83 c4 18             	add    $0x18,%esp
  106cb6:	5b                   	pop    %ebx
  106cb7:	c3                   	ret
  106cb8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106cbf:	00 

00106cc0 <get_pdir_entry>:

// Returns the page directory entry # [pde_index] of the process # [proc_index].
// This can be used to test whether the page directory entry is mapped.
unsigned int get_pdir_entry(unsigned int proc_index, unsigned int pde_index)
{
    return (unsigned int) PDirPool[proc_index][pde_index];
  106cc0:	e8 d9 96 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106cc5:	81 c2 2f 03 01 00    	add    $0x1032f,%edx
  106ccb:	8b 44 24 04          	mov    0x4(%esp),%eax
  106ccf:	c1 e0 0a             	shl    $0xa,%eax
  106cd2:	03 44 24 08          	add    0x8(%esp),%eax
  106cd6:	8b 84 82 0c 40 cd 00 	mov    0xcd400c(%edx,%eax,4),%eax
}
  106cdd:	c3                   	ret
  106cde:	66 90                	xchg   %ax,%ax

00106ce0 <set_pdir_entry>:
// You should also set the permissions PTE_P, PTE_W, and PTE_U.
void set_pdir_entry(unsigned int proc_index, unsigned int pde_index,
                    unsigned int page_index)
{
    unsigned int addr = page_index << 12;
    PDirPool[proc_index][pde_index] = (unsigned int *) (addr | PT_PERM_PTU);
  106ce0:	e8 0e c1 ff ff       	call   102df3 <__x86.get_pc_thunk.cx>
  106ce5:	81 c1 0f 03 01 00    	add    $0x1030f,%ecx
    unsigned int addr = page_index << 12;
  106ceb:	8b 54 24 0c          	mov    0xc(%esp),%edx
    PDirPool[proc_index][pde_index] = (unsigned int *) (addr | PT_PERM_PTU);
  106cef:	8b 44 24 04          	mov    0x4(%esp),%eax
    unsigned int addr = page_index << 12;
  106cf3:	c1 e2 0c             	shl    $0xc,%edx
    PDirPool[proc_index][pde_index] = (unsigned int *) (addr | PT_PERM_PTU);
  106cf6:	c1 e0 0a             	shl    $0xa,%eax
  106cf9:	03 44 24 08          	add    0x8(%esp),%eax
  106cfd:	83 ca 07             	or     $0x7,%edx
  106d00:	89 94 81 0c 40 cd 00 	mov    %edx,0xcd400c(%ecx,%eax,4)
}
  106d07:	c3                   	ret
  106d08:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106d0f:	00 

00106d10 <set_pdir_entry_identity>:
// with the initial address of page directory # [pde_index] in IDPTbl.
// You should also set the permissions PTE_P, PTE_W, and PTE_U.
// This will be used to map a page directory entry to an identity page table.
void set_pdir_entry_identity(unsigned int proc_index, unsigned int pde_index)
{
    unsigned int addr = (unsigned int) IDPTbl[pde_index];
  106d10:	e8 de c0 ff ff       	call   102df3 <__x86.get_pc_thunk.cx>
  106d15:	81 c1 df 02 01 00    	add    $0x102df,%ecx
    PDirPool[proc_index][pde_index] = (unsigned int *) (addr | PT_PERM_PTU);
  106d1b:	8b 44 24 04          	mov    0x4(%esp),%eax
{
  106d1f:	8b 54 24 08          	mov    0x8(%esp),%edx
    PDirPool[proc_index][pde_index] = (unsigned int *) (addr | PT_PERM_PTU);
  106d23:	c1 e0 0a             	shl    $0xa,%eax
  106d26:	01 d0                	add    %edx,%eax
    unsigned int addr = (unsigned int) IDPTbl[pde_index];
  106d28:	c1 e2 0c             	shl    $0xc,%edx
  106d2b:	8d 94 11 0c 40 8d 00 	lea    0x8d400c(%ecx,%edx,1),%edx
    PDirPool[proc_index][pde_index] = (unsigned int *) (addr | PT_PERM_PTU);
  106d32:	83 ca 07             	or     $0x7,%edx
  106d35:	89 94 81 0c 40 cd 00 	mov    %edx,0xcd400c(%ecx,%eax,4)
}
  106d3c:	c3                   	ret
  106d3d:	8d 76 00             	lea    0x0(%esi),%esi

00106d40 <rmv_pdir_entry>:

// Removes the specified page directory entry (sets the page directory entry to 0).
// Don't forget to cast the value to (unsigned int *).
void rmv_pdir_entry(unsigned int proc_index, unsigned int pde_index)
{
    PDirPool[proc_index][pde_index] = (unsigned int *) 0;
  106d40:	e8 59 96 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106d45:	81 c2 af 02 01 00    	add    $0x102af,%edx
  106d4b:	8b 44 24 04          	mov    0x4(%esp),%eax
  106d4f:	c1 e0 0a             	shl    $0xa,%eax
  106d52:	03 44 24 08          	add    0x8(%esp),%eax
  106d56:	c7 84 82 0c 40 cd 00 	movl   $0x0,0xcd400c(%edx,%eax,4)
  106d5d:	00 00 00 00 
}
  106d61:	c3                   	ret
  106d62:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106d69:	00 
  106d6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106d70 <get_ptbl_entry>:
// Do not forget that the permission info is also stored in the page directory entries.
unsigned int get_ptbl_entry(unsigned int proc_index, unsigned int pde_index,
                            unsigned int pte_index)
{
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
    return pt[pte_index];
  106d70:	e8 29 96 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106d75:	81 c2 7f 02 01 00    	add    $0x1027f,%edx
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
  106d7b:	8b 44 24 04          	mov    0x4(%esp),%eax
  106d7f:	c1 e0 0a             	shl    $0xa,%eax
  106d82:	03 44 24 08          	add    0x8(%esp),%eax
  106d86:	8b 84 82 0c 40 cd 00 	mov    0xcd400c(%edx,%eax,4),%eax
    return pt[pte_index];
  106d8d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
  106d91:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    return pt[pte_index];
  106d96:	8b 04 90             	mov    (%eax,%edx,4),%eax
}
  106d99:	c3                   	ret
  106d9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106da0 <set_ptbl_entry>:
void set_ptbl_entry(unsigned int proc_index, unsigned int pde_index,
                    unsigned int pte_index, unsigned int page_index,
                    unsigned int perm)
{
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
    pt[pte_index] = (page_index << 12) | perm;
  106da0:	e8 f9 95 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106da5:	81 c2 4f 02 01 00    	add    $0x1024f,%edx
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
  106dab:	8b 44 24 04          	mov    0x4(%esp),%eax
    pt[pte_index] = (page_index << 12) | perm;
  106daf:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
  106db3:	c1 e0 0a             	shl    $0xa,%eax
  106db6:	03 44 24 08          	add    0x8(%esp),%eax
  106dba:	8b 94 82 0c 40 cd 00 	mov    0xcd400c(%edx,%eax,4),%edx
    pt[pte_index] = (page_index << 12) | perm;
  106dc1:	8b 44 24 10          	mov    0x10(%esp),%eax
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
  106dc5:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
    pt[pte_index] = (page_index << 12) | perm;
  106dcb:	c1 e0 0c             	shl    $0xc,%eax
  106dce:	0b 44 24 14          	or     0x14(%esp),%eax
  106dd2:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
}
  106dd5:	c3                   	ret
  106dd6:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106ddd:	00 
  106dde:	66 90                	xchg   %ax,%ax

00106de0 <set_ptbl_entry_identity>:

// Sets up the specified page table entry in IDPTbl as the identity map.
// You should also set the given permission.
void set_ptbl_entry_identity(unsigned int pde_index, unsigned int pte_index,
                             unsigned int perm)
{
  106de0:	53                   	push   %ebx
  106de1:	8b 54 24 08          	mov    0x8(%esp),%edx
  106de5:	e8 b8 95 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106dea:	81 c3 0a 02 01 00    	add    $0x1020a,%ebx
  106df0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    unsigned int addr = (pde_index << 22) | (pte_index << 12);
    IDPTbl[pde_index][pte_index] = addr | perm;
  106df4:	89 d1                	mov    %edx,%ecx
    unsigned int addr = (pde_index << 22) | (pte_index << 12);
  106df6:	c1 e2 16             	shl    $0x16,%edx
    IDPTbl[pde_index][pte_index] = addr | perm;
  106df9:	c1 e1 0a             	shl    $0xa,%ecx
  106dfc:	01 c1                	add    %eax,%ecx
    unsigned int addr = (pde_index << 22) | (pte_index << 12);
  106dfe:	c1 e0 0c             	shl    $0xc,%eax
    IDPTbl[pde_index][pte_index] = addr | perm;
  106e01:	0b 44 24 10          	or     0x10(%esp),%eax
  106e05:	09 d0                	or     %edx,%eax
  106e07:	89 84 8b 0c 40 8d 00 	mov    %eax,0x8d400c(%ebx,%ecx,4)
}
  106e0e:	5b                   	pop    %ebx
  106e0f:	c3                   	ret

00106e10 <rmv_ptbl_entry>:
// Sets the specified page table entry to 0.
void rmv_ptbl_entry(unsigned int proc_index, unsigned int pde_index,
                    unsigned int pte_index)
{
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
    pt[pte_index] = 0;
  106e10:	e8 89 95 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  106e15:	81 c2 df 01 01 00    	add    $0x101df,%edx
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
  106e1b:	8b 44 24 04          	mov    0x4(%esp),%eax
  106e1f:	c1 e0 0a             	shl    $0xa,%eax
  106e22:	03 44 24 08          	add    0x8(%esp),%eax
  106e26:	8b 84 82 0c 40 cd 00 	mov    0xcd400c(%edx,%eax,4),%eax
    pt[pte_index] = 0;
  106e2d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    unsigned int *pt = (unsigned int *) ADDR_MASK(PDirPool[proc_index][pde_index]);
  106e31:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    pt[pte_index] = 0;
  106e36:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
}
  106e3d:	c3                   	ret
  106e3e:	66 90                	xchg   %ax,%ax

00106e40 <get_ptbl_entry_by_va>:
 * Returns the page table entry corresponding to the virtual address,
 * according to the page structure of process # [proc_index].
 * Returns 0 if the mapping does not exist.
 */
unsigned int get_ptbl_entry_by_va(unsigned int proc_index, unsigned int vaddr)
{
  106e40:	55                   	push   %ebp
  106e41:	57                   	push   %edi
  106e42:	56                   	push   %esi
  106e43:	53                   	push   %ebx
  106e44:	e8 59 95 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106e49:	81 c3 ab 01 01 00    	add    $0x101ab,%ebx
  106e4f:	83 ec 14             	sub    $0x14,%esp
  106e52:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  106e56:	8b 7c 24 28          	mov    0x28(%esp),%edi
    unsigned int pde_index = PDE_ADDR(vaddr);
  106e5a:	89 f5                	mov    %esi,%ebp
  106e5c:	c1 ed 16             	shr    $0x16,%ebp
    if (get_pdir_entry(proc_index, pde_index) != 0) {
  106e5f:	55                   	push   %ebp
  106e60:	57                   	push   %edi
  106e61:	e8 5a fe ff ff       	call   106cc0 <get_pdir_entry>
  106e66:	83 c4 10             	add    $0x10,%esp
  106e69:	85 c0                	test   %eax,%eax
  106e6b:	75 0b                	jne    106e78 <get_ptbl_entry_by_va+0x38>
        return get_ptbl_entry(proc_index, pde_index, PTE_ADDR(vaddr));
    } else {
        return 0;
    }
}
  106e6d:	83 c4 0c             	add    $0xc,%esp
  106e70:	5b                   	pop    %ebx
  106e71:	5e                   	pop    %esi
  106e72:	5f                   	pop    %edi
  106e73:	5d                   	pop    %ebp
  106e74:	c3                   	ret
  106e75:	8d 76 00             	lea    0x0(%esi),%esi
        return get_ptbl_entry(proc_index, pde_index, PTE_ADDR(vaddr));
  106e78:	c1 ee 0c             	shr    $0xc,%esi
  106e7b:	83 ec 04             	sub    $0x4,%esp
  106e7e:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
  106e84:	56                   	push   %esi
  106e85:	55                   	push   %ebp
  106e86:	57                   	push   %edi
  106e87:	e8 e4 fe ff ff       	call   106d70 <get_ptbl_entry>
  106e8c:	83 c4 10             	add    $0x10,%esp
}
  106e8f:	83 c4 0c             	add    $0xc,%esp
  106e92:	5b                   	pop    %ebx
  106e93:	5e                   	pop    %esi
  106e94:	5f                   	pop    %edi
  106e95:	5d                   	pop    %ebp
  106e96:	c3                   	ret
  106e97:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106e9e:	00 
  106e9f:	90                   	nop

00106ea0 <get_pdir_entry_by_va>:

// Returns the page directory entry corresponding to the given virtual address.
unsigned int get_pdir_entry_by_va(unsigned int proc_index, unsigned int vaddr)
{
  106ea0:	53                   	push   %ebx
  106ea1:	e8 fc 94 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106ea6:	81 c3 4e 01 01 00    	add    $0x1014e,%ebx
  106eac:	83 ec 10             	sub    $0x10,%esp
    return get_pdir_entry(proc_index, PDE_ADDR(vaddr));
  106eaf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  106eb3:	c1 e8 16             	shr    $0x16,%eax
  106eb6:	50                   	push   %eax
  106eb7:	ff 74 24 1c          	push   0x1c(%esp)
  106ebb:	e8 00 fe ff ff       	call   106cc0 <get_pdir_entry>
}
  106ec0:	83 c4 18             	add    $0x18,%esp
  106ec3:	5b                   	pop    %ebx
  106ec4:	c3                   	ret
  106ec5:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106ecc:	00 
  106ecd:	8d 76 00             	lea    0x0(%esi),%esi

00106ed0 <rmv_ptbl_entry_by_va>:

// Removes the page table entry for the given virtual address.
void rmv_ptbl_entry_by_va(unsigned int proc_index, unsigned int vaddr)
{
  106ed0:	55                   	push   %ebp
  106ed1:	57                   	push   %edi
  106ed2:	56                   	push   %esi
  106ed3:	53                   	push   %ebx
  106ed4:	e8 c9 94 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106ed9:	81 c3 1b 01 01 00    	add    $0x1011b,%ebx
  106edf:	83 ec 14             	sub    $0x14,%esp
  106ee2:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  106ee6:	8b 7c 24 28          	mov    0x28(%esp),%edi
    unsigned int pde_index = PDE_ADDR(vaddr);
  106eea:	89 f5                	mov    %esi,%ebp
  106eec:	c1 ed 16             	shr    $0x16,%ebp
    if (get_pdir_entry(proc_index, pde_index) != 0) {
  106eef:	55                   	push   %ebp
  106ef0:	57                   	push   %edi
  106ef1:	e8 ca fd ff ff       	call   106cc0 <get_pdir_entry>
  106ef6:	83 c4 10             	add    $0x10,%esp
  106ef9:	85 c0                	test   %eax,%eax
  106efb:	75 0b                	jne    106f08 <rmv_ptbl_entry_by_va+0x38>
        rmv_ptbl_entry(proc_index, pde_index, PTE_ADDR(vaddr));
    }
}
  106efd:	83 c4 0c             	add    $0xc,%esp
  106f00:	5b                   	pop    %ebx
  106f01:	5e                   	pop    %esi
  106f02:	5f                   	pop    %edi
  106f03:	5d                   	pop    %ebp
  106f04:	c3                   	ret
  106f05:	8d 76 00             	lea    0x0(%esi),%esi
        rmv_ptbl_entry(proc_index, pde_index, PTE_ADDR(vaddr));
  106f08:	c1 ee 0c             	shr    $0xc,%esi
  106f0b:	83 ec 04             	sub    $0x4,%esp
  106f0e:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
  106f14:	56                   	push   %esi
  106f15:	55                   	push   %ebp
  106f16:	57                   	push   %edi
  106f17:	e8 f4 fe ff ff       	call   106e10 <rmv_ptbl_entry>
  106f1c:	83 c4 10             	add    $0x10,%esp
}
  106f1f:	83 c4 0c             	add    $0xc,%esp
  106f22:	5b                   	pop    %ebx
  106f23:	5e                   	pop    %esi
  106f24:	5f                   	pop    %edi
  106f25:	5d                   	pop    %ebp
  106f26:	c3                   	ret
  106f27:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106f2e:	00 
  106f2f:	90                   	nop

00106f30 <rmv_pdir_entry_by_va>:

// Removes the page directory entry for the given virtual address.
void rmv_pdir_entry_by_va(unsigned int proc_index, unsigned int vaddr)
{
  106f30:	53                   	push   %ebx
  106f31:	e8 6c 94 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106f36:	81 c3 be 00 01 00    	add    $0x100be,%ebx
  106f3c:	83 ec 10             	sub    $0x10,%esp
    rmv_pdir_entry(proc_index, PDE_ADDR(vaddr));
  106f3f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  106f43:	c1 e8 16             	shr    $0x16,%eax
  106f46:	50                   	push   %eax
  106f47:	ff 74 24 1c          	push   0x1c(%esp)
  106f4b:	e8 f0 fd ff ff       	call   106d40 <rmv_pdir_entry>
}
  106f50:	83 c4 18             	add    $0x18,%esp
  106f53:	5b                   	pop    %ebx
  106f54:	c3                   	ret
  106f55:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  106f5c:	00 
  106f5d:	8d 76 00             	lea    0x0(%esi),%esi

00106f60 <set_ptbl_entry_by_va>:

// Maps the virtual address [vaddr] to the physical page # [page_index] with permission [perm].
// You do not need to worry about the page directory entry. just map the page table entry.
void set_ptbl_entry_by_va(unsigned int proc_index, unsigned int vaddr,
                          unsigned int page_index, unsigned int perm)
{
  106f60:	53                   	push   %ebx
  106f61:	e8 3c 94 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106f66:	81 c3 8e 00 01 00    	add    $0x1008e,%ebx
  106f6c:	83 ec 14             	sub    $0x14,%esp
  106f6f:	8b 44 24 20          	mov    0x20(%esp),%eax
    set_ptbl_entry(proc_index, PDE_ADDR(vaddr), PTE_ADDR(vaddr), page_index, perm);
  106f73:	ff 74 24 28          	push   0x28(%esp)
  106f77:	ff 74 24 28          	push   0x28(%esp)
  106f7b:	89 c2                	mov    %eax,%edx
  106f7d:	c1 e8 16             	shr    $0x16,%eax
  106f80:	c1 ea 0c             	shr    $0xc,%edx
  106f83:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  106f89:	52                   	push   %edx
  106f8a:	50                   	push   %eax
  106f8b:	ff 74 24 2c          	push   0x2c(%esp)
  106f8f:	e8 0c fe ff ff       	call   106da0 <set_ptbl_entry>
}
  106f94:	83 c4 28             	add    $0x28,%esp
  106f97:	5b                   	pop    %ebx
  106f98:	c3                   	ret
  106f99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00106fa0 <set_pdir_entry_by_va>:

// Registers the mapping from [vaddr] to physical page # [page_index] in the page directory.
void set_pdir_entry_by_va(unsigned int proc_index, unsigned int vaddr,
                          unsigned int page_index)
{
  106fa0:	53                   	push   %ebx
  106fa1:	e8 fc 93 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106fa6:	81 c3 4e 00 01 00    	add    $0x1004e,%ebx
  106fac:	83 ec 0c             	sub    $0xc,%esp
    set_pdir_entry(proc_index, PDE_ADDR(vaddr), page_index);
  106faf:	ff 74 24 1c          	push   0x1c(%esp)
  106fb3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  106fb7:	c1 e8 16             	shr    $0x16,%eax
  106fba:	50                   	push   %eax
  106fbb:	ff 74 24 1c          	push   0x1c(%esp)
  106fbf:	e8 1c fd ff ff       	call   106ce0 <set_pdir_entry>
}
  106fc4:	83 c4 18             	add    $0x18,%esp
  106fc7:	5b                   	pop    %ebx
  106fc8:	c3                   	ret
  106fc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00106fd0 <idptbl_init>:

// Initializes the identity page table.
// The permission for the kernel memory should be PTE_P, PTE_W, and PTE_G,
// While the permission for the rest should be PTE_P and PTE_W.
void idptbl_init(unsigned int mbi_addr)
{
  106fd0:	55                   	push   %ebp
    unsigned int pde_index, pte_index, perm;
    container_init(mbi_addr);

    // Set up IDPTbl
    for (pde_index = 0; pde_index < 1024; pde_index++) {
  106fd1:	31 ed                	xor    %ebp,%ebp
{
  106fd3:	57                   	push   %edi
  106fd4:	56                   	push   %esi
  106fd5:	53                   	push   %ebx
  106fd6:	e8 c7 93 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  106fdb:	81 c3 19 00 01 00    	add    $0x10019,%ebx
  106fe1:	83 ec 18             	sub    $0x18,%esp
    container_init(mbi_addr);
  106fe4:	ff 74 24 2c          	push   0x2c(%esp)
  106fe8:	e8 73 f9 ff ff       	call   106960 <container_init>
  106fed:	83 c4 10             	add    $0x10,%esp
        if ((pde_index < VM_USERLO_PDE) || (VM_USERHI_PDE <= pde_index)) {
  106ff0:	8d 85 00 ff ff ff    	lea    -0x100(%ebp),%eax
            // kernel mapping
            perm = PTE_P | PTE_W | PTE_G;
  106ff6:	3d c0 02 00 00       	cmp    $0x2c0,%eax
  106ffb:	19 ff                	sbb    %edi,%edi
        } else {
            // normal memory
            perm = PTE_P | PTE_W;
        }

        for (pte_index = 0; pte_index < 1024; pte_index++) {
  106ffd:	31 f6                	xor    %esi,%esi
            perm = PTE_P | PTE_W | PTE_G;
  106fff:	81 e7 00 ff ff ff    	and    $0xffffff00,%edi
  107005:	81 c7 03 01 00 00    	add    $0x103,%edi
        for (pte_index = 0; pte_index < 1024; pte_index++) {
  10700b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
            set_ptbl_entry_identity(pde_index, pte_index, perm);
  107010:	83 ec 04             	sub    $0x4,%esp
  107013:	57                   	push   %edi
  107014:	56                   	push   %esi
        for (pte_index = 0; pte_index < 1024; pte_index++) {
  107015:	83 c6 01             	add    $0x1,%esi
            set_ptbl_entry_identity(pde_index, pte_index, perm);
  107018:	55                   	push   %ebp
  107019:	e8 c2 fd ff ff       	call   106de0 <set_ptbl_entry_identity>
        for (pte_index = 0; pte_index < 1024; pte_index++) {
  10701e:	83 c4 10             	add    $0x10,%esp
  107021:	81 fe 00 04 00 00    	cmp    $0x400,%esi
  107027:	75 e7                	jne    107010 <idptbl_init+0x40>
    for (pde_index = 0; pde_index < 1024; pde_index++) {
  107029:	83 c5 01             	add    $0x1,%ebp
  10702c:	81 fd 00 04 00 00    	cmp    $0x400,%ebp
  107032:	75 bc                	jne    106ff0 <idptbl_init+0x20>
        }
    }
}
  107034:	83 c4 0c             	add    $0xc,%esp
  107037:	5b                   	pop    %ebx
  107038:	5e                   	pop    %esi
  107039:	5f                   	pop    %edi
  10703a:	5d                   	pop    %ebp
  10703b:	c3                   	ret
  10703c:	66 90                	xchg   %ax,%ax
  10703e:	66 90                	xchg   %ax,%ax

00107040 <pdir_init>:
 * For each process from id 0 to NUM_IDS - 1,
 * set up the page directory entries so that the kernel portion of the map is
 * the identity map, and the rest of the page directories are unmapped.
 */
void pdir_init(unsigned int mbi_addr)
{
  107040:	57                   	push   %edi
    unsigned int proc_index, pde_index;
    idptbl_init(mbi_addr);

    for (proc_index = 0; proc_index < NUM_IDS; proc_index++) {
  107041:	31 ff                	xor    %edi,%edi
{
  107043:	56                   	push   %esi
  107044:	53                   	push   %ebx
  107045:	e8 58 93 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10704a:	81 c3 aa ff 00 00    	add    $0xffaa,%ebx
    idptbl_init(mbi_addr);
  107050:	83 ec 0c             	sub    $0xc,%esp
  107053:	ff 74 24 1c          	push   0x1c(%esp)
  107057:	e8 74 ff ff ff       	call   106fd0 <idptbl_init>
  10705c:	83 c4 10             	add    $0x10,%esp
  10705f:	90                   	nop
        for (pde_index = 0; pde_index < 1024; pde_index++) {
  107060:	31 f6                	xor    %esi,%esi
  107062:	eb 14                	jmp    107078 <pdir_init+0x38>
  107064:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            if ((pde_index < VM_USERLO_PDE) || (VM_USERHI_PDE <= pde_index)) {
                set_pdir_entry_identity(proc_index, pde_index);
            } else {
                rmv_pdir_entry(proc_index, pde_index);
  107068:	83 ec 08             	sub    $0x8,%esp
  10706b:	56                   	push   %esi
        for (pde_index = 0; pde_index < 1024; pde_index++) {
  10706c:	83 c6 01             	add    $0x1,%esi
                rmv_pdir_entry(proc_index, pde_index);
  10706f:	57                   	push   %edi
  107070:	e8 cb fc ff ff       	call   106d40 <rmv_pdir_entry>
        for (pde_index = 0; pde_index < 1024; pde_index++) {
  107075:	83 c4 10             	add    $0x10,%esp
            if ((pde_index < VM_USERLO_PDE) || (VM_USERHI_PDE <= pde_index)) {
  107078:	8d 86 00 ff ff ff    	lea    -0x100(%esi),%eax
  10707e:	3d bf 02 00 00       	cmp    $0x2bf,%eax
  107083:	76 e3                	jbe    107068 <pdir_init+0x28>
                set_pdir_entry_identity(proc_index, pde_index);
  107085:	50                   	push   %eax
  107086:	50                   	push   %eax
  107087:	56                   	push   %esi
        for (pde_index = 0; pde_index < 1024; pde_index++) {
  107088:	83 c6 01             	add    $0x1,%esi
                set_pdir_entry_identity(proc_index, pde_index);
  10708b:	57                   	push   %edi
  10708c:	e8 7f fc ff ff       	call   106d10 <set_pdir_entry_identity>
        for (pde_index = 0; pde_index < 1024; pde_index++) {
  107091:	83 c4 10             	add    $0x10,%esp
  107094:	81 fe 00 04 00 00    	cmp    $0x400,%esi
  10709a:	75 dc                	jne    107078 <pdir_init+0x38>
    for (proc_index = 0; proc_index < NUM_IDS; proc_index++) {
  10709c:	83 c7 01             	add    $0x1,%edi
  10709f:	83 ff 40             	cmp    $0x40,%edi
  1070a2:	75 bc                	jne    107060 <pdir_init+0x20>
            }
        }
    }
}
  1070a4:	5b                   	pop    %ebx
  1070a5:	5e                   	pop    %esi
  1070a6:	5f                   	pop    %edi
  1070a7:	c3                   	ret
  1070a8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1070af:	00 

001070b0 <alloc_ptbl>:
 * and clears (set to 0) all page table entries for this newly mapped page table.
 * It returns the page index of the newly allocated physical page.
 * In the case when there's no physical page available, it returns 0.
 */
unsigned int alloc_ptbl(unsigned int proc_index, unsigned int vaddr)
{
  1070b0:	55                   	push   %ebp
  1070b1:	57                   	push   %edi
  1070b2:	56                   	push   %esi
  1070b3:	53                   	push   %ebx
  1070b4:	e8 e9 92 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1070b9:	81 c3 3b ff 00 00    	add    $0xff3b,%ebx
  1070bf:	83 ec 28             	sub    $0x28,%esp
  1070c2:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    unsigned int page_index = container_alloc(proc_index);
  1070c6:	56                   	push   %esi
  1070c7:	e8 d4 fa ff ff       	call   106ba0 <container_alloc>
  1070cc:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    unsigned int pde_index = PDE_ADDR(vaddr);
    unsigned int pte_index;

    if (page_index == 0) {
  1070d0:	83 c4 10             	add    $0x10,%esp
  1070d3:	85 c0                	test   %eax,%eax
  1070d5:	75 0c                	jne    1070e3 <alloc_ptbl+0x33>
            rmv_ptbl_entry(proc_index, pde_index, pte_index);
        }

        return page_index;
    }
}
  1070d7:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1070db:	83 c4 1c             	add    $0x1c,%esp
  1070de:	5b                   	pop    %ebx
  1070df:	5e                   	pop    %esi
  1070e0:	5f                   	pop    %edi
  1070e1:	5d                   	pop    %ebp
  1070e2:	c3                   	ret
    unsigned int pde_index = PDE_ADDR(vaddr);
  1070e3:	8b 7c 24 34          	mov    0x34(%esp),%edi
        set_pdir_entry_by_va(proc_index, vaddr, page_index);
  1070e7:	83 ec 04             	sub    $0x4,%esp
        for (pte_index = 0; pte_index < 1024; pte_index++) {
  1070ea:	31 ed                	xor    %ebp,%ebp
        set_pdir_entry_by_va(proc_index, vaddr, page_index);
  1070ec:	50                   	push   %eax
  1070ed:	ff 74 24 3c          	push   0x3c(%esp)
    unsigned int pde_index = PDE_ADDR(vaddr);
  1070f1:	c1 ef 16             	shr    $0x16,%edi
        set_pdir_entry_by_va(proc_index, vaddr, page_index);
  1070f4:	56                   	push   %esi
  1070f5:	e8 a6 fe ff ff       	call   106fa0 <set_pdir_entry_by_va>
  1070fa:	83 c4 10             	add    $0x10,%esp
  1070fd:	8d 76 00             	lea    0x0(%esi),%esi
            rmv_ptbl_entry(proc_index, pde_index, pte_index);
  107100:	83 ec 04             	sub    $0x4,%esp
  107103:	55                   	push   %ebp
        for (pte_index = 0; pte_index < 1024; pte_index++) {
  107104:	83 c5 01             	add    $0x1,%ebp
            rmv_ptbl_entry(proc_index, pde_index, pte_index);
  107107:	57                   	push   %edi
  107108:	56                   	push   %esi
  107109:	e8 02 fd ff ff       	call   106e10 <rmv_ptbl_entry>
        for (pte_index = 0; pte_index < 1024; pte_index++) {
  10710e:	83 c4 10             	add    $0x10,%esp
  107111:	81 fd 00 04 00 00    	cmp    $0x400,%ebp
  107117:	75 e7                	jne    107100 <alloc_ptbl+0x50>
}
  107119:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10711d:	83 c4 1c             	add    $0x1c,%esp
  107120:	5b                   	pop    %ebx
  107121:	5e                   	pop    %esi
  107122:	5f                   	pop    %edi
  107123:	5d                   	pop    %ebp
  107124:	c3                   	ret
  107125:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10712c:	00 
  10712d:	8d 76 00             	lea    0x0(%esi),%esi

00107130 <free_ptbl>:

// Reverse operation of alloc_ptbl.
// Removes corresponding the page directory entry,
// and frees the page for the page table entries (with container_free).
void free_ptbl(unsigned int proc_index, unsigned int vaddr)
{
  107130:	55                   	push   %ebp
  107131:	57                   	push   %edi
  107132:	56                   	push   %esi
  107133:	53                   	push   %ebx
  107134:	e8 69 92 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107139:	81 c3 bb fe 00 00    	add    $0xfebb,%ebx
  10713f:	83 ec 14             	sub    $0x14,%esp
  107142:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  107146:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    unsigned int page_index = get_pdir_entry_by_va(proc_index, vaddr) >> 12;
  10714a:	57                   	push   %edi

    rmv_pdir_entry(proc_index, PDE_ADDR(vaddr));
  10714b:	c1 ef 16             	shr    $0x16,%edi
    unsigned int page_index = get_pdir_entry_by_va(proc_index, vaddr) >> 12;
  10714e:	55                   	push   %ebp
  10714f:	e8 4c fd ff ff       	call   106ea0 <get_pdir_entry_by_va>
  107154:	89 c6                	mov    %eax,%esi
    rmv_pdir_entry(proc_index, PDE_ADDR(vaddr));
  107156:	58                   	pop    %eax
  107157:	5a                   	pop    %edx
  107158:	57                   	push   %edi
  107159:	55                   	push   %ebp
    unsigned int page_index = get_pdir_entry_by_va(proc_index, vaddr) >> 12;
  10715a:	c1 ee 0c             	shr    $0xc,%esi
    rmv_pdir_entry(proc_index, PDE_ADDR(vaddr));
  10715d:	e8 de fb ff ff       	call   106d40 <rmv_pdir_entry>
    container_free(proc_index, page_index);
  107162:	59                   	pop    %ecx
  107163:	5f                   	pop    %edi
  107164:	56                   	push   %esi
  107165:	55                   	push   %ebp
  107166:	e8 a5 fa ff ff       	call   106c10 <container_free>
}
  10716b:	83 c4 1c             	add    $0x1c,%esp
  10716e:	5b                   	pop    %ebx
  10716f:	5e                   	pop    %esi
  107170:	5f                   	pop    %edi
  107171:	5d                   	pop    %ebp
  107172:	c3                   	ret
  107173:	66 90                	xchg   %ax,%ax
  107175:	66 90                	xchg   %ax,%ax
  107177:	66 90                	xchg   %ax,%ax
  107179:	66 90                	xchg   %ax,%ax
  10717b:	66 90                	xchg   %ax,%ax
  10717d:	66 90                	xchg   %ax,%ax
  10717f:	90                   	nop

00107180 <pdir_init_kern>:
/**
 * Sets the entire page map for process 0 as the identity map.
 * Note that part of the task is already completed by pdir_init.
 */
void pdir_init_kern(unsigned int mbi_addr)
{
  107180:	56                   	push   %esi
    unsigned int pde_index;

    pdir_init(mbi_addr);

    // Set identity map for user PDEs
    for (pde_index = VM_USERLO_PDE; pde_index < VM_USERHI_PDE; pde_index++) {
  107181:	be 00 01 00 00       	mov    $0x100,%esi
{
  107186:	53                   	push   %ebx
  107187:	e8 16 92 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10718c:	81 c3 68 fe 00 00    	add    $0xfe68,%ebx
  107192:	83 ec 10             	sub    $0x10,%esp
    pdir_init(mbi_addr);
  107195:	ff 74 24 1c          	push   0x1c(%esp)
  107199:	e8 a2 fe ff ff       	call   107040 <pdir_init>
  10719e:	83 c4 10             	add    $0x10,%esp
  1071a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        set_pdir_entry_identity(0, pde_index);
  1071a8:	83 ec 08             	sub    $0x8,%esp
  1071ab:	56                   	push   %esi
    for (pde_index = VM_USERLO_PDE; pde_index < VM_USERHI_PDE; pde_index++) {
  1071ac:	83 c6 01             	add    $0x1,%esi
        set_pdir_entry_identity(0, pde_index);
  1071af:	6a 00                	push   $0x0
  1071b1:	e8 5a fb ff ff       	call   106d10 <set_pdir_entry_identity>
    for (pde_index = VM_USERLO_PDE; pde_index < VM_USERHI_PDE; pde_index++) {
  1071b6:	83 c4 10             	add    $0x10,%esp
  1071b9:	81 fe c0 03 00 00    	cmp    $0x3c0,%esi
  1071bf:	75 e7                	jne    1071a8 <pdir_init_kern+0x28>
    }
}
  1071c1:	83 c4 04             	add    $0x4,%esp
  1071c4:	5b                   	pop    %ebx
  1071c5:	5e                   	pop    %esi
  1071c6:	c3                   	ret
  1071c7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1071ce:	00 
  1071cf:	90                   	nop

001071d0 <map_page>:
 * otherwise, it returns the physical page index registered in the page directory,
 * (the return value of get_pdir_entry_by_va or alloc_ptbl).
 */
unsigned int map_page(unsigned int proc_index, unsigned int vaddr,
                      unsigned int page_index, unsigned int perm)
{
  1071d0:	55                   	push   %ebp
  1071d1:	57                   	push   %edi
  1071d2:	56                   	push   %esi
  1071d3:	53                   	push   %ebx
  1071d4:	e8 c9 91 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1071d9:	81 c3 1b fe 00 00    	add    $0xfe1b,%ebx
  1071df:	83 ec 14             	sub    $0x14,%esp
  1071e2:	8b 7c 24 28          	mov    0x28(%esp),%edi
  1071e6:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
    unsigned int pde_entry = get_pdir_entry_by_va(proc_index, vaddr);
  1071ea:	55                   	push   %ebp
  1071eb:	57                   	push   %edi
  1071ec:	e8 af fc ff ff       	call   106ea0 <get_pdir_entry_by_va>
    unsigned int pde_page_index = pde_entry >> 12;

    if (pde_entry == 0) {
  1071f1:	83 c4 10             	add    $0x10,%esp
  1071f4:	85 c0                	test   %eax,%eax
  1071f6:	74 28                	je     107220 <map_page+0x50>
    unsigned int pde_page_index = pde_entry >> 12;
  1071f8:	c1 e8 0c             	shr    $0xc,%eax
  1071fb:	89 c6                	mov    %eax,%esi
        if (pde_page_index == 0) {
            return MagicNumber;
        }
    }

    set_ptbl_entry_by_va(proc_index, vaddr, page_index, perm);
  1071fd:	ff 74 24 2c          	push   0x2c(%esp)
  107201:	ff 74 24 2c          	push   0x2c(%esp)
  107205:	55                   	push   %ebp
  107206:	57                   	push   %edi
  107207:	e8 54 fd ff ff       	call   106f60 <set_ptbl_entry_by_va>
    return pde_page_index;
  10720c:	83 c4 10             	add    $0x10,%esp
}
  10720f:	89 f0                	mov    %esi,%eax
  107211:	83 c4 0c             	add    $0xc,%esp
  107214:	5b                   	pop    %ebx
  107215:	5e                   	pop    %esi
  107216:	5f                   	pop    %edi
  107217:	5d                   	pop    %ebp
  107218:	c3                   	ret
  107219:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        pde_page_index = alloc_ptbl(proc_index, vaddr);
  107220:	83 ec 08             	sub    $0x8,%esp
  107223:	55                   	push   %ebp
  107224:	57                   	push   %edi
  107225:	e8 86 fe ff ff       	call   1070b0 <alloc_ptbl>
        if (pde_page_index == 0) {
  10722a:	83 c4 10             	add    $0x10,%esp
        pde_page_index = alloc_ptbl(proc_index, vaddr);
  10722d:	89 c6                	mov    %eax,%esi
        if (pde_page_index == 0) {
  10722f:	85 c0                	test   %eax,%eax
  107231:	75 ca                	jne    1071fd <map_page+0x2d>
}
  107233:	83 c4 0c             	add    $0xc,%esp
            return MagicNumber;
  107236:	be 01 00 10 00       	mov    $0x100001,%esi
}
  10723b:	5b                   	pop    %ebx
  10723c:	89 f0                	mov    %esi,%eax
  10723e:	5e                   	pop    %esi
  10723f:	5f                   	pop    %edi
  107240:	5d                   	pop    %ebp
  107241:	c3                   	ret
  107242:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  107249:	00 
  10724a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00107250 <unmap_page>:
 * Nothing should be done if the mapping no longer exists.
 * You do not need to unmap the page table from the page directory.
 * It should return the corresponding page table entry.
 */
unsigned int unmap_page(unsigned int proc_index, unsigned int vaddr)
{
  107250:	55                   	push   %ebp
  107251:	57                   	push   %edi
  107252:	53                   	push   %ebx
  107253:	e8 4a 91 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107258:	81 c3 9c fd 00 00    	add    $0xfd9c,%ebx
  10725e:	83 ec 18             	sub    $0x18,%esp
  107261:	8b 7c 24 28          	mov    0x28(%esp),%edi
  107265:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
    unsigned int pte_entry = get_ptbl_entry_by_va(proc_index, vaddr);
  107269:	55                   	push   %ebp
  10726a:	57                   	push   %edi
  10726b:	e8 d0 fb ff ff       	call   106e40 <get_ptbl_entry_by_va>
    if (pte_entry != 0) {
  107270:	83 c4 10             	add    $0x10,%esp
  107273:	85 c0                	test   %eax,%eax
  107275:	75 09                	jne    107280 <unmap_page+0x30>
        rmv_ptbl_entry_by_va(proc_index, vaddr);
    }
    return pte_entry;
}
  107277:	83 c4 10             	add    $0x10,%esp
  10727a:	5b                   	pop    %ebx
  10727b:	5f                   	pop    %edi
  10727c:	5d                   	pop    %ebp
  10727d:	c3                   	ret
  10727e:	66 90                	xchg   %ax,%ax
  107280:	89 44 24 0c          	mov    %eax,0xc(%esp)
        rmv_ptbl_entry_by_va(proc_index, vaddr);
  107284:	83 ec 08             	sub    $0x8,%esp
  107287:	55                   	push   %ebp
  107288:	57                   	push   %edi
  107289:	e8 42 fc ff ff       	call   106ed0 <rmv_ptbl_entry_by_va>
  10728e:	83 c4 10             	add    $0x10,%esp
  107291:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  107295:	83 c4 10             	add    $0x10,%esp
  107298:	5b                   	pop    %ebx
  107299:	5f                   	pop    %edi
  10729a:	5d                   	pop    %ebp
  10729b:	c3                   	ret
  10729c:	66 90                	xchg   %ax,%ax
  10729e:	66 90                	xchg   %ax,%ax

001072a0 <paging_init>:
/**
 * Initializes the page structures, moves to the kernel page structure (0),
 * and turns on the paging.
 */
void paging_init(unsigned int mbi_addr)
{
  1072a0:	53                   	push   %ebx
  1072a1:	e8 fc 90 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1072a6:	81 c3 4e fd 00 00    	add    $0xfd4e,%ebx
  1072ac:	83 ec 14             	sub    $0x14,%esp
    pdir_init_kern(mbi_addr);
  1072af:	ff 74 24 1c          	push   0x1c(%esp)
  1072b3:	e8 c8 fe ff ff       	call   107180 <pdir_init_kern>
    set_pdir_base(0);
  1072b8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1072bf:	e8 cc f9 ff ff       	call   106c90 <set_pdir_base>
    enable_paging();
  1072c4:	e8 07 9f ff ff       	call   1011d0 <enable_paging>
}
  1072c9:	83 c4 18             	add    $0x18,%esp
  1072cc:	5b                   	pop    %ebx
  1072cd:	c3                   	ret
  1072ce:	66 90                	xchg   %ax,%ax

001072d0 <paging_init_ap>:

void paging_init_ap(void)
{
  1072d0:	53                   	push   %ebx
  1072d1:	e8 cc 90 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1072d6:	81 c3 1e fd 00 00    	add    $0xfd1e,%ebx
  1072dc:	83 ec 14             	sub    $0x14,%esp
    set_pdir_base(0);
  1072df:	6a 00                	push   $0x0
  1072e1:	e8 aa f9 ff ff       	call   106c90 <set_pdir_base>
    enable_paging();
  1072e6:	e8 e5 9e ff ff       	call   1011d0 <enable_paging>
}
  1072eb:	83 c4 18             	add    $0x18,%esp
  1072ee:	5b                   	pop    %ebx
  1072ef:	c3                   	ret

001072f0 <alloc_page>:
 * return value from map_page.
 * In the case of error, it should return the constant MagicNumber.
 */
unsigned int alloc_page(unsigned int proc_index, unsigned int vaddr,
                        unsigned int perm)
{
  1072f0:	56                   	push   %esi
  1072f1:	53                   	push   %ebx
  1072f2:	e8 ab 90 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1072f7:	81 c3 fd fc 00 00    	add    $0xfcfd,%ebx
  1072fd:	83 ec 10             	sub    $0x10,%esp
  107300:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    unsigned int page_index = container_alloc(proc_index);
  107304:	56                   	push   %esi
  107305:	e8 96 f8 ff ff       	call   106ba0 <container_alloc>
    if (page_index != 0) {
  10730a:	83 c4 10             	add    $0x10,%esp
  10730d:	ba 01 00 10 00       	mov    $0x100001,%edx
  107312:	85 c0                	test   %eax,%eax
  107314:	74 14                	je     10732a <alloc_page+0x3a>
        return map_page(proc_index, vaddr, page_index, perm);
  107316:	ff 74 24 18          	push   0x18(%esp)
  10731a:	50                   	push   %eax
  10731b:	ff 74 24 1c          	push   0x1c(%esp)
  10731f:	56                   	push   %esi
  107320:	e8 ab fe ff ff       	call   1071d0 <map_page>
  107325:	83 c4 10             	add    $0x10,%esp
  107328:	89 c2                	mov    %eax,%edx
    } else {
        return MagicNumber;
    }
}
  10732a:	83 c4 04             	add    $0x4,%esp
  10732d:	89 d0                	mov    %edx,%eax
  10732f:	5b                   	pop    %ebx
  107330:	5e                   	pop    %esi
  107331:	c3                   	ret
  107332:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  107339:	00 
  10733a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00107340 <alloc_mem_quota>:

/**
 * Designate some memory quota for the next child process.
 */
unsigned int alloc_mem_quota(unsigned int id, unsigned int quota)
{
  107340:	53                   	push   %ebx
  107341:	e8 5c 90 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107346:	81 c3 ae fc 00 00    	add    $0xfcae,%ebx
  10734c:	83 ec 10             	sub    $0x10,%esp
    unsigned int child;
    child = container_split(id, quota);
  10734f:	ff 74 24 1c          	push   0x1c(%esp)
  107353:	ff 74 24 1c          	push   0x1c(%esp)
  107357:	e8 a4 f7 ff ff       	call   106b00 <container_split>
    return child;
}
  10735c:	83 c4 18             	add    $0x18,%esp
  10735f:	5b                   	pop    %ebx
  107360:	c3                   	ret
  107361:	66 90                	xchg   %ax,%ax
  107363:	66 90                	xchg   %ax,%ax
  107365:	66 90                	xchg   %ax,%ax
  107367:	66 90                	xchg   %ax,%ax
  107369:	66 90                	xchg   %ax,%ax
  10736b:	66 90                	xchg   %ax,%ax
  10736d:	66 90                	xchg   %ax,%ax
  10736f:	90                   	nop

00107370 <kctx_set_esp>:
// Memory to save the NUM_IDS kernel thread states.
struct kctx kctx_pool[NUM_IDS];

void kctx_set_esp(unsigned int pid, void *esp)
{
    kctx_pool[pid].esp = esp;
  107370:	e8 29 90 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107375:	81 c2 7f fc 00 00    	add    $0xfc7f,%edx
{
  10737b:	8b 44 24 04          	mov    0x4(%esp),%eax
    kctx_pool[pid].esp = esp;
  10737f:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  107383:	8d 04 40             	lea    (%eax,%eax,2),%eax
  107386:	89 8c c2 0c 40 d1 00 	mov    %ecx,0xd1400c(%edx,%eax,8)
}
  10738d:	c3                   	ret
  10738e:	66 90                	xchg   %ax,%ax

00107390 <kctx_set_eip>:

void kctx_set_eip(unsigned int pid, void *eip)
{
    kctx_pool[pid].eip = eip;
  107390:	e8 09 90 ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107395:	81 c2 5f fc 00 00    	add    $0xfc5f,%edx
{
  10739b:	8b 44 24 04          	mov    0x4(%esp),%eax
    kctx_pool[pid].eip = eip;
  10739f:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1073a3:	8d 04 40             	lea    (%eax,%eax,2),%eax
  1073a6:	89 8c c2 20 40 d1 00 	mov    %ecx,0xd14020(%edx,%eax,8)
}
  1073ad:	c3                   	ret
  1073ae:	66 90                	xchg   %ax,%ax

001073b0 <kctx_switch>:
/**
 * Saves the states for thread # [from_pid] and restores the states
 * for thread # [to_pid].
 */
void kctx_switch(unsigned int from_pid, unsigned int to_pid)
{
  1073b0:	53                   	push   %ebx
  1073b1:	e8 ec 8f ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1073b6:	81 c3 3e fc 00 00    	add    $0xfc3e,%ebx
  1073bc:	83 ec 10             	sub    $0x10,%esp
  1073bf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1073c3:	8b 54 24 18          	mov    0x18(%esp),%edx
    cswitch(&kctx_pool[from_pid], &kctx_pool[to_pid]);
  1073c7:	8d 0c 40             	lea    (%eax,%eax,2),%ecx
  1073ca:	8d 14 52             	lea    (%edx,%edx,2),%edx
  1073cd:	8d 83 0c 40 d1 00    	lea    0xd1400c(%ebx),%eax
  1073d3:	8d 0c c8             	lea    (%eax,%ecx,8),%ecx
  1073d6:	8d 04 d0             	lea    (%eax,%edx,8),%eax
  1073d9:	51                   	push   %ecx
  1073da:	50                   	push   %eax
  1073db:	e8 05 00 00 00       	call   1073e5 <cswitch>
}
  1073e0:	83 c4 18             	add    $0x18,%esp
  1073e3:	5b                   	pop    %ebx
  1073e4:	c3                   	ret

001073e5 <cswitch>:
/*
 * void cswitch(struct kctx *from, struct kctx *to);
 */
	.globl cswitch
cswitch:
	movl	4(%esp), %eax	/* %eax <- from */
  1073e5:	8b 44 24 04          	mov    0x4(%esp),%eax
	movl	8(%esp), %edx	/* %edx <- to */
  1073e9:	8b 54 24 08          	mov    0x8(%esp),%edx

	/* save the old kernel context */
	movl	0(%esp), %ecx
  1073ed:	8b 0c 24             	mov    (%esp),%ecx
	movl	%ecx, 20(%eax)
  1073f0:	89 48 14             	mov    %ecx,0x14(%eax)
	movl	%ebp, 16(%eax)
  1073f3:	89 68 10             	mov    %ebp,0x10(%eax)
	movl	%ebx, 12(%eax)
  1073f6:	89 58 0c             	mov    %ebx,0xc(%eax)
	movl	%esi, 8(%eax)
  1073f9:	89 70 08             	mov    %esi,0x8(%eax)
	movl	%edi, 4(%eax)
  1073fc:	89 78 04             	mov    %edi,0x4(%eax)
	movl	%esp, 0(%eax)
  1073ff:	89 20                	mov    %esp,(%eax)

	/* load the new kernel context */
	movl	0(%edx), %esp
  107401:	8b 22                	mov    (%edx),%esp
	movl	4(%edx), %edi
  107403:	8b 7a 04             	mov    0x4(%edx),%edi
	movl	8(%edx), %esi
  107406:	8b 72 08             	mov    0x8(%edx),%esi
	movl	12(%edx), %ebx
  107409:	8b 5a 0c             	mov    0xc(%edx),%ebx
	movl	16(%edx), %ebp
  10740c:	8b 6a 10             	mov    0x10(%edx),%ebp
	movl	20(%edx), %ecx
  10740f:	8b 4a 14             	mov    0x14(%edx),%ecx
	movl	%ecx, 0(%esp)
  107412:	89 0c 24             	mov    %ecx,(%esp)

	xor	%eax, %eax
  107415:	31 c0                	xor    %eax,%eax
	ret
  107417:	c3                   	ret
  107418:	66 90                	xchg   %ax,%ax
  10741a:	66 90                	xchg   %ax,%ax
  10741c:	66 90                	xchg   %ax,%ax
  10741e:	66 90                	xchg   %ax,%ax

00107420 <kctx_new>:
 * Don't forget the stack is going down from high address to low.
 * We do not care about the rest of states when a new thread starts.
 * The function returns the child thread (process) id.
 */
unsigned int kctx_new(void *entry, unsigned int id, unsigned int quota)
{
  107420:	55                   	push   %ebp
  107421:	57                   	push   %edi
  107422:	56                   	push   %esi
    unsigned int pid = NUM_IDS;
  107423:	be 40 00 00 00       	mov    $0x40,%esi
{
  107428:	53                   	push   %ebx
  107429:	e8 74 8f ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10742e:	81 c3 c6 fb 00 00    	add    $0xfbc6,%ebx
  107434:	83 ec 14             	sub    $0x14,%esp
  107437:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  10743b:	8b 6c 24 30          	mov    0x30(%esp),%ebp

    if (container_can_consume(id, quota)) {
  10743f:	55                   	push   %ebp
  107440:	57                   	push   %edi
  107441:	e8 8a f6 ff ff       	call   106ad0 <container_can_consume>
  107446:	83 c4 10             	add    $0x10,%esp
  107449:	85 c0                	test   %eax,%eax
  10744b:	75 13                	jne    107460 <kctx_new+0x40>
            kctx_set_eip(pid, entry);
        }
    }

    return pid;
}
  10744d:	83 c4 0c             	add    $0xc,%esp
  107450:	89 f0                	mov    %esi,%eax
  107452:	5b                   	pop    %ebx
  107453:	5e                   	pop    %esi
  107454:	5f                   	pop    %edi
  107455:	5d                   	pop    %ebp
  107456:	c3                   	ret
  107457:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10745e:	00 
  10745f:	90                   	nop
        pid = alloc_mem_quota(id, quota);
  107460:	83 ec 08             	sub    $0x8,%esp
  107463:	55                   	push   %ebp
  107464:	57                   	push   %edi
  107465:	e8 d6 fe ff ff       	call   107340 <alloc_mem_quota>
        if (pid != NUM_IDS) {
  10746a:	83 c4 10             	add    $0x10,%esp
        pid = alloc_mem_quota(id, quota);
  10746d:	89 c6                	mov    %eax,%esi
        if (pid != NUM_IDS) {
  10746f:	83 f8 40             	cmp    $0x40,%eax
  107472:	74 d9                	je     10744d <kctx_new+0x2d>
            kctx_set_esp(pid, proc_kstack[pid].kstack_hi);
  107474:	8d 40 01             	lea    0x1(%eax),%eax
  107477:	83 ec 08             	sub    $0x8,%esp
  10747a:	c1 e0 0c             	shl    $0xc,%eax
  10747d:	81 c0 00 20 1a 00    	add    $0x1a2000,%eax
  107483:	50                   	push   %eax
  107484:	56                   	push   %esi
  107485:	e8 e6 fe ff ff       	call   107370 <kctx_set_esp>
            kctx_set_eip(pid, entry);
  10748a:	58                   	pop    %eax
  10748b:	5a                   	pop    %edx
  10748c:	ff 74 24 28          	push   0x28(%esp)
  107490:	56                   	push   %esi
  107491:	e8 fa fe ff ff       	call   107390 <kctx_set_eip>
  107496:	83 c4 10             	add    $0x10,%esp
}
  107499:	89 f0                	mov    %esi,%eax
  10749b:	83 c4 0c             	add    $0xc,%esp
  10749e:	5b                   	pop    %ebx
  10749f:	5e                   	pop    %esi
  1074a0:	5f                   	pop    %edi
  1074a1:	5d                   	pop    %ebp
  1074a2:	c3                   	ret
  1074a3:	66 90                	xchg   %ax,%ax
  1074a5:	66 90                	xchg   %ax,%ax
  1074a7:	66 90                	xchg   %ax,%ax
  1074a9:	66 90                	xchg   %ax,%ax
  1074ab:	66 90                	xchg   %ax,%ax
  1074ad:	66 90                	xchg   %ax,%ax
  1074af:	90                   	nop

001074b0 <tcb_get_state>:

struct TCB TCBPool[NUM_IDS];

unsigned int tcb_get_state(unsigned int pid)
{
    return TCBPool[pid].state;
  1074b0:	e8 e9 8e ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  1074b5:	81 c2 3f fb 00 00    	add    $0xfb3f,%edx
  1074bb:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  1074c0:	8b 84 02 0c 46 d1 00 	mov    0xd1460c(%edx,%eax,1),%eax
}
  1074c7:	c3                   	ret
  1074c8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1074cf:	00 

001074d0 <tcb_set_state>:

void tcb_set_state(unsigned int pid, unsigned int state)
{
    TCBPool[pid].state = state;
  1074d0:	e8 c9 8e ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  1074d5:	81 c2 1f fb 00 00    	add    $0xfb1f,%edx
  1074db:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  1074e0:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1074e4:	89 8c 02 0c 46 d1 00 	mov    %ecx,0xd1460c(%edx,%eax,1)
}
  1074eb:	c3                   	ret
  1074ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001074f0 <tcb_get_cpu>:

unsigned int tcb_get_cpu(unsigned int pid)
{
    return TCBPool[pid].cpuid;
  1074f0:	e8 a9 8e ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  1074f5:	81 c2 ff fa 00 00    	add    $0xfaff,%edx
  1074fb:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  107500:	8b 84 02 10 46 d1 00 	mov    0xd14610(%edx,%eax,1),%eax
}
  107507:	c3                   	ret
  107508:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10750f:	00 

00107510 <tcb_set_cpu>:

void tcb_set_cpu(unsigned int pid, unsigned int cpu)
{
    TCBPool[pid].cpuid = cpu;
  107510:	e8 89 8e ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107515:	81 c2 df fa 00 00    	add    $0xfadf,%edx
  10751b:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  107520:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  107524:	89 8c 02 10 46 d1 00 	mov    %ecx,0xd14610(%edx,%eax,1)
}
  10752b:	c3                   	ret
  10752c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00107530 <tcb_get_prev>:

unsigned int tcb_get_prev(unsigned int pid)
{
    return TCBPool[pid].prev;
  107530:	e8 69 8e ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107535:	81 c2 bf fa 00 00    	add    $0xfabf,%edx
  10753b:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  107540:	8b 84 02 14 46 d1 00 	mov    0xd14614(%edx,%eax,1),%eax
}
  107547:	c3                   	ret
  107548:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10754f:	00 

00107550 <tcb_set_prev>:

void tcb_set_prev(unsigned int pid, unsigned int prev_pid)
{
    TCBPool[pid].prev = prev_pid;
  107550:	e8 49 8e ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107555:	81 c2 9f fa 00 00    	add    $0xfa9f,%edx
  10755b:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  107560:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  107564:	89 8c 02 14 46 d1 00 	mov    %ecx,0xd14614(%edx,%eax,1)
}
  10756b:	c3                   	ret
  10756c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00107570 <tcb_get_next>:

unsigned int tcb_get_next(unsigned int pid)
{
    return TCBPool[pid].next;
  107570:	e8 29 8e ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107575:	81 c2 7f fa 00 00    	add    $0xfa7f,%edx
  10757b:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  107580:	8b 84 02 18 46 d1 00 	mov    0xd14618(%edx,%eax,1),%eax
}
  107587:	c3                   	ret
  107588:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10758f:	00 

00107590 <tcb_set_next>:

void tcb_set_next(unsigned int pid, unsigned int next_pid)
{
    TCBPool[pid].next = next_pid;
  107590:	e8 09 8e ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107595:	81 c2 5f fa 00 00    	add    $0xfa5f,%edx
  10759b:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  1075a0:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1075a4:	89 8c 02 18 46 d1 00 	mov    %ecx,0xd14618(%edx,%eax,1)
}
  1075ab:	c3                   	ret
  1075ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001075b0 <tcb_init_at_id>:

void tcb_init_at_id(unsigned int pid)
{
  1075b0:	57                   	push   %edi
    TCBPool[pid].state = TSTATE_DEAD;
  1075b1:	8d 3d 0c 46 d1 00    	lea    0xd1460c,%edi
{
  1075b7:	56                   	push   %esi
  1075b8:	53                   	push   %ebx
    TCBPool[pid].state = TSTATE_DEAD;
  1075b9:	6b 44 24 10 58       	imul   $0x58,0x10(%esp),%eax
  1075be:	e8 df 8d ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1075c3:	81 c3 31 fa 00 00    	add    $0xfa31,%ebx
    TCBPool[pid].cpuid = NUM_CPUS;
    TCBPool[pid].prev = NUM_IDS;
    TCBPool[pid].next = NUM_IDS;
    TCBPool[pid].channel = 0;
    memzero(TCBPool[pid].openfiles, sizeof *TCBPool[pid].openfiles);
  1075c9:	83 ec 08             	sub    $0x8,%esp
    TCBPool[pid].state = TSTATE_DEAD;
  1075cc:	8d 14 3b             	lea    (%ebx,%edi,1),%edx
    TCBPool[pid].cpuid = NUM_CPUS;
  1075cf:	8d 34 18             	lea    (%eax,%ebx,1),%esi
  1075d2:	01 fe                	add    %edi,%esi
    TCBPool[pid].state = TSTATE_DEAD;
  1075d4:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    memzero(TCBPool[pid].openfiles, sizeof *TCBPool[pid].openfiles);
  1075d7:	8d 44 02 14          	lea    0x14(%edx,%eax,1),%eax
    TCBPool[pid].state = TSTATE_DEAD;
  1075db:	c7 01 03 00 00 00    	movl   $0x3,(%ecx)
    TCBPool[pid].cpuid = NUM_CPUS;
  1075e1:	c7 46 04 08 00 00 00 	movl   $0x8,0x4(%esi)
    TCBPool[pid].prev = NUM_IDS;
  1075e8:	c7 46 08 40 00 00 00 	movl   $0x40,0x8(%esi)
    TCBPool[pid].next = NUM_IDS;
  1075ef:	c7 46 0c 40 00 00 00 	movl   $0x40,0xc(%esi)
    TCBPool[pid].channel = 0;
  1075f6:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
    memzero(TCBPool[pid].openfiles, sizeof *TCBPool[pid].openfiles);
  1075fd:	6a 04                	push   $0x4
  1075ff:	50                   	push   %eax
  107600:	e8 fb cf ff ff       	call   104600 <memzero>
    TCBPool[pid].cwd = namei("/");
  107605:	8d 83 b5 65 ff ff    	lea    -0x9a4b(%ebx),%eax
  10760b:	89 04 24             	mov    %eax,(%esp)
  10760e:	e8 bd 30 00 00       	call   10a6d0 <namei>
}
  107613:	83 c4 10             	add    $0x10,%esp
    TCBPool[pid].cwd = namei("/");
  107616:	89 46 54             	mov    %eax,0x54(%esi)
}
  107619:	5b                   	pop    %ebx
  10761a:	5e                   	pop    %esi
  10761b:	5f                   	pop    %edi
  10761c:	c3                   	ret
  10761d:	8d 76 00             	lea    0x0(%esi),%esi

00107620 <tcb_get_chan>:

void *tcb_get_chan(unsigned int pid)
{
    return TCBPool[pid].channel;
  107620:	e8 79 8d ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107625:	81 c2 cf f9 00 00    	add    $0xf9cf,%edx
  10762b:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  107630:	8b 84 02 1c 46 d1 00 	mov    0xd1461c(%edx,%eax,1),%eax
}
  107637:	c3                   	ret
  107638:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10763f:	00 

00107640 <tcb_set_chan>:

void tcb_set_chan(unsigned int pid, void *chan)
{
    TCBPool[pid].channel = chan;
  107640:	e8 59 8d ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107645:	81 c2 af f9 00 00    	add    $0xf9af,%edx
  10764b:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  107650:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  107654:	89 8c 02 1c 46 d1 00 	mov    %ecx,0xd1461c(%edx,%eax,1)
}
  10765b:	c3                   	ret
  10765c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00107660 <tcb_get_openfiles>:

struct file **tcb_get_openfiles(unsigned int pid)
{
    return TCBPool[pid].openfiles;
  107660:	e8 39 8d ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107665:	81 c2 8f f9 00 00    	add    $0xf98f,%edx
  10766b:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  107670:	8d 84 02 20 46 d1 00 	lea    0xd14620(%edx,%eax,1),%eax
}
  107677:	c3                   	ret
  107678:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10767f:	00 

00107680 <tcb_set_openfiles>:

void tcb_set_openfiles(unsigned int pid, int fd, struct file *f)
{
    TCBPool[pid].openfiles[fd] = f;
  107680:	e8 19 8d ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  107685:	81 c2 6f f9 00 00    	add    $0xf96f,%edx
  10768b:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  10768f:	6b 44 24 04 16       	imul   $0x16,0x4(%esp),%eax
  107694:	03 44 24 08          	add    0x8(%esp),%eax
  107698:	89 8c 82 20 46 d1 00 	mov    %ecx,0xd14620(%edx,%eax,4)
}
  10769f:	c3                   	ret

001076a0 <tcb_get_cwd>:

struct inode *tcb_get_cwd(unsigned int pid)
{
    return TCBPool[pid].cwd;
  1076a0:	e8 f9 8c ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  1076a5:	81 c2 4f f9 00 00    	add    $0xf94f,%edx
  1076ab:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  1076b0:	8b 84 02 60 46 d1 00 	mov    0xd14660(%edx,%eax,1),%eax
}
  1076b7:	c3                   	ret
  1076b8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1076bf:	00 

001076c0 <tcb_set_cwd>:

void tcb_set_cwd(unsigned int pid, struct inode *d)
{
    TCBPool[pid].cwd = d;
  1076c0:	e8 d9 8c ff ff       	call   10039e <__x86.get_pc_thunk.dx>
  1076c5:	81 c2 2f f9 00 00    	add    $0xf92f,%edx
  1076cb:	6b 44 24 04 58       	imul   $0x58,0x4(%esp),%eax
  1076d0:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1076d4:	89 8c 02 60 46 d1 00 	mov    %ecx,0xd14660(%edx,%eax,1)
}
  1076db:	c3                   	ret
  1076dc:	66 90                	xchg   %ax,%ax
  1076de:	66 90                	xchg   %ax,%ax

001076e0 <tcb_init>:
/**
 * Initializes the TCB for all NUM_IDS threads with the state TSTATE_DEAD,
 * and with two indices being NUM_IDS (which represents NULL).
 */
void tcb_init(unsigned int mbi_addr)
{
  1076e0:	56                   	push   %esi
    unsigned int pid = 0;
  1076e1:	31 f6                	xor    %esi,%esi
{
  1076e3:	53                   	push   %ebx
  1076e4:	e8 b9 8c ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1076e9:	81 c3 0b f9 00 00    	add    $0xf90b,%ebx
  1076ef:	83 ec 10             	sub    $0x10,%esp
    paging_init(mbi_addr);
  1076f2:	ff 74 24 1c          	push   0x1c(%esp)
  1076f6:	e8 a5 fb ff ff       	call   1072a0 <paging_init>
  1076fb:	83 c4 10             	add    $0x10,%esp
  1076fe:	66 90                	xchg   %ax,%ax

    while (pid < NUM_IDS) {
        tcb_init_at_id(pid);
  107700:	83 ec 0c             	sub    $0xc,%esp
  107703:	56                   	push   %esi
        pid++;
  107704:	83 c6 01             	add    $0x1,%esi
        tcb_init_at_id(pid);
  107707:	e8 a4 fe ff ff       	call   1075b0 <tcb_init_at_id>
    while (pid < NUM_IDS) {
  10770c:	83 c4 10             	add    $0x10,%esp
  10770f:	83 fe 40             	cmp    $0x40,%esi
  107712:	75 ec                	jne    107700 <tcb_init+0x20>
    }
}
  107714:	83 c4 04             	add    $0x4,%esp
  107717:	5b                   	pop    %ebx
  107718:	5e                   	pop    %esi
  107719:	c3                   	ret
  10771a:	66 90                	xchg   %ax,%ax
  10771c:	66 90                	xchg   %ax,%ax
  10771e:	66 90                	xchg   %ax,%ax

00107720 <tqueue_get_head>:
 */
struct TQueue TQueuePool[NUM_IDS + NUM_CPUS];

unsigned int tqueue_get_head(unsigned int chid)
{
    return TQueuePool[chid].head;
  107720:	e8 75 8c ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  107725:	05 cf f8 00 00       	add    $0xf8cf,%eax
  10772a:	8b 54 24 04          	mov    0x4(%esp),%edx
  10772e:	8b 84 d0 6c 5c d1 00 	mov    0xd15c6c(%eax,%edx,8),%eax
}
  107735:	c3                   	ret
  107736:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10773d:	00 
  10773e:	66 90                	xchg   %ax,%ax

00107740 <tqueue_set_head>:

void tqueue_set_head(unsigned int chid, unsigned int head)
{
    TQueuePool[chid].head = head;
  107740:	e8 55 8c ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  107745:	05 af f8 00 00       	add    $0xf8af,%eax
  10774a:	8b 54 24 04          	mov    0x4(%esp),%edx
  10774e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  107752:	89 8c d0 6c 5c d1 00 	mov    %ecx,0xd15c6c(%eax,%edx,8)
}
  107759:	c3                   	ret
  10775a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00107760 <tqueue_get_tail>:

unsigned int tqueue_get_tail(unsigned int chid)
{
    return TQueuePool[chid].tail;
  107760:	e8 35 8c ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  107765:	05 8f f8 00 00       	add    $0xf88f,%eax
  10776a:	8b 54 24 04          	mov    0x4(%esp),%edx
  10776e:	8b 84 d0 70 5c d1 00 	mov    0xd15c70(%eax,%edx,8),%eax
}
  107775:	c3                   	ret
  107776:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10777d:	00 
  10777e:	66 90                	xchg   %ax,%ax

00107780 <tqueue_set_tail>:

void tqueue_set_tail(unsigned int chid, unsigned int tail)
{
    TQueuePool[chid].tail = tail;
  107780:	e8 15 8c ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  107785:	05 6f f8 00 00       	add    $0xf86f,%eax
  10778a:	8b 54 24 04          	mov    0x4(%esp),%edx
  10778e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  107792:	89 8c d0 70 5c d1 00 	mov    %ecx,0xd15c70(%eax,%edx,8)
}
  107799:	c3                   	ret
  10779a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001077a0 <tqueue_init_at_id>:

void tqueue_init_at_id(unsigned int chid)
{
    TQueuePool[chid].head = NUM_IDS;
  1077a0:	e8 f5 8b ff ff       	call   10039a <__x86.get_pc_thunk.ax>
  1077a5:	05 4f f8 00 00       	add    $0xf84f,%eax
{
  1077aa:	8b 54 24 04          	mov    0x4(%esp),%edx
    TQueuePool[chid].head = NUM_IDS;
  1077ae:	c7 84 d0 6c 5c d1 00 	movl   $0x40,0xd15c6c(%eax,%edx,8)
  1077b5:	40 00 00 00 
    TQueuePool[chid].tail = NUM_IDS;
  1077b9:	c7 84 d0 70 5c d1 00 	movl   $0x40,0xd15c70(%eax,%edx,8)
  1077c0:	40 00 00 00 
}
  1077c4:	c3                   	ret
  1077c5:	66 90                	xchg   %ax,%ax
  1077c7:	66 90                	xchg   %ax,%ax
  1077c9:	66 90                	xchg   %ax,%ax
  1077cb:	66 90                	xchg   %ax,%ax
  1077cd:	66 90                	xchg   %ax,%ax
  1077cf:	90                   	nop

001077d0 <tqueue_init>:

/**
 * Initializes all the thread queues with tqueue_init_at_id.
 */
void tqueue_init(unsigned int mbi_addr)
{
  1077d0:	56                   	push   %esi
    unsigned int cpu_idx, chid;
    tcb_init(mbi_addr);

    chid = 0;
  1077d1:	31 f6                	xor    %esi,%esi
{
  1077d3:	53                   	push   %ebx
  1077d4:	e8 c9 8b ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1077d9:	81 c3 1b f8 00 00    	add    $0xf81b,%ebx
  1077df:	83 ec 10             	sub    $0x10,%esp
    tcb_init(mbi_addr);
  1077e2:	ff 74 24 1c          	push   0x1c(%esp)
  1077e6:	e8 f5 fe ff ff       	call   1076e0 <tcb_init>
  1077eb:	83 c4 10             	add    $0x10,%esp
  1077ee:	66 90                	xchg   %ax,%ax
    while (chid < NUM_IDS + NUM_CPUS) {
        tqueue_init_at_id(chid);
  1077f0:	83 ec 0c             	sub    $0xc,%esp
  1077f3:	56                   	push   %esi
        chid++;
  1077f4:	83 c6 01             	add    $0x1,%esi
        tqueue_init_at_id(chid);
  1077f7:	e8 a4 ff ff ff       	call   1077a0 <tqueue_init_at_id>
    while (chid < NUM_IDS + NUM_CPUS) {
  1077fc:	83 c4 10             	add    $0x10,%esp
  1077ff:	83 fe 48             	cmp    $0x48,%esi
  107802:	75 ec                	jne    1077f0 <tqueue_init+0x20>
    }
}
  107804:	83 c4 04             	add    $0x4,%esp
  107807:	5b                   	pop    %ebx
  107808:	5e                   	pop    %esi
  107809:	c3                   	ret
  10780a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00107810 <tqueue_enqueue>:
 * Recall that the doubly linked list is index based.
 * So you only need to insert the index.
 * Hint: there are multiple cases in this function.
 */
void tqueue_enqueue(unsigned int chid, unsigned int pid)
{
  107810:	55                   	push   %ebp
  107811:	57                   	push   %edi
  107812:	56                   	push   %esi
  107813:	53                   	push   %ebx
  107814:	e8 89 8b ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107819:	81 c3 db f7 00 00    	add    $0xf7db,%ebx
  10781f:	83 ec 18             	sub    $0x18,%esp
  107822:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  107826:	8b 74 24 30          	mov    0x30(%esp),%esi
    unsigned int tail = tqueue_get_tail(chid);
  10782a:	57                   	push   %edi
  10782b:	e8 30 ff ff ff       	call   107760 <tqueue_get_tail>

    if (tail == NUM_IDS) {
  107830:	83 c4 10             	add    $0x10,%esp
  107833:	83 f8 40             	cmp    $0x40,%eax
  107836:	74 38                	je     107870 <tqueue_enqueue+0x60>
        tcb_set_prev(pid, NUM_IDS);
        tcb_set_next(pid, NUM_IDS);
        tqueue_set_head(chid, pid);
        tqueue_set_tail(chid, pid);
    } else {
        tcb_set_next(tail, pid);
  107838:	83 ec 08             	sub    $0x8,%esp
  10783b:	89 c5                	mov    %eax,%ebp
  10783d:	56                   	push   %esi
  10783e:	50                   	push   %eax
  10783f:	e8 4c fd ff ff       	call   107590 <tcb_set_next>
        tcb_set_prev(pid, tail);
  107844:	59                   	pop    %ecx
  107845:	58                   	pop    %eax
  107846:	55                   	push   %ebp
  107847:	56                   	push   %esi
  107848:	e8 03 fd ff ff       	call   107550 <tcb_set_prev>
        tcb_set_next(pid, NUM_IDS);
  10784d:	58                   	pop    %eax
  10784e:	5a                   	pop    %edx
  10784f:	6a 40                	push   $0x40
  107851:	56                   	push   %esi
  107852:	e8 39 fd ff ff       	call   107590 <tcb_set_next>
        tqueue_set_tail(chid, pid);
  107857:	58                   	pop    %eax
  107858:	5a                   	pop    %edx
  107859:	56                   	push   %esi
  10785a:	57                   	push   %edi
  10785b:	e8 20 ff ff ff       	call   107780 <tqueue_set_tail>
  107860:	83 c4 10             	add    $0x10,%esp
    }
}
  107863:	83 c4 0c             	add    $0xc,%esp
  107866:	5b                   	pop    %ebx
  107867:	5e                   	pop    %esi
  107868:	5f                   	pop    %edi
  107869:	5d                   	pop    %ebp
  10786a:	c3                   	ret
  10786b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        tcb_set_prev(pid, NUM_IDS);
  107870:	83 ec 08             	sub    $0x8,%esp
  107873:	6a 40                	push   $0x40
  107875:	56                   	push   %esi
  107876:	e8 d5 fc ff ff       	call   107550 <tcb_set_prev>
        tcb_set_next(pid, NUM_IDS);
  10787b:	59                   	pop    %ecx
  10787c:	5d                   	pop    %ebp
  10787d:	6a 40                	push   $0x40
  10787f:	56                   	push   %esi
  107880:	e8 0b fd ff ff       	call   107590 <tcb_set_next>
        tqueue_set_head(chid, pid);
  107885:	58                   	pop    %eax
  107886:	5a                   	pop    %edx
  107887:	56                   	push   %esi
  107888:	57                   	push   %edi
  107889:	e8 b2 fe ff ff       	call   107740 <tqueue_set_head>
        tqueue_set_tail(chid, pid);
  10788e:	eb c7                	jmp    107857 <tqueue_enqueue+0x47>

00107890 <tqueue_dequeue>:
 * Reverse action of tqueue_enqueue, i.e. pops a TCB from the head of the specified queue.
 * It returns the popped thread's id, or NUM_IDS if the queue is empty.
 * Hint: there are multiple cases in this function.
 */
unsigned int tqueue_dequeue(unsigned int chid)
{
  107890:	55                   	push   %ebp
  107891:	57                   	push   %edi
  107892:	56                   	push   %esi
  107893:	53                   	push   %ebx
  107894:	e8 09 8b ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107899:	81 c3 5b f7 00 00    	add    $0xf75b,%ebx
  10789f:	83 ec 18             	sub    $0x18,%esp
  1078a2:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    unsigned int head, next, pid;

    pid = NUM_IDS;
    head = tqueue_get_head(chid);
  1078a6:	57                   	push   %edi
  1078a7:	e8 74 fe ff ff       	call   107720 <tqueue_get_head>

    if (head != NUM_IDS) {
  1078ac:	83 c4 10             	add    $0x10,%esp
    head = tqueue_get_head(chid);
  1078af:	89 c6                	mov    %eax,%esi
    if (head != NUM_IDS) {
  1078b1:	83 f8 40             	cmp    $0x40,%eax
  1078b4:	74 42                	je     1078f8 <tqueue_dequeue+0x68>
        pid = head;
        next = tcb_get_next(head);
  1078b6:	83 ec 0c             	sub    $0xc,%esp
  1078b9:	50                   	push   %eax
  1078ba:	e8 b1 fc ff ff       	call   107570 <tcb_get_next>

        if (next == NUM_IDS) {
  1078bf:	83 c4 10             	add    $0x10,%esp
        next = tcb_get_next(head);
  1078c2:	89 c5                	mov    %eax,%ebp
        if (next == NUM_IDS) {
  1078c4:	83 f8 40             	cmp    $0x40,%eax
  1078c7:	74 3f                	je     107908 <tqueue_dequeue+0x78>
            tqueue_set_head(chid, NUM_IDS);
            tqueue_set_tail(chid, NUM_IDS);
        } else {
            tcb_set_prev(next, NUM_IDS);
  1078c9:	83 ec 08             	sub    $0x8,%esp
  1078cc:	6a 40                	push   $0x40
  1078ce:	50                   	push   %eax
  1078cf:	e8 7c fc ff ff       	call   107550 <tcb_set_prev>
            tqueue_set_head(chid, next);
  1078d4:	59                   	pop    %ecx
  1078d5:	58                   	pop    %eax
  1078d6:	55                   	push   %ebp
  1078d7:	57                   	push   %edi
  1078d8:	e8 63 fe ff ff       	call   107740 <tqueue_set_head>
  1078dd:	83 c4 10             	add    $0x10,%esp
        }
        tcb_set_prev(pid, NUM_IDS);
  1078e0:	83 ec 08             	sub    $0x8,%esp
  1078e3:	6a 40                	push   $0x40
  1078e5:	56                   	push   %esi
  1078e6:	e8 65 fc ff ff       	call   107550 <tcb_set_prev>
        tcb_set_next(pid, NUM_IDS);
  1078eb:	58                   	pop    %eax
  1078ec:	5a                   	pop    %edx
  1078ed:	6a 40                	push   $0x40
  1078ef:	56                   	push   %esi
  1078f0:	e8 9b fc ff ff       	call   107590 <tcb_set_next>
  1078f5:	83 c4 10             	add    $0x10,%esp
    }

    return pid;
}
  1078f8:	83 c4 0c             	add    $0xc,%esp
  1078fb:	89 f0                	mov    %esi,%eax
  1078fd:	5b                   	pop    %ebx
  1078fe:	5e                   	pop    %esi
  1078ff:	5f                   	pop    %edi
  107900:	5d                   	pop    %ebp
  107901:	c3                   	ret
  107902:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            tqueue_set_head(chid, NUM_IDS);
  107908:	83 ec 08             	sub    $0x8,%esp
  10790b:	6a 40                	push   $0x40
  10790d:	57                   	push   %edi
  10790e:	e8 2d fe ff ff       	call   107740 <tqueue_set_head>
            tqueue_set_tail(chid, NUM_IDS);
  107913:	58                   	pop    %eax
  107914:	5a                   	pop    %edx
  107915:	6a 40                	push   $0x40
  107917:	57                   	push   %edi
  107918:	e8 63 fe ff ff       	call   107780 <tqueue_set_tail>
  10791d:	83 c4 10             	add    $0x10,%esp
  107920:	eb be                	jmp    1078e0 <tqueue_dequeue+0x50>
  107922:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  107929:	00 
  10792a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00107930 <tqueue_remove>:
/**
 * Removes the TCB #pid from the queue #chid.
 * Hint: there are many cases in this function.
 */
void tqueue_remove(unsigned int chid, unsigned int pid)
{
  107930:	55                   	push   %ebp
  107931:	57                   	push   %edi
  107932:	56                   	push   %esi
  107933:	53                   	push   %ebx
  107934:	e8 69 8a ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107939:	81 c3 bb f6 00 00    	add    $0xf6bb,%ebx
  10793f:	83 ec 18             	sub    $0x18,%esp
  107942:	8b 7c 24 30          	mov    0x30(%esp),%edi
    unsigned int prev, next;

    prev = tcb_get_prev(pid);
  107946:	57                   	push   %edi
  107947:	e8 e4 fb ff ff       	call   107530 <tcb_get_prev>
    next = tcb_get_next(pid);
  10794c:	89 3c 24             	mov    %edi,(%esp)
    prev = tcb_get_prev(pid);
  10794f:	89 c5                	mov    %eax,%ebp
    next = tcb_get_next(pid);
  107951:	e8 1a fc ff ff       	call   107570 <tcb_get_next>

    if (prev == NUM_IDS) {
  107956:	83 c4 10             	add    $0x10,%esp
    next = tcb_get_next(pid);
  107959:	89 c6                	mov    %eax,%esi
    if (prev == NUM_IDS) {
  10795b:	83 fd 40             	cmp    $0x40,%ebp
  10795e:	74 50                	je     1079b0 <tqueue_remove+0x80>
        } else {
            tcb_set_prev(next, NUM_IDS);
            tqueue_set_head(chid, next);
        }
    } else {
        if (next == NUM_IDS) {
  107960:	83 f8 40             	cmp    $0x40,%eax
  107963:	74 73                	je     1079d8 <tqueue_remove+0xa8>
            tcb_set_next(prev, NUM_IDS);
            tqueue_set_tail(chid, prev);
        } else {
            if (prev != next)
  107965:	39 c5                	cmp    %eax,%ebp
  107967:	75 2f                	jne    107998 <tqueue_remove+0x68>
                tcb_set_next(prev, next);
            tcb_set_prev(next, prev);
  107969:	83 ec 08             	sub    $0x8,%esp
  10796c:	55                   	push   %ebp
  10796d:	56                   	push   %esi
  10796e:	e8 dd fb ff ff       	call   107550 <tcb_set_prev>
  107973:	83 c4 10             	add    $0x10,%esp
        }
    }
    tcb_set_prev(pid, NUM_IDS);
  107976:	83 ec 08             	sub    $0x8,%esp
  107979:	6a 40                	push   $0x40
  10797b:	57                   	push   %edi
  10797c:	e8 cf fb ff ff       	call   107550 <tcb_set_prev>
    tcb_set_next(pid, NUM_IDS);
  107981:	58                   	pop    %eax
  107982:	5a                   	pop    %edx
  107983:	6a 40                	push   $0x40
  107985:	57                   	push   %edi
  107986:	e8 05 fc ff ff       	call   107590 <tcb_set_next>
}
  10798b:	83 c4 1c             	add    $0x1c,%esp
  10798e:	5b                   	pop    %ebx
  10798f:	5e                   	pop    %esi
  107990:	5f                   	pop    %edi
  107991:	5d                   	pop    %ebp
  107992:	c3                   	ret
  107993:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
                tcb_set_next(prev, next);
  107998:	83 ec 08             	sub    $0x8,%esp
  10799b:	50                   	push   %eax
  10799c:	55                   	push   %ebp
  10799d:	e8 ee fb ff ff       	call   107590 <tcb_set_next>
  1079a2:	83 c4 10             	add    $0x10,%esp
  1079a5:	eb c2                	jmp    107969 <tqueue_remove+0x39>
  1079a7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1079ae:	00 
  1079af:	90                   	nop
        if (next == NUM_IDS) {
  1079b0:	83 f8 40             	cmp    $0x40,%eax
  1079b3:	74 43                	je     1079f8 <tqueue_remove+0xc8>
            tcb_set_prev(next, NUM_IDS);
  1079b5:	83 ec 08             	sub    $0x8,%esp
  1079b8:	6a 40                	push   $0x40
  1079ba:	50                   	push   %eax
  1079bb:	e8 90 fb ff ff       	call   107550 <tcb_set_prev>
            tqueue_set_head(chid, next);
  1079c0:	5d                   	pop    %ebp
  1079c1:	58                   	pop    %eax
  1079c2:	56                   	push   %esi
  1079c3:	ff 74 24 2c          	push   0x2c(%esp)
  1079c7:	e8 74 fd ff ff       	call   107740 <tqueue_set_head>
  1079cc:	83 c4 10             	add    $0x10,%esp
  1079cf:	eb a5                	jmp    107976 <tqueue_remove+0x46>
  1079d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            tcb_set_next(prev, NUM_IDS);
  1079d8:	83 ec 08             	sub    $0x8,%esp
  1079db:	6a 40                	push   $0x40
  1079dd:	55                   	push   %ebp
  1079de:	e8 ad fb ff ff       	call   107590 <tcb_set_next>
            tqueue_set_tail(chid, prev);
  1079e3:	59                   	pop    %ecx
  1079e4:	5e                   	pop    %esi
  1079e5:	55                   	push   %ebp
  1079e6:	ff 74 24 2c          	push   0x2c(%esp)
  1079ea:	e8 91 fd ff ff       	call   107780 <tqueue_set_tail>
  1079ef:	83 c4 10             	add    $0x10,%esp
  1079f2:	eb 82                	jmp    107976 <tqueue_remove+0x46>
  1079f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            tqueue_set_head(chid, NUM_IDS);
  1079f8:	83 ec 08             	sub    $0x8,%esp
  1079fb:	6a 40                	push   $0x40
  1079fd:	ff 74 24 2c          	push   0x2c(%esp)
  107a01:	e8 3a fd ff ff       	call   107740 <tqueue_set_head>
            tqueue_set_tail(chid, NUM_IDS);
  107a06:	58                   	pop    %eax
  107a07:	5a                   	pop    %edx
  107a08:	6a 40                	push   $0x40
  107a0a:	ff 74 24 2c          	push   0x2c(%esp)
  107a0e:	e8 6d fd ff ff       	call   107780 <tqueue_set_tail>
  107a13:	83 c4 10             	add    $0x10,%esp
  107a16:	e9 5b ff ff ff       	jmp    107976 <tqueue_remove+0x46>
  107a1b:	66 90                	xchg   %ax,%ax
  107a1d:	66 90                	xchg   %ax,%ax
  107a1f:	90                   	nop

00107a20 <get_curid>:
#include <pcpu/PCPUIntro/export.h>

unsigned int CURID[NUM_CPUS];

unsigned int get_curid(void)
{
  107a20:	53                   	push   %ebx
  107a21:	e8 7c 89 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107a26:	81 c3 ce f5 00 00    	add    $0xf5ce,%ebx
  107a2c:	83 ec 08             	sub    $0x8,%esp
    return CURID[get_pcpu_idx()];
  107a2f:	e8 2c e8 ff ff       	call   106260 <get_pcpu_idx>
  107a34:	8b 84 83 ac 5e d1 00 	mov    0xd15eac(%ebx,%eax,4),%eax
}
  107a3b:	83 c4 08             	add    $0x8,%esp
  107a3e:	5b                   	pop    %ebx
  107a3f:	c3                   	ret

00107a40 <set_curid>:

void set_curid(unsigned int curid)
{
  107a40:	53                   	push   %ebx
  107a41:	e8 5c 89 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107a46:	81 c3 ae f5 00 00    	add    $0xf5ae,%ebx
  107a4c:	83 ec 08             	sub    $0x8,%esp
    CURID[get_pcpu_idx()] = curid;
  107a4f:	e8 0c e8 ff ff       	call   106260 <get_pcpu_idx>
  107a54:	8b 54 24 10          	mov    0x10(%esp),%edx
  107a58:	89 94 83 ac 5e d1 00 	mov    %edx,0xd15eac(%ebx,%eax,4)
}
  107a5f:	83 c4 08             	add    $0x8,%esp
  107a62:	5b                   	pop    %ebx
  107a63:	c3                   	ret
  107a64:	66 90                	xchg   %ax,%ax
  107a66:	66 90                	xchg   %ax,%ax
  107a68:	66 90                	xchg   %ax,%ax
  107a6a:	66 90                	xchg   %ax,%ax
  107a6c:	66 90                	xchg   %ax,%ax
  107a6e:	66 90                	xchg   %ax,%ax

00107a70 <thread_init>:
static spinlock_t sched_lk;

unsigned int sched_ticks[NUM_CPUS];

void thread_init(unsigned int mbi_addr)
{
  107a70:	53                   	push   %ebx
  107a71:	e8 2c 89 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107a76:	81 c3 7e f5 00 00    	add    $0xf57e,%ebx
  107a7c:	83 ec 14             	sub    $0x14,%esp
    unsigned int i;
    for (i = 0; i < NUM_CPUS; i++) {
        sched_ticks[i] = 0;
  107a7f:	c7 83 cc 5e d1 00 00 	movl   $0x0,0xd15ecc(%ebx)
  107a86:	00 00 00 
    }

    spinlock_init(&sched_lk);
  107a89:	8d 83 ec 5e d1 00    	lea    0xd15eec(%ebx),%eax
  107a8f:	50                   	push   %eax
        sched_ticks[i] = 0;
  107a90:	c7 83 d0 5e d1 00 00 	movl   $0x0,0xd15ed0(%ebx)
  107a97:	00 00 00 
  107a9a:	c7 83 d4 5e d1 00 00 	movl   $0x0,0xd15ed4(%ebx)
  107aa1:	00 00 00 
  107aa4:	c7 83 d8 5e d1 00 00 	movl   $0x0,0xd15ed8(%ebx)
  107aab:	00 00 00 
  107aae:	c7 83 dc 5e d1 00 00 	movl   $0x0,0xd15edc(%ebx)
  107ab5:	00 00 00 
  107ab8:	c7 83 e0 5e d1 00 00 	movl   $0x0,0xd15ee0(%ebx)
  107abf:	00 00 00 
  107ac2:	c7 83 e4 5e d1 00 00 	movl   $0x0,0xd15ee4(%ebx)
  107ac9:	00 00 00 
  107acc:	c7 83 e8 5e d1 00 00 	movl   $0x0,0xd15ee8(%ebx)
  107ad3:	00 00 00 
    spinlock_init(&sched_lk);
  107ad6:	e8 e5 e3 ff ff       	call   105ec0 <spinlock_init>
    tqueue_init(mbi_addr);
  107adb:	58                   	pop    %eax
  107adc:	ff 74 24 1c          	push   0x1c(%esp)
  107ae0:	e8 eb fc ff ff       	call   1077d0 <tqueue_init>
    set_curid(0);
  107ae5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107aec:	e8 4f ff ff ff       	call   107a40 <set_curid>
    tcb_set_state(0, TSTATE_RUN);
  107af1:	5a                   	pop    %edx
  107af2:	59                   	pop    %ecx
  107af3:	6a 01                	push   $0x1
  107af5:	6a 00                	push   $0x0
  107af7:	e8 d4 f9 ff ff       	call   1074d0 <tcb_set_state>
}
  107afc:	83 c4 18             	add    $0x18,%esp
  107aff:	5b                   	pop    %ebx
  107b00:	c3                   	ret
  107b01:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  107b08:	00 
  107b09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00107b10 <thread_spawn>:
 * Allocates a new child thread context, sets the state of the new child thread
 * to ready, and pushes it to the ready queue.
 * It returns the child thread id.
 */
unsigned int thread_spawn(void *entry, unsigned int id, unsigned int quota)
{
  107b10:	57                   	push   %edi
  107b11:	56                   	push   %esi
  107b12:	53                   	push   %ebx
  107b13:	e8 8a 88 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107b18:	81 c3 dc f4 00 00    	add    $0xf4dc,%ebx
    unsigned int pid;

    spinlock_acquire(&sched_lk);
  107b1e:	83 ec 0c             	sub    $0xc,%esp
  107b21:	8d bb ec 5e d1 00    	lea    0xd15eec(%ebx),%edi
  107b27:	57                   	push   %edi
  107b28:	e8 23 e4 ff ff       	call   105f50 <spinlock_acquire>

    pid = kctx_new(entry, id, quota);
  107b2d:	83 c4 0c             	add    $0xc,%esp
  107b30:	ff 74 24 1c          	push   0x1c(%esp)
  107b34:	ff 74 24 1c          	push   0x1c(%esp)
  107b38:	ff 74 24 1c          	push   0x1c(%esp)
  107b3c:	e8 df f8 ff ff       	call   107420 <kctx_new>
    if (pid != NUM_IDS) {
  107b41:	83 c4 10             	add    $0x10,%esp
    pid = kctx_new(entry, id, quota);
  107b44:	89 c6                	mov    %eax,%esi
    if (pid != NUM_IDS) {
  107b46:	83 f8 40             	cmp    $0x40,%eax
  107b49:	74 18                	je     107b63 <thread_spawn+0x53>
        tcb_set_state(pid, TSTATE_READY);
  107b4b:	83 ec 08             	sub    $0x8,%esp
  107b4e:	6a 00                	push   $0x0
  107b50:	50                   	push   %eax
  107b51:	e8 7a f9 ff ff       	call   1074d0 <tcb_set_state>
        tqueue_enqueue(NUM_IDS, pid);
  107b56:	58                   	pop    %eax
  107b57:	5a                   	pop    %edx
  107b58:	56                   	push   %esi
  107b59:	6a 40                	push   $0x40
  107b5b:	e8 b0 fc ff ff       	call   107810 <tqueue_enqueue>
  107b60:	83 c4 10             	add    $0x10,%esp
    }

    spinlock_release(&sched_lk);
  107b63:	83 ec 0c             	sub    $0xc,%esp
  107b66:	57                   	push   %edi
  107b67:	e8 64 e4 ff ff       	call   105fd0 <spinlock_release>

    return pid;
  107b6c:	83 c4 10             	add    $0x10,%esp
}
  107b6f:	89 f0                	mov    %esi,%eax
  107b71:	5b                   	pop    %ebx
  107b72:	5e                   	pop    %esi
  107b73:	5f                   	pop    %edi
  107b74:	c3                   	ret
  107b75:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  107b7c:	00 
  107b7d:	8d 76 00             	lea    0x0(%esi),%esi

00107b80 <thread_yield>:
 * current thread id, and switch to the new kernel context.
 * Hint: If you are the only thread that is ready to run,
 * do you need to switch to yourself?
 */
void thread_yield(void)
{
  107b80:	55                   	push   %ebp
  107b81:	57                   	push   %edi
  107b82:	56                   	push   %esi
  107b83:	53                   	push   %ebx
  107b84:	e8 19 88 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107b89:	81 c3 6b f4 00 00    	add    $0xf46b,%ebx
  107b8f:	83 ec 18             	sub    $0x18,%esp
    unsigned int old_cur_pid;
    unsigned int new_cur_pid;

    spinlock_acquire(&sched_lk);
  107b92:	8d ab ec 5e d1 00    	lea    0xd15eec(%ebx),%ebp
  107b98:	55                   	push   %ebp
  107b99:	e8 b2 e3 ff ff       	call   105f50 <spinlock_acquire>

    old_cur_pid = get_curid();
  107b9e:	e8 7d fe ff ff       	call   107a20 <get_curid>
    tcb_set_state(old_cur_pid, TSTATE_READY);
  107ba3:	59                   	pop    %ecx
  107ba4:	5f                   	pop    %edi
  107ba5:	6a 00                	push   $0x0
  107ba7:	50                   	push   %eax
    old_cur_pid = get_curid();
  107ba8:	89 c6                	mov    %eax,%esi
    tcb_set_state(old_cur_pid, TSTATE_READY);
  107baa:	e8 21 f9 ff ff       	call   1074d0 <tcb_set_state>
    tqueue_enqueue(NUM_IDS, old_cur_pid);
  107baf:	58                   	pop    %eax
  107bb0:	5a                   	pop    %edx
  107bb1:	56                   	push   %esi
  107bb2:	6a 40                	push   $0x40
  107bb4:	e8 57 fc ff ff       	call   107810 <tqueue_enqueue>

    new_cur_pid = tqueue_dequeue(NUM_IDS);
  107bb9:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  107bc0:	e8 cb fc ff ff       	call   107890 <tqueue_dequeue>
    tcb_set_state(new_cur_pid, TSTATE_RUN);
  107bc5:	59                   	pop    %ecx
  107bc6:	5a                   	pop    %edx
  107bc7:	6a 01                	push   $0x1
  107bc9:	50                   	push   %eax
    new_cur_pid = tqueue_dequeue(NUM_IDS);
  107bca:	89 c7                	mov    %eax,%edi
    tcb_set_state(new_cur_pid, TSTATE_RUN);
  107bcc:	e8 ff f8 ff ff       	call   1074d0 <tcb_set_state>
    set_curid(new_cur_pid);
  107bd1:	89 3c 24             	mov    %edi,(%esp)
  107bd4:	e8 67 fe ff ff       	call   107a40 <set_curid>

    if (old_cur_pid != new_cur_pid) {
  107bd9:	83 c4 10             	add    $0x10,%esp
  107bdc:	39 fe                	cmp    %edi,%esi
  107bde:	74 20                	je     107c00 <thread_yield+0x80>
        spinlock_release(&sched_lk);
  107be0:	83 ec 0c             	sub    $0xc,%esp
  107be3:	55                   	push   %ebp
  107be4:	e8 e7 e3 ff ff       	call   105fd0 <spinlock_release>
        kctx_switch(old_cur_pid, new_cur_pid);
  107be9:	58                   	pop    %eax
  107bea:	5a                   	pop    %edx
  107beb:	57                   	push   %edi
  107bec:	56                   	push   %esi
  107bed:	e8 be f7 ff ff       	call   1073b0 <kctx_switch>
  107bf2:	83 c4 10             	add    $0x10,%esp
    }
    else {
        spinlock_release(&sched_lk);
    }
}
  107bf5:	83 c4 0c             	add    $0xc,%esp
  107bf8:	5b                   	pop    %ebx
  107bf9:	5e                   	pop    %esi
  107bfa:	5f                   	pop    %edi
  107bfb:	5d                   	pop    %ebp
  107bfc:	c3                   	ret
  107bfd:	8d 76 00             	lea    0x0(%esi),%esi
        spinlock_release(&sched_lk);
  107c00:	83 ec 0c             	sub    $0xc,%esp
  107c03:	55                   	push   %ebp
  107c04:	e8 c7 e3 ff ff       	call   105fd0 <spinlock_release>
  107c09:	83 c4 10             	add    $0x10,%esp
}
  107c0c:	83 c4 0c             	add    $0xc,%esp
  107c0f:	5b                   	pop    %ebx
  107c10:	5e                   	pop    %esi
  107c11:	5f                   	pop    %edi
  107c12:	5d                   	pop    %ebp
  107c13:	c3                   	ret
  107c14:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  107c1b:	00 
  107c1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00107c20 <sched_update>:

void sched_update(void)
{
  107c20:	57                   	push   %edi
  107c21:	56                   	push   %esi
  107c22:	53                   	push   %ebx
  107c23:	e8 7a 87 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107c28:	81 c3 cc f3 00 00    	add    $0xf3cc,%ebx
    spinlock_acquire(&sched_lk);
  107c2e:	83 ec 0c             	sub    $0xc,%esp
  107c31:	8d bb ec 5e d1 00    	lea    0xd15eec(%ebx),%edi
    sched_ticks[get_pcpu_idx()] += 1000 / LAPIC_TIMER_INTR_FREQ;
  107c37:	8d b3 cc 5e d1 00    	lea    0xd15ecc(%ebx),%esi
    spinlock_acquire(&sched_lk);
  107c3d:	57                   	push   %edi
  107c3e:	e8 0d e3 ff ff       	call   105f50 <spinlock_acquire>
    sched_ticks[get_pcpu_idx()] += 1000 / LAPIC_TIMER_INTR_FREQ;
  107c43:	e8 18 e6 ff ff       	call   106260 <get_pcpu_idx>
  107c48:	83 04 86 01          	addl   $0x1,(%esi,%eax,4)
    if (sched_ticks[get_pcpu_idx()] >= SCHED_SLICE) {
  107c4c:	e8 0f e6 ff ff       	call   106260 <get_pcpu_idx>
  107c51:	83 c4 10             	add    $0x10,%esp
  107c54:	83 3c 86 04          	cmpl   $0x4,(%esi,%eax,4)
  107c58:	76 26                	jbe    107c80 <sched_update+0x60>
        sched_ticks[get_pcpu_idx()] = 0;
  107c5a:	e8 01 e6 ff ff       	call   106260 <get_pcpu_idx>
        spinlock_release(&sched_lk);
  107c5f:	83 ec 0c             	sub    $0xc,%esp
        sched_ticks[get_pcpu_idx()] = 0;
  107c62:	c7 04 86 00 00 00 00 	movl   $0x0,(%esi,%eax,4)
        spinlock_release(&sched_lk);
  107c69:	57                   	push   %edi
  107c6a:	e8 61 e3 ff ff       	call   105fd0 <spinlock_release>
        thread_yield();
  107c6f:	83 c4 10             	add    $0x10,%esp
    }
    else {
        spinlock_release(&sched_lk);
    }
}
  107c72:	5b                   	pop    %ebx
  107c73:	5e                   	pop    %esi
  107c74:	5f                   	pop    %edi
        thread_yield();
  107c75:	e9 06 ff ff ff       	jmp    107b80 <thread_yield>
  107c7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        spinlock_release(&sched_lk);
  107c80:	83 ec 0c             	sub    $0xc,%esp
  107c83:	57                   	push   %edi
  107c84:	e8 47 e3 ff ff       	call   105fd0 <spinlock_release>
  107c89:	83 c4 10             	add    $0x10,%esp
}
  107c8c:	5b                   	pop    %ebx
  107c8d:	5e                   	pop    %esi
  107c8e:	5f                   	pop    %edi
  107c8f:	c3                   	ret

00107c90 <thread_sleep>:
/**
 * Atomically release lock and sleep on chan.
 * Reacquires lock when awakened.
 */
void thread_sleep(void *chan, spinlock_t *lk)
{
  107c90:	55                   	push   %ebp
  107c91:	57                   	push   %edi
  107c92:	56                   	push   %esi
  107c93:	53                   	push   %ebx
  107c94:	e8 09 87 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107c99:	81 c3 5b f3 00 00    	add    $0xf35b,%ebx
  107c9f:	83 ec 0c             	sub    $0xc,%esp
	// KERN_DEBUG("Process: %d, CALLING thread_sleep on chan %p\n", get_curid(), chan);
    // TODO: your local variables here.
    unsigned int old_cur_pid;
    unsigned int new_cur_pid;

    if (lk == 0)
  107ca2:	8b 44 24 24          	mov    0x24(%esp),%eax
  107ca6:	85 c0                	test   %eax,%eax
  107ca8:	0f 84 ca 00 00 00    	je     107d78 <thread_sleep+0xe8>

    // Must acquire sched_lk in order to change the current thread's state and
    // then switch. Once we hold sched_lk, we can be guaranteed that we won't
    // miss any wakeup (wakeup runs with sched_lk locked), so it's okay to
    // release lock.
    spinlock_acquire(&sched_lk);
  107cae:	83 ec 0c             	sub    $0xc,%esp
  107cb1:	8d ab ec 5e d1 00    	lea    0xd15eec(%ebx),%ebp
  107cb7:	55                   	push   %ebp
  107cb8:	e8 93 e2 ff ff       	call   105f50 <spinlock_acquire>
    spinlock_release(lk);
  107cbd:	58                   	pop    %eax
  107cbe:	ff 74 24 30          	push   0x30(%esp)
  107cc2:	e8 09 e3 ff ff       	call   105fd0 <spinlock_release>

    // Go to sleep.
    old_cur_pid = get_curid();
  107cc7:	e8 54 fd ff ff       	call   107a20 <get_curid>
    new_cur_pid = tqueue_dequeue(NUM_IDS);
  107ccc:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
    old_cur_pid = get_curid();
  107cd3:	89 c6                	mov    %eax,%esi
    new_cur_pid = tqueue_dequeue(NUM_IDS);
  107cd5:	e8 b6 fb ff ff       	call   107890 <tqueue_dequeue>
    KERN_ASSERT(new_cur_pid != NUM_IDS);
  107cda:	83 c4 10             	add    $0x10,%esp
    new_cur_pid = tqueue_dequeue(NUM_IDS);
  107cdd:	89 c7                	mov    %eax,%edi
    KERN_ASSERT(new_cur_pid != NUM_IDS);
  107cdf:	83 f8 40             	cmp    $0x40,%eax
  107ce2:	74 6c                	je     107d50 <thread_sleep+0xc0>
    tcb_set_chan(old_cur_pid, chan);
  107ce4:	83 ec 08             	sub    $0x8,%esp
  107ce7:	ff 74 24 28          	push   0x28(%esp)
  107ceb:	56                   	push   %esi
  107cec:	e8 4f f9 ff ff       	call   107640 <tcb_set_chan>
    tcb_set_state(old_cur_pid, TSTATE_SLEEP);
  107cf1:	58                   	pop    %eax
  107cf2:	5a                   	pop    %edx
  107cf3:	6a 02                	push   $0x2
  107cf5:	56                   	push   %esi
  107cf6:	e8 d5 f7 ff ff       	call   1074d0 <tcb_set_state>
    tcb_set_state(new_cur_pid, TSTATE_RUN);
  107cfb:	59                   	pop    %ecx
  107cfc:	58                   	pop    %eax
  107cfd:	6a 01                	push   $0x1
  107cff:	57                   	push   %edi
  107d00:	e8 cb f7 ff ff       	call   1074d0 <tcb_set_state>
    set_curid(new_cur_pid);
  107d05:	89 3c 24             	mov    %edi,(%esp)
  107d08:	e8 33 fd ff ff       	call   107a40 <set_curid>

    // Context switch.
    spinlock_release(&sched_lk);
  107d0d:	89 2c 24             	mov    %ebp,(%esp)
  107d10:	e8 bb e2 ff ff       	call   105fd0 <spinlock_release>
    kctx_switch(old_cur_pid, new_cur_pid);
  107d15:	58                   	pop    %eax
  107d16:	5a                   	pop    %edx
  107d17:	57                   	push   %edi
  107d18:	56                   	push   %esi
  107d19:	e8 92 f6 ff ff       	call   1073b0 <kctx_switch>
    spinlock_acquire(&sched_lk);
  107d1e:	89 2c 24             	mov    %ebp,(%esp)
  107d21:	e8 2a e2 ff ff       	call   105f50 <spinlock_acquire>

    // Tidy up.
    tcb_set_chan(old_cur_pid, NULL);
  107d26:	59                   	pop    %ecx
  107d27:	5f                   	pop    %edi
  107d28:	6a 00                	push   $0x0
  107d2a:	56                   	push   %esi
  107d2b:	e8 10 f9 ff ff       	call   107640 <tcb_set_chan>

    // Reacquire original lock.
    spinlock_acquire(lk);
  107d30:	58                   	pop    %eax
  107d31:	ff 74 24 30          	push   0x30(%esp)
  107d35:	e8 16 e2 ff ff       	call   105f50 <spinlock_acquire>
    spinlock_release(&sched_lk);
  107d3a:	89 2c 24             	mov    %ebp,(%esp)
  107d3d:	e8 8e e2 ff ff       	call   105fd0 <spinlock_release>
}
  107d42:	83 c4 1c             	add    $0x1c,%esp
  107d45:	5b                   	pop    %ebx
  107d46:	5e                   	pop    %esi
  107d47:	5f                   	pop    %edi
  107d48:	5d                   	pop    %ebp
  107d49:	c3                   	ret
  107d4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    KERN_ASSERT(new_cur_pid != NUM_IDS);
  107d50:	8d 83 e8 65 ff ff    	lea    -0x9a18(%ebx),%eax
  107d56:	50                   	push   %eax
  107d57:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  107d5d:	50                   	push   %eax
  107d5e:	8d 83 ca 65 ff ff    	lea    -0x9a36(%ebx),%eax
  107d64:	6a 79                	push   $0x79
  107d66:	50                   	push   %eax
  107d67:	e8 84 ca ff ff       	call   1047f0 <debug_panic>
  107d6c:	83 c4 10             	add    $0x10,%esp
  107d6f:	e9 70 ff ff ff       	jmp    107ce4 <thread_sleep+0x54>
  107d74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        KERN_PANIC("sleep without lock");
  107d78:	83 ec 04             	sub    $0x4,%esp
  107d7b:	8d 83 b7 65 ff ff    	lea    -0x9a49(%ebx),%eax
  107d81:	50                   	push   %eax
  107d82:	8d 83 ca 65 ff ff    	lea    -0x9a36(%ebx),%eax
  107d88:	6a 6d                	push   $0x6d
  107d8a:	50                   	push   %eax
  107d8b:	e8 60 ca ff ff       	call   1047f0 <debug_panic>
  107d90:	83 c4 10             	add    $0x10,%esp
  107d93:	e9 16 ff ff ff       	jmp    107cae <thread_sleep+0x1e>
  107d98:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  107d9f:	00 

00107da0 <thread_wakeup>:

/**
 * Wake up all processes sleeping on chan.
 */
void thread_wakeup(void *chan)
{
  107da0:	55                   	push   %ebp
  107da1:	57                   	push   %edi
  107da2:	56                   	push   %esi
    unsigned int pid;
    spinlock_acquire(&sched_lk);

    for (pid = 0; pid < NUM_IDS; pid++) {
  107da3:	31 f6                	xor    %esi,%esi
{
  107da5:	53                   	push   %ebx
  107da6:	e8 f7 85 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107dab:	81 c3 49 f2 00 00    	add    $0xf249,%ebx
  107db1:	83 ec 18             	sub    $0x18,%esp
  107db4:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    spinlock_acquire(&sched_lk);
  107db8:	8d ab ec 5e d1 00    	lea    0xd15eec(%ebx),%ebp
  107dbe:	55                   	push   %ebp
  107dbf:	e8 8c e1 ff ff       	call   105f50 <spinlock_acquire>
  107dc4:	83 c4 10             	add    $0x10,%esp
  107dc7:	eb 0f                	jmp    107dd8 <thread_wakeup+0x38>
  107dc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    for (pid = 0; pid < NUM_IDS; pid++) {
  107dd0:	83 c6 01             	add    $0x1,%esi
  107dd3:	83 fe 40             	cmp    $0x40,%esi
  107dd6:	74 30                	je     107e08 <thread_wakeup+0x68>
        if (chan == tcb_get_chan(pid)) {
  107dd8:	83 ec 0c             	sub    $0xc,%esp
  107ddb:	56                   	push   %esi
  107ddc:	e8 3f f8 ff ff       	call   107620 <tcb_get_chan>
  107de1:	83 c4 10             	add    $0x10,%esp
  107de4:	39 c7                	cmp    %eax,%edi
  107de6:	75 e8                	jne    107dd0 <thread_wakeup+0x30>
            // KERN_DEBUG("Process: %d, CALLING thread_wakeup on process %d from chan %p\n", get_curid(), pid, chan);
            tcb_set_state(pid, TSTATE_READY);
  107de8:	83 ec 08             	sub    $0x8,%esp
  107deb:	6a 00                	push   $0x0
  107ded:	56                   	push   %esi
  107dee:	e8 dd f6 ff ff       	call   1074d0 <tcb_set_state>
            tqueue_enqueue(NUM_IDS, pid);
  107df3:	58                   	pop    %eax
  107df4:	5a                   	pop    %edx
  107df5:	56                   	push   %esi
  107df6:	6a 40                	push   $0x40
    for (pid = 0; pid < NUM_IDS; pid++) {
  107df8:	83 c6 01             	add    $0x1,%esi
            tqueue_enqueue(NUM_IDS, pid);
  107dfb:	e8 10 fa ff ff       	call   107810 <tqueue_enqueue>
  107e00:	83 c4 10             	add    $0x10,%esp
    for (pid = 0; pid < NUM_IDS; pid++) {
  107e03:	83 fe 40             	cmp    $0x40,%esi
  107e06:	75 d0                	jne    107dd8 <thread_wakeup+0x38>
        }
    }

    spinlock_release(&sched_lk);
  107e08:	83 ec 0c             	sub    $0xc,%esp
  107e0b:	55                   	push   %ebp
  107e0c:	e8 bf e1 ff ff       	call   105fd0 <spinlock_release>
}
  107e11:	83 c4 1c             	add    $0x1c,%esp
  107e14:	5b                   	pop    %ebx
  107e15:	5e                   	pop    %esi
  107e16:	5f                   	pop    %edi
  107e17:	5d                   	pop    %ebp
  107e18:	c3                   	ret
  107e19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00107e20 <thread_suspend>:
 * Suspend the running of the current thread, switch to a new thread.
 * Note: the thread being suspended is assumed to be stored in a "sleeping queue" elsewhere
 * and thus is not stored in any queue explicitly within this implementation
*/
void thread_suspend(spinlock_t *lock)
{
  107e20:	55                   	push   %ebp
  107e21:	57                   	push   %edi
  107e22:	56                   	push   %esi
  107e23:	53                   	push   %ebx
  107e24:	e8 79 85 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107e29:	81 c3 cb f1 00 00    	add    $0xf1cb,%ebx
  107e2f:	83 ec 18             	sub    $0x18,%esp
	// implementation follows Scheduler::suspend() in OS book
	spinlock_acquire(&sched_lk);
  107e32:	8d ab ec 5e d1 00    	lea    0xd15eec(%ebx),%ebp
  107e38:	55                   	push   %ebp
  107e39:	e8 12 e1 ff ff       	call   105f50 <spinlock_acquire>
	spinlock_release(lock);
  107e3e:	59                   	pop    %ecx
  107e3f:	ff 74 24 2c          	push   0x2c(%esp)
  107e43:	e8 88 e1 ff ff       	call   105fd0 <spinlock_release>
	
	unsigned int cur_pid = get_curid(); 
  107e48:	e8 d3 fb ff ff       	call   107a20 <get_curid>
	tcb_set_state(cur_pid, TSTATE_SLEEP); // maybe add a new state called TSTATE_WAITING?
  107e4d:	5e                   	pop    %esi
  107e4e:	5a                   	pop    %edx
  107e4f:	6a 02                	push   $0x2
  107e51:	50                   	push   %eax
	unsigned int cur_pid = get_curid(); 
  107e52:	89 c7                	mov    %eax,%edi
	tcb_set_state(cur_pid, TSTATE_SLEEP); // maybe add a new state called TSTATE_WAITING?
  107e54:	e8 77 f6 ff ff       	call   1074d0 <tcb_set_state>

	unsigned int new_pid = tqueue_dequeue(NUM_IDS); // removed + get_pcpu_idx()
  107e59:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  107e60:	e8 2b fa ff ff       	call   107890 <tqueue_dequeue>
    KERN_ASSERT(new_pid != NUM_IDS);
  107e65:	83 c4 10             	add    $0x10,%esp
	unsigned int new_pid = tqueue_dequeue(NUM_IDS); // removed + get_pcpu_idx()
  107e68:	89 c6                	mov    %eax,%esi
    KERN_ASSERT(new_pid != NUM_IDS);
  107e6a:	83 f8 40             	cmp    $0x40,%eax
  107e6d:	74 59                	je     107ec8 <thread_suspend+0xa8>
	tcb_set_state(new_pid, TSTATE_RUN); 
  107e6f:	83 ec 08             	sub    $0x8,%esp
  107e72:	6a 01                	push   $0x1
  107e74:	56                   	push   %esi
  107e75:	e8 56 f6 ff ff       	call   1074d0 <tcb_set_state>
	set_curid(new_pid);
  107e7a:	89 34 24             	mov    %esi,(%esp)
  107e7d:	e8 be fb ff ff       	call   107a40 <set_curid>

    // TODO: acquire lock before releasing sched_lk?

	if (cur_pid != new_pid) {
  107e82:	83 c4 10             	add    $0x10,%esp
  107e85:	39 f7                	cmp    %esi,%edi
  107e87:	74 27                	je     107eb0 <thread_suspend+0x90>
		spinlock_release(&sched_lk);
  107e89:	83 ec 0c             	sub    $0xc,%esp
  107e8c:	55                   	push   %ebp
  107e8d:	e8 3e e1 ff ff       	call   105fd0 <spinlock_release>
		kctx_switch(cur_pid, new_pid); 
  107e92:	58                   	pop    %eax
  107e93:	5a                   	pop    %edx
  107e94:	56                   	push   %esi
  107e95:	57                   	push   %edi
  107e96:	e8 15 f5 ff ff       	call   1073b0 <kctx_switch>
  107e9b:	83 c4 10             	add    $0x10,%esp
		// note: the book implementation has the lock being released after the thread has switched
	} else {
		spinlock_release(&sched_lk);
	}
}
  107e9e:	83 c4 0c             	add    $0xc,%esp
  107ea1:	5b                   	pop    %ebx
  107ea2:	5e                   	pop    %esi
  107ea3:	5f                   	pop    %edi
  107ea4:	5d                   	pop    %ebp
  107ea5:	c3                   	ret
  107ea6:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  107ead:	00 
  107eae:	66 90                	xchg   %ax,%ax
		spinlock_release(&sched_lk);
  107eb0:	83 ec 0c             	sub    $0xc,%esp
  107eb3:	55                   	push   %ebp
  107eb4:	e8 17 e1 ff ff       	call   105fd0 <spinlock_release>
  107eb9:	83 c4 10             	add    $0x10,%esp
}
  107ebc:	83 c4 0c             	add    $0xc,%esp
  107ebf:	5b                   	pop    %ebx
  107ec0:	5e                   	pop    %esi
  107ec1:	5f                   	pop    %edi
  107ec2:	5d                   	pop    %ebp
  107ec3:	c3                   	ret
  107ec4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    KERN_ASSERT(new_pid != NUM_IDS);
  107ec8:	8d 83 ff 65 ff ff    	lea    -0x9a01(%ebx),%eax
  107ece:	50                   	push   %eax
  107ecf:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  107ed5:	50                   	push   %eax
  107ed6:	8d 83 ca 65 ff ff    	lea    -0x9a36(%ebx),%eax
  107edc:	68 af 00 00 00       	push   $0xaf
  107ee1:	50                   	push   %eax
  107ee2:	e8 09 c9 ff ff       	call   1047f0 <debug_panic>
  107ee7:	83 c4 10             	add    $0x10,%esp
  107eea:	eb 83                	jmp    107e6f <thread_suspend+0x4f>
  107eec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00107ef0 <thread_wake>:
 * Place the thread in the ready queue for its own CPU.
 * Note: this implementation might be risky? 
 * (threads on different CPUs can queue on each others' ready queues)
*/
void thread_wake(unsigned int id)
{
  107ef0:	57                   	push   %edi
  107ef1:	56                   	push   %esi
  107ef2:	53                   	push   %ebx
  107ef3:	8b 74 24 10          	mov    0x10(%esp),%esi
  107ef7:	e8 a6 84 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107efc:	81 c3 f8 f0 00 00    	add    $0xf0f8,%ebx
	// implementation follows Scheduler::makeReady() in OS book 
	unsigned int cpu_num = tcb_get_cpu(id);
  107f02:	83 ec 0c             	sub    $0xc,%esp
  107f05:	56                   	push   %esi
  107f06:	e8 e5 f5 ff ff       	call   1074f0 <tcb_get_cpu>
	spinlock_acquire(&sched_lk);
  107f0b:	8d bb ec 5e d1 00    	lea    0xd15eec(%ebx),%edi
  107f11:	89 3c 24             	mov    %edi,(%esp)
  107f14:	e8 37 e0 ff ff       	call   105f50 <spinlock_acquire>
	tcb_set_state(id, TSTATE_READY);
  107f19:	58                   	pop    %eax
  107f1a:	5a                   	pop    %edx
  107f1b:	6a 00                	push   $0x0
  107f1d:	56                   	push   %esi
  107f1e:	e8 ad f5 ff ff       	call   1074d0 <tcb_set_state>
	tqueue_enqueue(NUM_IDS, id); // removed NUM_IDS + cpu_num 
  107f23:	59                   	pop    %ecx
  107f24:	58                   	pop    %eax
  107f25:	56                   	push   %esi
  107f26:	6a 40                	push   $0x40
  107f28:	e8 e3 f8 ff ff       	call   107810 <tqueue_enqueue>
	spinlock_release(&sched_lk); 
  107f2d:	89 3c 24             	mov    %edi,(%esp)
  107f30:	e8 9b e0 ff ff       	call   105fd0 <spinlock_release>
  107f35:	83 c4 10             	add    $0x10,%esp
  107f38:	5b                   	pop    %ebx
  107f39:	5e                   	pop    %esi
  107f3a:	5f                   	pop    %edi
  107f3b:	c3                   	ret
  107f3c:	66 90                	xchg   %ax,%ax
  107f3e:	66 90                	xchg   %ax,%ax

00107f40 <proc_start_user>:
extern unsigned int last_active[NUM_CPUS];

void log_init();

void proc_start_user(void)
{
  107f40:	57                   	push   %edi
  107f41:	56                   	push   %esi
  107f42:	53                   	push   %ebx
  107f43:	e8 5a 84 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107f48:	81 c3 ac f0 00 00    	add    $0xf0ac,%ebx
    unsigned int cur_pid = get_curid();
  107f4e:	e8 cd fa ff ff       	call   107a20 <get_curid>
  107f53:	89 c6                	mov    %eax,%esi
    unsigned int cpu_idx = get_pcpu_idx();
  107f55:	e8 06 e3 ff ff       	call   106260 <get_pcpu_idx>
  107f5a:	89 c7                	mov    %eax,%edi

    static int started = FALSE;

    if (get_curid() != 1 && started == FALSE) {
  107f5c:	e8 bf fa ff ff       	call   107a20 <get_curid>
  107f61:	83 f8 01             	cmp    $0x1,%eax
  107f64:	74 0a                	je     107f70 <proc_start_user+0x30>
  107f66:	8b 83 0c 70 d1 00    	mov    0xd1700c(%ebx),%eax
  107f6c:	85 c0                	test   %eax,%eax
  107f6e:	74 38                	je     107fa8 <proc_start_user+0x68>
        started = TRUE;
        log_init();
    }

    kstack_switch(cur_pid);
  107f70:	83 ec 0c             	sub    $0xc,%esp
  107f73:	56                   	push   %esi
  107f74:	e8 b7 d0 ff ff       	call   105030 <kstack_switch>
    set_pdir_base(cur_pid);
  107f79:	89 34 24             	mov    %esi,(%esp)
  107f7c:	e8 0f ed ff ff       	call   106c90 <set_pdir_base>
    last_active[cpu_idx] = cur_pid;
  107f81:	c7 c0 20 e0 e6 00    	mov    $0xe6e020,%eax
  107f87:	89 34 b8             	mov    %esi,(%eax,%edi,4)

    trap_return((void *) &uctx_pool[cur_pid]);
  107f8a:	6b f6 44             	imul   $0x44,%esi,%esi
  107f8d:	81 c6 00 cf e2 00    	add    $0xe2cf00,%esi
  107f93:	89 34 24             	mov    %esi,(%esp)
  107f96:	e8 f5 a2 ff ff       	call   102290 <trap_return>
}
  107f9b:	83 c4 10             	add    $0x10,%esp
  107f9e:	5b                   	pop    %ebx
  107f9f:	5e                   	pop    %esi
  107fa0:	5f                   	pop    %edi
  107fa1:	c3                   	ret
  107fa2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        started = TRUE;
  107fa8:	c7 83 0c 70 d1 00 01 	movl   $0x1,0xd1700c(%ebx)
  107faf:	00 00 00 
        log_init();
  107fb2:	e8 c9 13 00 00       	call   109380 <log_init>
  107fb7:	eb b7                	jmp    107f70 <proc_start_user+0x30>
  107fb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00107fc0 <proc_create>:

unsigned int proc_create(void *elf_addr, unsigned int quota)
{
  107fc0:	57                   	push   %edi
  107fc1:	56                   	push   %esi
  107fc2:	53                   	push   %ebx
  107fc3:	e8 da 83 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  107fc8:	81 c3 2c f0 00 00    	add    $0xf02c,%ebx
    unsigned int pid, id;

    id = get_curid();
  107fce:	e8 4d fa ff ff       	call   107a20 <get_curid>
    pid = thread_spawn((void *) proc_start_user, id, quota);
  107fd3:	83 ec 04             	sub    $0x4,%esp
  107fd6:	ff 74 24 18          	push   0x18(%esp)
  107fda:	50                   	push   %eax
  107fdb:	8d 83 4c 0f ff ff    	lea    -0xf0b4(%ebx),%eax
  107fe1:	50                   	push   %eax
  107fe2:	e8 29 fb ff ff       	call   107b10 <thread_spawn>

    if (pid != NUM_IDS) {
  107fe7:	83 c4 10             	add    $0x10,%esp
    pid = thread_spawn((void *) proc_start_user, id, quota);
  107fea:	89 c6                	mov    %eax,%esi
    if (pid != NUM_IDS) {
  107fec:	83 f8 40             	cmp    $0x40,%eax
  107fef:	74 66                	je     108057 <proc_create+0x97>
        elf_load(elf_addr, pid);
  107ff1:	83 ec 08             	sub    $0x8,%esp

        uctx_pool[pid].es = CPU_GDT_UDATA | 3;
  107ff4:	6b fe 44             	imul   $0x44,%esi,%edi
        elf_load(elf_addr, pid);
  107ff7:	50                   	push   %eax
  107ff8:	ff 74 24 1c          	push   0x1c(%esp)
  107ffc:	e8 df db ff ff       	call   105be0 <elf_load>
        uctx_pool[pid].es = CPU_GDT_UDATA | 3;
  108001:	81 c7 00 cf e2 00    	add    $0xe2cf00,%edi
  108007:	b8 23 00 00 00       	mov    $0x23,%eax
        uctx_pool[pid].ds = CPU_GDT_UDATA | 3;
  10800c:	ba 23 00 00 00       	mov    $0x23,%edx
        uctx_pool[pid].es = CPU_GDT_UDATA | 3;
  108011:	66 89 47 20          	mov    %ax,0x20(%edi)
        uctx_pool[pid].cs = CPU_GDT_UCODE | 3;
  108015:	b9 1b 00 00 00       	mov    $0x1b,%ecx
        uctx_pool[pid].ss = CPU_GDT_UDATA | 3;
  10801a:	b8 23 00 00 00       	mov    $0x23,%eax
        uctx_pool[pid].ds = CPU_GDT_UDATA | 3;
  10801f:	66 89 57 24          	mov    %dx,0x24(%edi)
        uctx_pool[pid].cs = CPU_GDT_UCODE | 3;
  108023:	66 89 4f 34          	mov    %cx,0x34(%edi)
        uctx_pool[pid].ss = CPU_GDT_UDATA | 3;
  108027:	66 89 47 40          	mov    %ax,0x40(%edi)
        uctx_pool[pid].esp = VM_USERHI;
  10802b:	c7 47 3c 00 00 00 f0 	movl   $0xf0000000,0x3c(%edi)
        uctx_pool[pid].eflags = FL_IF;
  108032:	c7 47 38 00 02 00 00 	movl   $0x200,0x38(%edi)
        uctx_pool[pid].eip = elf_entry(elf_addr);
  108039:	58                   	pop    %eax
  10803a:	ff 74 24 1c          	push   0x1c(%esp)
  10803e:	e8 dd dd ff ff       	call   105e20 <elf_entry>
  108043:	89 47 30             	mov    %eax,0x30(%edi)

        seg_init_proc(get_pcpu_idx(), pid);
  108046:	e8 15 e2 ff ff       	call   106260 <get_pcpu_idx>
  10804b:	5a                   	pop    %edx
  10804c:	59                   	pop    %ecx
  10804d:	56                   	push   %esi
  10804e:	50                   	push   %eax
  10804f:	e8 0c d2 ff ff       	call   105260 <seg_init_proc>
  108054:	83 c4 10             	add    $0x10,%esp
    }

    return pid;
}
  108057:	89 f0                	mov    %esi,%eax
  108059:	5b                   	pop    %ebx
  10805a:	5e                   	pop    %esi
  10805b:	5f                   	pop    %edi
  10805c:	c3                   	ret
  10805d:	66 90                	xchg   %ax,%ax
  10805f:	90                   	nop

00108060 <syscall_get_arg1>:
 * Retrieves the system call arguments from uctx_pool that get
 * passed in from the current running process' system call.
 */
unsigned int syscall_get_arg1(tf_t *tf)
{
    return tf->regs.eax;
  108060:	8b 44 24 04          	mov    0x4(%esp),%eax
  108064:	8b 40 1c             	mov    0x1c(%eax),%eax
}
  108067:	c3                   	ret
  108068:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10806f:	00 

00108070 <syscall_get_arg2>:

unsigned int syscall_get_arg2(tf_t *tf)
{
    return tf->regs.ebx;
  108070:	8b 44 24 04          	mov    0x4(%esp),%eax
  108074:	8b 40 10             	mov    0x10(%eax),%eax
}
  108077:	c3                   	ret
  108078:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10807f:	00 

00108080 <syscall_get_arg3>:

unsigned int syscall_get_arg3(tf_t *tf)
{
    return tf->regs.ecx;
  108080:	8b 44 24 04          	mov    0x4(%esp),%eax
  108084:	8b 40 18             	mov    0x18(%eax),%eax
}
  108087:	c3                   	ret
  108088:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10808f:	00 

00108090 <syscall_get_arg4>:

unsigned int syscall_get_arg4(tf_t *tf)
{
    return tf->regs.edx;
  108090:	8b 44 24 04          	mov    0x4(%esp),%eax
  108094:	8b 40 14             	mov    0x14(%eax),%eax
}
  108097:	c3                   	ret
  108098:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10809f:	00 

001080a0 <syscall_get_arg5>:

unsigned int syscall_get_arg5(tf_t *tf)
{
    return tf->regs.esi;
  1080a0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1080a4:	8b 40 04             	mov    0x4(%eax),%eax
}
  1080a7:	c3                   	ret
  1080a8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1080af:	00 

001080b0 <syscall_get_arg6>:

unsigned int syscall_get_arg6(tf_t *tf)
{
    return tf->regs.edi;
  1080b0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1080b4:	8b 00                	mov    (%eax),%eax
}
  1080b6:	c3                   	ret
  1080b7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1080be:	00 
  1080bf:	90                   	nop

001080c0 <syscall_set_errno>:
 * Sets the error number in uctx_pool that gets passed
 * to the current running process when we return to it.
 */
void syscall_set_errno(tf_t *tf, unsigned int errno)
{
    tf->regs.eax = errno;
  1080c0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1080c4:	8b 54 24 08          	mov    0x8(%esp),%edx
  1080c8:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  1080cb:	c3                   	ret
  1080cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001080d0 <syscall_set_retval1>:
 * Sets the return values in uctx_pool that get passed
 * to the current running process when we return to it.
 */
void syscall_set_retval1(tf_t *tf, unsigned int retval)
{
    tf->regs.ebx = retval;
  1080d0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1080d4:	8b 54 24 08          	mov    0x8(%esp),%edx
  1080d8:	89 50 10             	mov    %edx,0x10(%eax)
}
  1080db:	c3                   	ret
  1080dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001080e0 <syscall_set_retval2>:

void syscall_set_retval2(tf_t *tf, unsigned int retval)
{
    tf->regs.ecx = retval;
  1080e0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1080e4:	8b 54 24 08          	mov    0x8(%esp),%edx
  1080e8:	89 50 18             	mov    %edx,0x18(%eax)
}
  1080eb:	c3                   	ret
  1080ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

001080f0 <syscall_set_retval3>:

void syscall_set_retval3(tf_t *tf, unsigned int retval)
{
    tf->regs.edx = retval;
  1080f0:	8b 44 24 04          	mov    0x4(%esp),%eax
  1080f4:	8b 54 24 08          	mov    0x8(%esp),%edx
  1080f8:	89 50 14             	mov    %edx,0x14(%eax)
}
  1080fb:	c3                   	ret
  1080fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00108100 <syscall_set_retval4>:

void syscall_set_retval4(tf_t *tf, unsigned int retval)
{
    tf->regs.esi = retval;
  108100:	8b 44 24 04          	mov    0x4(%esp),%eax
  108104:	8b 54 24 08          	mov    0x8(%esp),%edx
  108108:	89 50 04             	mov    %edx,0x4(%eax)
}
  10810b:	c3                   	ret
  10810c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00108110 <syscall_set_retval5>:

void syscall_set_retval5(tf_t *tf, unsigned int retval)
{
    tf->regs.edi = retval;
  108110:	8b 44 24 04          	mov    0x4(%esp),%eax
  108114:	8b 54 24 08          	mov    0x8(%esp),%edx
  108118:	89 10                	mov    %edx,(%eax)
}
  10811a:	c3                   	ret
  10811b:	66 90                	xchg   %ax,%ax
  10811d:	66 90                	xchg   %ax,%ax
  10811f:	90                   	nop

00108120 <sys_puts>:
/**
 * Copies a string from user into buffer and prints it to the screen.
 * This is called by the user level "printf" library as a system call.
 */
void sys_puts(tf_t *tf)
{
  108120:	55                   	push   %ebp
  108121:	57                   	push   %edi
  108122:	56                   	push   %esi
  108123:	53                   	push   %ebx
  108124:	e8 79 82 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108129:	81 c3 cb ee 00 00    	add    $0xeecb,%ebx
  10812f:	83 ec 2c             	sub    $0x2c,%esp
  108132:	8b 74 24 40          	mov    0x40(%esp),%esi
    unsigned int cur_pid;
    unsigned int str_uva, str_len;
    unsigned int remain, cur_pos, nbytes;

    cur_pid = get_curid();
  108136:	e8 e5 f8 ff ff       	call   107a20 <get_curid>
    str_uva = syscall_get_arg2(tf);
  10813b:	83 ec 0c             	sub    $0xc,%esp
    cur_pid = get_curid();
  10813e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    str_uva = syscall_get_arg2(tf);
  108142:	56                   	push   %esi
  108143:	e8 28 ff ff ff       	call   108070 <syscall_get_arg2>
    str_len = syscall_get_arg3(tf);
  108148:	89 34 24             	mov    %esi,(%esp)
    str_uva = syscall_get_arg2(tf);
  10814b:	89 c7                	mov    %eax,%edi
    str_len = syscall_get_arg3(tf);
  10814d:	e8 2e ff ff ff       	call   108080 <syscall_get_arg3>

    if (!(VM_USERLO <= str_uva && str_uva + str_len <= VM_USERHI)) {
  108152:	83 c4 10             	add    $0x10,%esp
  108155:	81 ff ff ff ff 3f    	cmp    $0x3fffffff,%edi
  10815b:	0f 86 d7 00 00 00    	jbe    108238 <sys_puts+0x118>
  108161:	8d 14 07             	lea    (%edi,%eax,1),%edx
  108164:	89 c5                	mov    %eax,%ebp
  108166:	81 fa 00 00 00 f0    	cmp    $0xf0000000,%edx
  10816c:	0f 87 c6 00 00 00    	ja     108238 <sys_puts+0x118>
    }

    remain = str_len;
    cur_pos = str_uva;

    while (remain) {
  108172:	85 c0                	test   %eax,%eax
  108174:	0f 84 a2 00 00 00    	je     10821c <sys_puts+0xfc>
        if (remain < PAGESIZE - 1)
            nbytes = remain;
        else
            nbytes = PAGESIZE - 1;

        if (pt_copyin(cur_pid, cur_pos, sys_buf[cur_pid], nbytes) != nbytes) {
  10817a:	8b 44 24 10          	mov    0x10(%esp),%eax
  10817e:	8d 8b 2c 70 d1 00    	lea    0xd1702c(%ebx),%ecx
            syscall_set_errno(tf, E_MEM);
            return;
        }

        sys_buf[cur_pid][nbytes] = '\0';
        KERN_INFO("%s", sys_buf[cur_pid]);
  108184:	89 74 24 40          	mov    %esi,0x40(%esp)
  108188:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
        if (pt_copyin(cur_pid, cur_pos, sys_buf[cur_pid], nbytes) != nbytes) {
  10818c:	c1 e0 0c             	shl    $0xc,%eax
  10818f:	89 44 24 14          	mov    %eax,0x14(%esp)
  108193:	01 c8                	add    %ecx,%eax
  108195:	89 44 24 08          	mov    %eax,0x8(%esp)
        KERN_INFO("%s", sys_buf[cur_pid]);
  108199:	8d 83 1a 60 ff ff    	lea    -0x9fe6(%ebx),%eax
  10819f:	89 44 24 18          	mov    %eax,0x18(%esp)
  1081a3:	eb 33                	jmp    1081d8 <sys_puts+0xb8>
  1081a5:	8d 76 00             	lea    0x0(%esi),%esi
        sys_buf[cur_pid][nbytes] = '\0';
  1081a8:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  1081ac:	89 44 24 0c          	mov    %eax,0xc(%esp)
        KERN_INFO("%s", sys_buf[cur_pid]);
  1081b0:	83 ec 08             	sub    $0x8,%esp
        sys_buf[cur_pid][nbytes] = '\0';
  1081b3:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  1081b6:	8b 44 24 24          	mov    0x24(%esp),%eax
  1081ba:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)
        KERN_INFO("%s", sys_buf[cur_pid]);
  1081be:	ff 74 24 10          	push   0x10(%esp)
  1081c2:	ff 74 24 24          	push   0x24(%esp)
  1081c6:	e8 85 c5 ff ff       	call   104750 <debug_info>

        remain -= nbytes;
        cur_pos += nbytes;
  1081cb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    while (remain) {
  1081cf:	83 c4 10             	add    $0x10,%esp
        cur_pos += nbytes;
  1081d2:	01 c7                	add    %eax,%edi
    while (remain) {
  1081d4:	29 c5                	sub    %eax,%ebp
  1081d6:	74 40                	je     108218 <sys_puts+0xf8>
        if (remain < PAGESIZE - 1)
  1081d8:	ba ff 0f 00 00       	mov    $0xfff,%edx
  1081dd:	39 d5                	cmp    %edx,%ebp
  1081df:	89 d6                	mov    %edx,%esi
  1081e1:	0f 46 f5             	cmovbe %ebp,%esi
        if (pt_copyin(cur_pid, cur_pos, sys_buf[cur_pid], nbytes) != nbytes) {
  1081e4:	56                   	push   %esi
  1081e5:	ff 74 24 0c          	push   0xc(%esp)
  1081e9:	57                   	push   %edi
  1081ea:	ff 74 24 1c          	push   0x1c(%esp)
  1081ee:	e8 3d d7 ff ff       	call   105930 <pt_copyin>
  1081f3:	83 c4 10             	add    $0x10,%esp
  1081f6:	39 f0                	cmp    %esi,%eax
  1081f8:	74 ae                	je     1081a8 <sys_puts+0x88>
            syscall_set_errno(tf, E_MEM);
  1081fa:	8b 74 24 40          	mov    0x40(%esp),%esi
  1081fe:	83 ec 08             	sub    $0x8,%esp
  108201:	6a 01                	push   $0x1
  108203:	56                   	push   %esi
  108204:	e8 b7 fe ff ff       	call   1080c0 <syscall_set_errno>
            return;
  108209:	83 c4 10             	add    $0x10,%esp
    }

    syscall_set_errno(tf, E_SUCC);
}
  10820c:	83 c4 2c             	add    $0x2c,%esp
  10820f:	5b                   	pop    %ebx
  108210:	5e                   	pop    %esi
  108211:	5f                   	pop    %edi
  108212:	5d                   	pop    %ebp
  108213:	c3                   	ret
  108214:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  108218:	8b 74 24 40          	mov    0x40(%esp),%esi
    syscall_set_errno(tf, E_SUCC);
  10821c:	83 ec 08             	sub    $0x8,%esp
  10821f:	6a 00                	push   $0x0
  108221:	56                   	push   %esi
  108222:	e8 99 fe ff ff       	call   1080c0 <syscall_set_errno>
  108227:	83 c4 10             	add    $0x10,%esp
}
  10822a:	83 c4 2c             	add    $0x2c,%esp
  10822d:	5b                   	pop    %ebx
  10822e:	5e                   	pop    %esi
  10822f:	5f                   	pop    %edi
  108230:	5d                   	pop    %ebp
  108231:	c3                   	ret
  108232:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        syscall_set_errno(tf, E_INVAL_ADDR);
  108238:	83 ec 08             	sub    $0x8,%esp
  10823b:	6a 04                	push   $0x4
  10823d:	56                   	push   %esi
  10823e:	e8 7d fe ff ff       	call   1080c0 <syscall_set_errno>
        return;
  108243:	83 c4 10             	add    $0x10,%esp
}
  108246:	83 c4 2c             	add    $0x2c,%esp
  108249:	5b                   	pop    %ebx
  10824a:	5e                   	pop    %esi
  10824b:	5f                   	pop    %edi
  10824c:	5d                   	pop    %ebp
  10824d:	c3                   	ret
  10824e:	66 90                	xchg   %ax,%ax

00108250 <sys_readline>:

void sys_readline(tf_t *tf)
{
  108250:	55                   	push   %ebp
  108251:	57                   	push   %edi
  108252:	56                   	push   %esi
  108253:	53                   	push   %ebx
  108254:	e8 49 81 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108259:	81 c3 9b ed 00 00    	add    $0xed9b,%ebx
  10825f:	83 ec 1c             	sub    $0x1c,%esp
  108262:	8b 7c 24 30          	mov    0x30(%esp),%edi
    char *buf;
    int read;
    unsigned int curid = get_curid();
  108266:	e8 b5 f7 ff ff       	call   107a20 <get_curid>
    uintptr_t line = syscall_get_arg2(tf);
  10826b:	83 ec 0c             	sub    $0xc,%esp
  10826e:	57                   	push   %edi
    unsigned int curid = get_curid();
  10826f:	89 c5                	mov    %eax,%ebp
    uintptr_t line = syscall_get_arg2(tf);
  108271:	e8 fa fd ff ff       	call   108070 <syscall_get_arg2>
    uintptr_t len = syscall_get_arg3(tf);
  108276:	89 3c 24             	mov    %edi,(%esp)
    uintptr_t line = syscall_get_arg2(tf);
  108279:	89 c6                	mov    %eax,%esi
    uintptr_t len = syscall_get_arg3(tf);
  10827b:	e8 00 fe ff ff       	call   108080 <syscall_get_arg3>

    if (!(VM_USERLO <= line && line + len <= VM_USERHI)
  108280:	83 c4 10             	add    $0x10,%esp
  108283:	81 fe ff ff ff 3f    	cmp    $0x3fffffff,%esi
  108289:	76 14                	jbe    10829f <sys_readline+0x4f>
  10828b:	89 c2                	mov    %eax,%edx
  10828d:	8d 04 06             	lea    (%esi,%eax,1),%eax
        || len >= BUFLEN) {
  108290:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  108295:	77 08                	ja     10829f <sys_readline+0x4f>
  108297:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
  10829d:	76 19                	jbe    1082b8 <sys_readline+0x68>
        syscall_set_errno(tf, E_INVAL_ADDR);
  10829f:	83 ec 08             	sub    $0x8,%esp
  1082a2:	6a 04                	push   $0x4
  1082a4:	57                   	push   %edi
  1082a5:	e8 16 fe ff ff       	call   1080c0 <syscall_set_errno>
        return;
  1082aa:	83 c4 10             	add    $0x10,%esp
        return;
    }

    syscall_set_errno(tf, E_SUCC);
    syscall_set_retval1(tf, read);
}
  1082ad:	83 c4 1c             	add    $0x1c,%esp
  1082b0:	5b                   	pop    %ebx
  1082b1:	5e                   	pop    %esi
  1082b2:	5f                   	pop    %edi
  1082b3:	5d                   	pop    %ebp
  1082b4:	c3                   	ret
  1082b5:	8d 76 00             	lea    0x0(%esi),%esi
  1082b8:	89 54 24 0c          	mov    %edx,0xc(%esp)
    buf = readline("$> ");
  1082bc:	8d 83 df 64 ff ff    	lea    -0x9b21(%ebx),%eax
  1082c2:	83 ec 0c             	sub    $0xc,%esp
  1082c5:	50                   	push   %eax
  1082c6:	e8 c5 82 ff ff       	call   100590 <readline>
  1082cb:	89 c1                	mov    %eax,%ecx
    len = min(strnlen(buf, BUFLEN - 1), len);
  1082cd:	58                   	pop    %eax
  1082ce:	5a                   	pop    %edx
  1082cf:	68 ff 03 00 00       	push   $0x3ff
  1082d4:	51                   	push   %ecx
  1082d5:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  1082d9:	e8 62 c2 ff ff       	call   104540 <strnlen>
  1082de:	59                   	pop    %ecx
  1082df:	5a                   	pop    %edx
  1082e0:	8b 54 24 14          	mov    0x14(%esp),%edx
  1082e4:	52                   	push   %edx
  1082e5:	50                   	push   %eax
  1082e6:	e8 85 d0 ff ff       	call   105370 <min>
    buf[len] = '\0';
  1082eb:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    len = min(strnlen(buf, BUFLEN - 1), len);
  1082ef:	89 c2                	mov    %eax,%edx
    buf[len] = '\0';
  1082f1:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
    read = pt_copyout(buf, curid, line, len + 1);
  1082f5:	8d 40 01             	lea    0x1(%eax),%eax
  1082f8:	89 54 24 18          	mov    %edx,0x18(%esp)
  1082fc:	50                   	push   %eax
  1082fd:	56                   	push   %esi
  1082fe:	55                   	push   %ebp
  1082ff:	51                   	push   %ecx
  108300:	e8 1b d7 ff ff       	call   105a20 <pt_copyout>
    if (len > 0 && read == 0) {
  108305:	8b 54 24 28          	mov    0x28(%esp),%edx
  108309:	83 c4 20             	add    $0x20,%esp
    read = pt_copyout(buf, curid, line, len + 1);
  10830c:	89 c6                	mov    %eax,%esi
    if (len > 0 && read == 0) {
  10830e:	85 d2                	test   %edx,%edx
  108310:	74 1e                	je     108330 <sys_readline+0xe0>
  108312:	85 c0                	test   %eax,%eax
  108314:	75 1a                	jne    108330 <sys_readline+0xe0>
        syscall_set_errno(tf, E_MEM);
  108316:	83 ec 08             	sub    $0x8,%esp
  108319:	6a 01                	push   $0x1
  10831b:	57                   	push   %edi
  10831c:	e8 9f fd ff ff       	call   1080c0 <syscall_set_errno>
        return;
  108321:	83 c4 10             	add    $0x10,%esp
  108324:	eb 87                	jmp    1082ad <sys_readline+0x5d>
  108326:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10832d:	00 
  10832e:	66 90                	xchg   %ax,%ax
    syscall_set_errno(tf, E_SUCC);
  108330:	83 ec 08             	sub    $0x8,%esp
  108333:	6a 00                	push   $0x0
  108335:	57                   	push   %edi
  108336:	e8 85 fd ff ff       	call   1080c0 <syscall_set_errno>
    syscall_set_retval1(tf, read);
  10833b:	58                   	pop    %eax
  10833c:	5a                   	pop    %edx
  10833d:	56                   	push   %esi
  10833e:	57                   	push   %edi
  10833f:	e8 8c fd ff ff       	call   1080d0 <syscall_set_retval1>
  108344:	83 c4 10             	add    $0x10,%esp
}
  108347:	83 c4 1c             	add    $0x1c,%esp
  10834a:	5b                   	pop    %ebx
  10834b:	5e                   	pop    %esi
  10834c:	5f                   	pop    %edi
  10834d:	5d                   	pop    %ebp
  10834e:	c3                   	ret
  10834f:	90                   	nop

00108350 <sys_spawn>:
 * NUM_IDS with the error number E_INVAL_PID. The same error case apply
 * when the proc_create fails.
 * Otherwise, you should mark it as successful, and return the new child process id.
 */
void sys_spawn(tf_t *tf)
{
  108350:	55                   	push   %ebp
  108351:	57                   	push   %edi
  108352:	56                   	push   %esi
  108353:	53                   	push   %ebx
  108354:	e8 49 80 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108359:	81 c3 9b ec 00 00    	add    $0xec9b,%ebx
  10835f:	83 ec 1c             	sub    $0x1c,%esp
  108362:	8b 74 24 30          	mov    0x30(%esp),%esi
    unsigned int new_pid;
    unsigned int elf_id, quota;
    void *elf_addr;
    unsigned int curid = get_curid();
  108366:	e8 b5 f6 ff ff       	call   107a20 <get_curid>

    elf_id = syscall_get_arg2(tf);
  10836b:	83 ec 0c             	sub    $0xc,%esp
  10836e:	56                   	push   %esi
    unsigned int curid = get_curid();
  10836f:	89 c5                	mov    %eax,%ebp
    elf_id = syscall_get_arg2(tf);
  108371:	e8 fa fc ff ff       	call   108070 <syscall_get_arg2>
    quota = syscall_get_arg3(tf);
  108376:	89 34 24             	mov    %esi,(%esp)
    elf_id = syscall_get_arg2(tf);
  108379:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    quota = syscall_get_arg3(tf);
  10837d:	e8 fe fc ff ff       	call   108080 <syscall_get_arg3>

    if (!container_can_consume(curid, quota)) {
  108382:	5a                   	pop    %edx
  108383:	59                   	pop    %ecx
  108384:	50                   	push   %eax
    quota = syscall_get_arg3(tf);
  108385:	89 c7                	mov    %eax,%edi
    if (!container_can_consume(curid, quota)) {
  108387:	55                   	push   %ebp
  108388:	e8 43 e7 ff ff       	call   106ad0 <container_can_consume>
  10838d:	83 c4 10             	add    $0x10,%esp
  108390:	85 c0                	test   %eax,%eax
  108392:	74 5c                	je     1083f0 <sys_spawn+0xa0>
        syscall_set_errno(tf, E_EXCEEDS_QUOTA);
        syscall_set_retval1(tf, NUM_IDS);
        return;
    }
    else if (NUM_IDS < curid * MAX_CHILDREN + 1 + MAX_CHILDREN) {
  108394:	8d 44 6d 04          	lea    0x4(%ebp,%ebp,2),%eax
  108398:	83 f8 40             	cmp    $0x40,%eax
  10839b:	77 2b                	ja     1083c8 <sys_spawn+0x78>
        syscall_set_errno(tf, E_MAX_NUM_CHILDEN_REACHED);
        syscall_set_retval1(tf, NUM_IDS);
        return;
    }
    else if (container_get_nchildren(curid) == MAX_CHILDREN) {
  10839d:	83 ec 0c             	sub    $0xc,%esp
  1083a0:	55                   	push   %ebp
  1083a1:	e8 ca e6 ff ff       	call   106a70 <container_get_nchildren>
  1083a6:	83 c4 10             	add    $0x10,%esp
  1083a9:	83 f8 03             	cmp    $0x3,%eax
  1083ac:	74 52                	je     108400 <sys_spawn+0xb0>
        syscall_set_errno(tf, E_INVAL_CHILD_ID);
        syscall_set_retval1(tf, NUM_IDS);
        return;
    }

    switch (elf_id) {
  1083ae:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1083b2:	83 f8 0a             	cmp    $0xa,%eax
  1083b5:	77 59                	ja     108410 <.L45>
  1083b7:	8b 84 83 5c 7f ff ff 	mov    -0x80a4(%ebx,%eax,4),%eax
  1083be:	01 d8                	add    %ebx,%eax
  1083c0:	ff e0                	jmp    *%eax
  1083c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        syscall_set_errno(tf, E_MAX_NUM_CHILDEN_REACHED);
  1083c8:	83 ec 08             	sub    $0x8,%esp
  1083cb:	6a 18                	push   $0x18
    }

    new_pid = proc_create(elf_addr, quota);

    if (new_pid == NUM_IDS) {
        syscall_set_errno(tf, E_INVAL_PID);
  1083cd:	56                   	push   %esi
  1083ce:	e8 ed fc ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, NUM_IDS);
  1083d3:	59                   	pop    %ecx
  1083d4:	5f                   	pop    %edi
  1083d5:	6a 40                	push   $0x40
  1083d7:	56                   	push   %esi
  1083d8:	e8 f3 fc ff ff       	call   1080d0 <syscall_set_retval1>
  1083dd:	83 c4 10             	add    $0x10,%esp
    } else {
        syscall_set_errno(tf, E_SUCC);
        syscall_set_retval1(tf, new_pid);
    }
}
  1083e0:	83 c4 1c             	add    $0x1c,%esp
  1083e3:	5b                   	pop    %ebx
  1083e4:	5e                   	pop    %esi
  1083e5:	5f                   	pop    %edi
  1083e6:	5d                   	pop    %ebp
  1083e7:	c3                   	ret
  1083e8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1083ef:	00 
        syscall_set_errno(tf, E_EXCEEDS_QUOTA);
  1083f0:	83 ec 08             	sub    $0x8,%esp
  1083f3:	6a 17                	push   $0x17
  1083f5:	eb d6                	jmp    1083cd <sys_spawn+0x7d>
  1083f7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1083fe:	00 
  1083ff:	90                   	nop
        syscall_set_errno(tf, E_INVAL_CHILD_ID);
  108400:	83 ec 08             	sub    $0x8,%esp
  108403:	6a 19                	push   $0x19
  108405:	eb c6                	jmp    1083cd <sys_spawn+0x7d>
  108407:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10840e:	00 
  10840f:	90                   	nop

00108410 <.L45>:
        syscall_set_errno(tf, E_INVAL_PID);
  108410:	83 ec 08             	sub    $0x8,%esp
  108413:	6a 05                	push   $0x5
  108415:	eb b6                	jmp    1083cd <sys_spawn+0x7d>
  108417:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10841e:	00 
  10841f:	90                   	nop

00108420 <.L39>:
        elf_addr = _binary___obj_user_pingpong_ding_start;
  108420:	c7 c0 6e 46 13 00    	mov    $0x13466e,%eax
  108426:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10842d:	00 
  10842e:	66 90                	xchg   %ax,%ax
    new_pid = proc_create(elf_addr, quota);
  108430:	83 ec 08             	sub    $0x8,%esp
  108433:	57                   	push   %edi
  108434:	50                   	push   %eax
  108435:	e8 86 fb ff ff       	call   107fc0 <proc_create>
    if (new_pid == NUM_IDS) {
  10843a:	83 c4 10             	add    $0x10,%esp
    new_pid = proc_create(elf_addr, quota);
  10843d:	89 c7                	mov    %eax,%edi
    if (new_pid == NUM_IDS) {
  10843f:	83 f8 40             	cmp    $0x40,%eax
  108442:	74 cc                	je     108410 <.L45>
        syscall_set_errno(tf, E_SUCC);
  108444:	83 ec 08             	sub    $0x8,%esp
  108447:	6a 00                	push   $0x0
  108449:	56                   	push   %esi
  10844a:	e8 71 fc ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, new_pid);
  10844f:	58                   	pop    %eax
  108450:	5a                   	pop    %edx
  108451:	57                   	push   %edi
  108452:	56                   	push   %esi
  108453:	e8 78 fc ff ff       	call   1080d0 <syscall_set_retval1>
  108458:	83 c4 10             	add    $0x10,%esp
}
  10845b:	83 c4 1c             	add    $0x1c,%esp
  10845e:	5b                   	pop    %ebx
  10845f:	5e                   	pop    %esi
  108460:	5f                   	pop    %edi
  108461:	5d                   	pop    %ebp
  108462:	c3                   	ret
  108463:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00108468 <.L43>:
    switch (elf_id) {
  108468:	c7 c0 12 ab 12 00    	mov    $0x12ab12,%eax
  10846e:	eb c0                	jmp    108430 <.L39+0x10>

00108470 <.L38>:
        elf_addr = _binary___obj_user_fstest_fstest_start;
  108470:	c7 c0 ca e1 13 00    	mov    $0x13e1ca,%eax
        break;
  108476:	eb b8                	jmp    108430 <.L39+0x10>
  108478:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10847f:	00 

00108480 <.L31>:
        elf_addr = _binary___obj_user_flocktest_flockstall_start;
  108480:	c7 c0 7e 4e 19 00    	mov    $0x194e7e,%eax
        break; 
  108486:	eb a8                	jmp    108430 <.L39+0x10>
  108488:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10848f:	00 

00108490 <.L34>:
        elf_addr = _binary___obj_user_flocktest_flockreader_start;
  108490:	c7 c0 5e 04 18 00    	mov    $0x18045e,%eax
        break;
  108496:	eb 98                	jmp    108430 <.L39+0x10>
  108498:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10849f:	00 

001084a0 <.L33>:
        elf_addr = _binary___obj_user_flocktest_flockwriter_start;
  1084a0:	c7 c0 b6 a9 18 00    	mov    $0x18a9b6,%eax
        break;
  1084a6:	eb 88                	jmp    108430 <.L39+0x10>
  1084a8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1084af:	00 

001084b0 <.L37>:
        elf_addr = _binary___obj_user_shell_shell_start;
  1084b0:	c7 c0 fe 42 15 00    	mov    $0x1542fe,%eax
        break;
  1084b6:	e9 75 ff ff ff       	jmp    108430 <.L39+0x10>
  1084bb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

001084c0 <.L36>:
        elf_addr = _binary___obj_user_flocktest_flocktest_start;
  1084c0:	c7 c0 7e 7d 16 00    	mov    $0x167d7e,%eax
        break;
  1084c6:	e9 65 ff ff ff       	jmp    108430 <.L39+0x10>
  1084cb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

001084d0 <.L35>:
        elf_addr = _binary___obj_user_flocktest_flockdemo_start;
  1084d0:	c7 c0 d2 5e 17 00    	mov    $0x175ed2,%eax
        break;
  1084d6:	e9 55 ff ff ff       	jmp    108430 <.L39+0x10>
  1084db:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

001084e0 <.L41>:
        elf_addr = _binary___obj_user_pingpong_ping_start;
  1084e0:	c7 c0 b6 0f 12 00    	mov    $0x120fb6,%eax
  1084e6:	e9 45 ff ff ff       	jmp    108430 <.L39+0x10>
  1084eb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

001084f0 <sys_yield>:
 * The user level library function sys_yield (defined in user/include/syscall.h)
 * does not take any argument and does not have any return values.
 * Do not forget to set the error number as E_SUCC.
 */
void sys_yield(tf_t *tf)
{
  1084f0:	53                   	push   %ebx
  1084f1:	e8 ac 7e ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1084f6:	81 c3 fe ea 00 00    	add    $0xeafe,%ebx
  1084fc:	83 ec 08             	sub    $0x8,%esp
    thread_yield();
  1084ff:	e8 7c f6 ff ff       	call   107b80 <thread_yield>
    syscall_set_errno(tf, E_SUCC);
  108504:	83 ec 08             	sub    $0x8,%esp
  108507:	6a 00                	push   $0x0
  108509:	ff 74 24 1c          	push   0x1c(%esp)
  10850d:	e8 ae fb ff ff       	call   1080c0 <syscall_set_errno>
}
  108512:	83 c4 18             	add    $0x18,%esp
  108515:	5b                   	pop    %ebx
  108516:	c3                   	ret
  108517:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10851e:	00 
  10851f:	90                   	nop

00108520 <sys_produce>:

void sys_produce(tf_t *tf)
{
  108520:	56                   	push   %esi
  108521:	53                   	push   %ebx
  108522:	e8 7b 7e ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108527:	81 c3 cd ea 00 00    	add    $0xeacd,%ebx
  10852d:	83 ec 10             	sub    $0x10,%esp
  108530:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    int item;

    item = syscall_get_arg2(tf);
  108534:	56                   	push   %esi
  108535:	e8 36 fb ff ff       	call   108070 <syscall_get_arg2>

	// intr_local_disable();
    // KERN_DEBUG("CPU %d: Process %d: CALLING bbuffer_insert_item(%d)\n", get_pcpu_idx(), get_curid(), item);
    // intr_local_enable();

    bbuffer_insert_item(item);
  10853a:	89 04 24             	mov    %eax,(%esp)
  10853d:	e8 ce 3c 00 00       	call   10c210 <bbuffer_insert_item>

    syscall_set_errno(tf, E_SUCC);
  108542:	58                   	pop    %eax
  108543:	5a                   	pop    %edx
  108544:	6a 00                	push   $0x0
  108546:	56                   	push   %esi
  108547:	e8 74 fb ff ff       	call   1080c0 <syscall_set_errno>
}
  10854c:	83 c4 14             	add    $0x14,%esp
  10854f:	5b                   	pop    %ebx
  108550:	5e                   	pop    %esi
  108551:	c3                   	ret
  108552:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  108559:	00 
  10855a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00108560 <sys_consume>:

void sys_consume(tf_t *tf)
{
  108560:	57                   	push   %edi
  108561:	56                   	push   %esi
  108562:	53                   	push   %ebx
  108563:	8b 7c 24 10          	mov    0x10(%esp),%edi
  108567:	e8 36 7e ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10856c:	81 c3 88 ea 00 00    	add    $0xea88,%ebx

	// intr_local_disable();
	// KERN_DEBUG("CPU: %d, Process %d: CALLING bbuffer_remove_item()\n", get_pcpu_idx(), get_curid());
	// intr_local_enable();

    removed_item = bbuffer_remove_item(); 
  108572:	e8 59 3d 00 00       	call   10c2d0 <bbuffer_remove_item>
    syscall_set_errno(tf, E_SUCC);
  108577:	83 ec 08             	sub    $0x8,%esp
  10857a:	6a 00                	push   $0x0
    removed_item = bbuffer_remove_item(); 
  10857c:	89 c6                	mov    %eax,%esi
    syscall_set_errno(tf, E_SUCC);
  10857e:	57                   	push   %edi
  10857f:	e8 3c fb ff ff       	call   1080c0 <syscall_set_errno>
    syscall_set_retval1(tf, removed_item);
  108584:	58                   	pop    %eax
  108585:	5a                   	pop    %edx
  108586:	56                   	push   %esi
  108587:	57                   	push   %edi
  108588:	e8 43 fb ff ff       	call   1080d0 <syscall_set_retval1>
  10858d:	83 c4 10             	add    $0x10,%esp
  108590:	5b                   	pop    %ebx
  108591:	5e                   	pop    %esi
  108592:	5f                   	pop    %edi
  108593:	c3                   	ret
  108594:	66 90                	xchg   %ax,%ax
  108596:	66 90                	xchg   %ax,%ax
  108598:	66 90                	xchg   %ax,%ax
  10859a:	66 90                	xchg   %ax,%ax
  10859c:	66 90                	xchg   %ax,%ax
  10859e:	66 90                	xchg   %ax,%ax

001085a0 <syscall_dispatch>:

#include "import.h"
#include <kern/fs/sysfile.h>

void syscall_dispatch(tf_t *tf)
{
  1085a0:	56                   	push   %esi
  1085a1:	53                   	push   %ebx
  1085a2:	e8 fb 7d ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1085a7:	81 c3 4d ea 00 00    	add    $0xea4d,%ebx
  1085ad:	83 ec 10             	sub    $0x10,%esp
  1085b0:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    unsigned int nr;

    nr = syscall_get_arg1(tf);
  1085b4:	56                   	push   %esi
  1085b5:	e8 a6 fa ff ff       	call   108060 <syscall_get_arg1>

    switch (nr) {
  1085ba:	83 c4 10             	add    $0x10,%esp
  1085bd:	83 f8 0f             	cmp    $0xf,%eax
  1085c0:	0f 87 53 01 00 00    	ja     108719 <.L6+0x11>
  1085c6:	8b 94 83 88 7f ff ff 	mov    -0x8078(%ebx,%eax,4),%edx
  1085cd:	01 da                	add    %ebx,%edx
  1085cf:	ff e2                	jmp    *%edx
  1085d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001085d8 <.L5>:
        break;
    case SYS_flock:
        sys_flock(tf);
        break;
    case SYS_produce:
        sys_produce(tf);
  1085d8:	83 ec 0c             	sub    $0xc,%esp
  1085db:	56                   	push   %esi
  1085dc:	e8 3f ff ff ff       	call   108520 <sys_produce>
        break;
  1085e1:	83 c4 10             	add    $0x10,%esp
        sys_consume(tf);
        break;
    default:
        syscall_set_errno(tf, E_INVAL_CALLNR);
    }
}
  1085e4:	83 c4 04             	add    $0x4,%esp
  1085e7:	5b                   	pop    %ebx
  1085e8:	5e                   	pop    %esi
  1085e9:	c3                   	ret
  1085ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001085f0 <.L3>:
        sys_consume(tf);
  1085f0:	83 ec 0c             	sub    $0xc,%esp
  1085f3:	56                   	push   %esi
  1085f4:	e8 67 ff ff ff       	call   108560 <sys_consume>
        break;
  1085f9:	83 c4 10             	add    $0x10,%esp
  1085fc:	eb e6                	jmp    1085e4 <.L5+0xc>
  1085fe:	66 90                	xchg   %ax,%ax

00108600 <.L19>:
        sys_puts(tf);
  108600:	83 ec 0c             	sub    $0xc,%esp
  108603:	56                   	push   %esi
  108604:	e8 17 fb ff ff       	call   108120 <sys_puts>
        break;
  108609:	83 c4 10             	add    $0x10,%esp
  10860c:	eb d6                	jmp    1085e4 <.L5+0xc>
  10860e:	66 90                	xchg   %ax,%ax

00108610 <.L18>:
        sys_readline(tf);
  108610:	83 ec 0c             	sub    $0xc,%esp
  108613:	56                   	push   %esi
  108614:	e8 37 fc ff ff       	call   108250 <sys_readline>
        break;
  108619:	83 c4 10             	add    $0x10,%esp
  10861c:	eb c6                	jmp    1085e4 <.L5+0xc>
  10861e:	66 90                	xchg   %ax,%ax

00108620 <.L17>:
        sys_spawn(tf);
  108620:	83 ec 0c             	sub    $0xc,%esp
  108623:	56                   	push   %esi
  108624:	e8 27 fd ff ff       	call   108350 <sys_spawn>
        break;
  108629:	83 c4 10             	add    $0x10,%esp
  10862c:	eb b6                	jmp    1085e4 <.L5+0xc>
  10862e:	66 90                	xchg   %ax,%ax

00108630 <.L16>:
        sys_yield(tf);
  108630:	83 ec 0c             	sub    $0xc,%esp
  108633:	56                   	push   %esi
  108634:	e8 b7 fe ff ff       	call   1084f0 <sys_yield>
        break;
  108639:	83 c4 10             	add    $0x10,%esp
  10863c:	eb a6                	jmp    1085e4 <.L5+0xc>
  10863e:	66 90                	xchg   %ax,%ax

00108640 <.L15>:
        sys_open(tf);
  108640:	83 ec 0c             	sub    $0xc,%esp
  108643:	56                   	push   %esi
  108644:	e8 17 31 00 00       	call   10b760 <sys_open>
        break;
  108649:	83 c4 10             	add    $0x10,%esp
  10864c:	eb 96                	jmp    1085e4 <.L5+0xc>
  10864e:	66 90                	xchg   %ax,%ax

00108650 <.L14>:
        sys_close(tf);
  108650:	83 ec 0c             	sub    $0xc,%esp
  108653:	56                   	push   %esi
  108654:	e8 87 2a 00 00       	call   10b0e0 <sys_close>
        break;
  108659:	83 c4 10             	add    $0x10,%esp
  10865c:	eb 86                	jmp    1085e4 <.L5+0xc>
  10865e:	66 90                	xchg   %ax,%ax

00108660 <.L13>:
        sys_read(tf);
  108660:	83 ec 0c             	sub    $0xc,%esp
  108663:	56                   	push   %esi
  108664:	e8 e7 27 00 00       	call   10ae50 <sys_read>
        break;
  108669:	83 c4 10             	add    $0x10,%esp
  10866c:	e9 73 ff ff ff       	jmp    1085e4 <.L5+0xc>
  108671:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00108678 <.L12>:
        sys_write(tf);
  108678:	83 ec 0c             	sub    $0xc,%esp
  10867b:	56                   	push   %esi
  10867c:	e8 1f 29 00 00       	call   10afa0 <sys_write>
        break;
  108681:	83 c4 10             	add    $0x10,%esp
  108684:	e9 5b ff ff ff       	jmp    1085e4 <.L5+0xc>
  108689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00108690 <.L11>:
        sys_mkdir(tf);
  108690:	83 ec 0c             	sub    $0xc,%esp
  108693:	56                   	push   %esi
  108694:	e8 f7 32 00 00       	call   10b990 <sys_mkdir>
        break;
  108699:	83 c4 10             	add    $0x10,%esp
  10869c:	e9 43 ff ff ff       	jmp    1085e4 <.L5+0xc>
  1086a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001086a8 <.L10>:
        sys_chdir(tf);
  1086a8:	83 ec 0c             	sub    $0xc,%esp
  1086ab:	56                   	push   %esi
  1086ac:	e8 bf 33 00 00       	call   10ba70 <sys_chdir>
        break;
  1086b1:	83 c4 10             	add    $0x10,%esp
  1086b4:	e9 2b ff ff ff       	jmp    1085e4 <.L5+0xc>
  1086b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001086c0 <.L9>:
        sys_link(tf);
  1086c0:	83 ec 0c             	sub    $0xc,%esp
  1086c3:	56                   	push   %esi
  1086c4:	e8 97 2b 00 00       	call   10b260 <sys_link>
        break;
  1086c9:	83 c4 10             	add    $0x10,%esp
  1086cc:	e9 13 ff ff ff       	jmp    1085e4 <.L5+0xc>
  1086d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001086d8 <.L8>:
        sys_unlink(tf);
  1086d8:	83 ec 0c             	sub    $0xc,%esp
  1086db:	56                   	push   %esi
  1086dc:	e8 7f 2d 00 00       	call   10b460 <sys_unlink>
        break;
  1086e1:	83 c4 10             	add    $0x10,%esp
  1086e4:	e9 fb fe ff ff       	jmp    1085e4 <.L5+0xc>
  1086e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

001086f0 <.L7>:
        sys_fstat(tf);
  1086f0:	83 ec 0c             	sub    $0xc,%esp
  1086f3:	56                   	push   %esi
  1086f4:	e8 87 2a 00 00       	call   10b180 <sys_fstat>
        break;
  1086f9:	83 c4 10             	add    $0x10,%esp
  1086fc:	e9 e3 fe ff ff       	jmp    1085e4 <.L5+0xc>
  108701:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00108708 <.L6>:
        sys_flock(tf);
  108708:	83 ec 0c             	sub    $0xc,%esp
  10870b:	56                   	push   %esi
  10870c:	e8 9f 34 00 00       	call   10bbb0 <sys_flock>
        break;
  108711:	83 c4 10             	add    $0x10,%esp
  108714:	e9 cb fe ff ff       	jmp    1085e4 <.L5+0xc>
        syscall_set_errno(tf, E_INVAL_CALLNR);
  108719:	83 ec 08             	sub    $0x8,%esp
  10871c:	6a 03                	push   $0x3
  10871e:	56                   	push   %esi
  10871f:	e8 9c f9 ff ff       	call   1080c0 <syscall_set_errno>
  108724:	83 c4 10             	add    $0x10,%esp
}
  108727:	e9 b8 fe ff ff       	jmp    1085e4 <.L5+0xc>
  10872c:	66 90                	xchg   %ax,%ax
  10872e:	66 90                	xchg   %ax,%ax

00108730 <trap_dump.part.0>:

#include "import.h"

void ide_intr(void);

static void trap_dump(tf_t *tf)
  108730:	55                   	push   %ebp
  108731:	57                   	push   %edi
  108732:	56                   	push   %esi
  108733:	89 c6                	mov    %eax,%esi
  108735:	53                   	push   %ebx
  108736:	e8 67 7c ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10873b:	81 c3 b9 e8 00 00    	add    $0xe8b9,%ebx
  108741:	83 ec 0c             	sub    $0xc,%esp
    if (tf == NULL)
        return;

    uintptr_t base = (uintptr_t) tf;

    KERN_DEBUG("trapframe at %x\n", base);
  108744:	50                   	push   %eax
  108745:	8d bb b8 72 ff ff    	lea    -0x8d48(%ebx),%edi
  10874b:	8d 83 12 66 ff ff    	lea    -0x99ee(%ebx),%eax
  108751:	50                   	push   %eax
    KERN_DEBUG("\t%08x:\tedi:   \t\t%08x\n", &tf->regs.edi, tf->regs.edi);
    KERN_DEBUG("\t%08x:\tesi:   \t\t%08x\n", &tf->regs.esi, tf->regs.esi);
    KERN_DEBUG("\t%08x:\tebp:   \t\t%08x\n", &tf->regs.ebp, tf->regs.ebp);
    KERN_DEBUG("\t%08x:\tesp:   \t\t%08x\n", &tf->regs.oesp, tf->regs.oesp);
  108752:	8d ab 65 66 ff ff    	lea    -0x999b(%ebx),%ebp
    KERN_DEBUG("trapframe at %x\n", base);
  108758:	6a 18                	push   $0x18
  10875a:	57                   	push   %edi
  10875b:	e8 30 c0 ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tedi:   \t\t%08x\n", &tf->regs.edi, tf->regs.edi);
  108760:	58                   	pop    %eax
  108761:	8d 83 23 66 ff ff    	lea    -0x99dd(%ebx),%eax
  108767:	ff 36                	push   (%esi)
  108769:	56                   	push   %esi
  10876a:	50                   	push   %eax
  10876b:	6a 19                	push   $0x19
  10876d:	57                   	push   %edi
  10876e:	e8 1d c0 ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tesi:   \t\t%08x\n", &tf->regs.esi, tf->regs.esi);
  108773:	83 c4 14             	add    $0x14,%esp
  108776:	8d 46 04             	lea    0x4(%esi),%eax
  108779:	ff 76 04             	push   0x4(%esi)
  10877c:	50                   	push   %eax
  10877d:	8d 83 39 66 ff ff    	lea    -0x99c7(%ebx),%eax
  108783:	50                   	push   %eax
  108784:	6a 1a                	push   $0x1a
  108786:	57                   	push   %edi
  108787:	e8 04 c0 ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tebp:   \t\t%08x\n", &tf->regs.ebp, tf->regs.ebp);
  10878c:	83 c4 14             	add    $0x14,%esp
  10878f:	8d 46 08             	lea    0x8(%esi),%eax
  108792:	ff 76 08             	push   0x8(%esi)
  108795:	50                   	push   %eax
  108796:	8d 83 4f 66 ff ff    	lea    -0x99b1(%ebx),%eax
  10879c:	50                   	push   %eax
  10879d:	6a 1b                	push   $0x1b
  10879f:	57                   	push   %edi
  1087a0:	e8 eb bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tesp:   \t\t%08x\n", &tf->regs.oesp, tf->regs.oesp);
  1087a5:	83 c4 14             	add    $0x14,%esp
  1087a8:	8d 46 0c             	lea    0xc(%esi),%eax
  1087ab:	ff 76 0c             	push   0xc(%esi)
  1087ae:	50                   	push   %eax
  1087af:	55                   	push   %ebp
  1087b0:	6a 1c                	push   $0x1c
  1087b2:	57                   	push   %edi
  1087b3:	e8 d8 bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tebx:   \t\t%08x\n", &tf->regs.ebx, tf->regs.ebx);
  1087b8:	83 c4 14             	add    $0x14,%esp
  1087bb:	8d 46 10             	lea    0x10(%esi),%eax
  1087be:	ff 76 10             	push   0x10(%esi)
  1087c1:	50                   	push   %eax
  1087c2:	8d 83 7b 66 ff ff    	lea    -0x9985(%ebx),%eax
  1087c8:	50                   	push   %eax
  1087c9:	6a 1d                	push   $0x1d
  1087cb:	57                   	push   %edi
  1087cc:	e8 bf bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tedx:   \t\t%08x\n", &tf->regs.edx, tf->regs.edx);
  1087d1:	83 c4 14             	add    $0x14,%esp
  1087d4:	8d 46 14             	lea    0x14(%esi),%eax
  1087d7:	ff 76 14             	push   0x14(%esi)
  1087da:	50                   	push   %eax
  1087db:	8d 83 91 66 ff ff    	lea    -0x996f(%ebx),%eax
  1087e1:	50                   	push   %eax
  1087e2:	6a 1e                	push   $0x1e
  1087e4:	57                   	push   %edi
  1087e5:	e8 a6 bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tecx:   \t\t%08x\n", &tf->regs.ecx, tf->regs.ecx);
  1087ea:	83 c4 14             	add    $0x14,%esp
  1087ed:	8d 46 18             	lea    0x18(%esi),%eax
  1087f0:	ff 76 18             	push   0x18(%esi)
  1087f3:	50                   	push   %eax
  1087f4:	8d 83 a7 66 ff ff    	lea    -0x9959(%ebx),%eax
  1087fa:	50                   	push   %eax
  1087fb:	6a 1f                	push   $0x1f
  1087fd:	57                   	push   %edi
  1087fe:	e8 8d bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\teax:   \t\t%08x\n", &tf->regs.eax, tf->regs.eax);
  108803:	83 c4 14             	add    $0x14,%esp
  108806:	8d 46 1c             	lea    0x1c(%esi),%eax
  108809:	ff 76 1c             	push   0x1c(%esi)
  10880c:	50                   	push   %eax
  10880d:	8d 83 bd 66 ff ff    	lea    -0x9943(%ebx),%eax
  108813:	50                   	push   %eax
  108814:	6a 20                	push   $0x20
  108816:	57                   	push   %edi
  108817:	e8 74 bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tes:    \t\t%08x\n", &tf->es, tf->es);
  10881c:	0f b7 46 20          	movzwl 0x20(%esi),%eax
  108820:	83 c4 14             	add    $0x14,%esp
  108823:	50                   	push   %eax
  108824:	8d 46 20             	lea    0x20(%esi),%eax
  108827:	50                   	push   %eax
  108828:	8d 83 d3 66 ff ff    	lea    -0x992d(%ebx),%eax
  10882e:	50                   	push   %eax
  10882f:	6a 21                	push   $0x21
  108831:	57                   	push   %edi
  108832:	e8 59 bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tds:    \t\t%08x\n", &tf->ds, tf->ds);
  108837:	0f b7 46 24          	movzwl 0x24(%esi),%eax
  10883b:	83 c4 14             	add    $0x14,%esp
  10883e:	50                   	push   %eax
  10883f:	8d 46 24             	lea    0x24(%esi),%eax
  108842:	50                   	push   %eax
  108843:	8d 83 e9 66 ff ff    	lea    -0x9917(%ebx),%eax
  108849:	50                   	push   %eax
  10884a:	6a 22                	push   $0x22
  10884c:	57                   	push   %edi
  10884d:	e8 3e bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\ttrapno:\t\t%08x\n", &tf->trapno, tf->trapno);
  108852:	83 c4 14             	add    $0x14,%esp
  108855:	8d 46 28             	lea    0x28(%esi),%eax
  108858:	ff 76 28             	push   0x28(%esi)
  10885b:	50                   	push   %eax
  10885c:	8d 83 ff 66 ff ff    	lea    -0x9901(%ebx),%eax
  108862:	50                   	push   %eax
  108863:	6a 23                	push   $0x23
  108865:	57                   	push   %edi
  108866:	e8 25 bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\terr:   \t\t%08x\n", &tf->err, tf->err);
  10886b:	83 c4 14             	add    $0x14,%esp
  10886e:	8d 46 2c             	lea    0x2c(%esi),%eax
  108871:	ff 76 2c             	push   0x2c(%esi)
  108874:	50                   	push   %eax
  108875:	8d 83 15 67 ff ff    	lea    -0x98eb(%ebx),%eax
  10887b:	50                   	push   %eax
  10887c:	6a 24                	push   $0x24
  10887e:	57                   	push   %edi
  10887f:	e8 0c bf ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\teip:   \t\t%08x\n", &tf->eip, tf->eip);
  108884:	83 c4 14             	add    $0x14,%esp
  108887:	8d 46 30             	lea    0x30(%esi),%eax
  10888a:	ff 76 30             	push   0x30(%esi)
  10888d:	50                   	push   %eax
  10888e:	8d 83 2b 67 ff ff    	lea    -0x98d5(%ebx),%eax
  108894:	50                   	push   %eax
  108895:	6a 25                	push   $0x25
  108897:	57                   	push   %edi
  108898:	e8 f3 be ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tcs:    \t\t%08x\n", &tf->cs, tf->cs);
  10889d:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  1088a1:	83 c4 14             	add    $0x14,%esp
  1088a4:	50                   	push   %eax
  1088a5:	8d 46 34             	lea    0x34(%esi),%eax
  1088a8:	50                   	push   %eax
  1088a9:	8d 83 41 67 ff ff    	lea    -0x98bf(%ebx),%eax
  1088af:	50                   	push   %eax
  1088b0:	6a 26                	push   $0x26
  1088b2:	57                   	push   %edi
  1088b3:	e8 d8 be ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\teflags:\t\t%08x\n", &tf->eflags, tf->eflags);
  1088b8:	83 c4 14             	add    $0x14,%esp
  1088bb:	8d 46 38             	lea    0x38(%esi),%eax
  1088be:	ff 76 38             	push   0x38(%esi)
  1088c1:	50                   	push   %eax
  1088c2:	8d 83 57 67 ff ff    	lea    -0x98a9(%ebx),%eax
  1088c8:	50                   	push   %eax
  1088c9:	6a 27                	push   $0x27
  1088cb:	57                   	push   %edi
  1088cc:	e8 bf be ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tesp:   \t\t%08x\n", &tf->esp, tf->esp);
  1088d1:	83 c4 14             	add    $0x14,%esp
  1088d4:	8d 46 3c             	lea    0x3c(%esi),%eax
  1088d7:	ff 76 3c             	push   0x3c(%esi)
  1088da:	50                   	push   %eax
    KERN_DEBUG("\t%08x:\tss:    \t\t%08x\n", &tf->ss, tf->ss);
  1088db:	83 c6 40             	add    $0x40,%esi
    KERN_DEBUG("\t%08x:\tesp:   \t\t%08x\n", &tf->esp, tf->esp);
  1088de:	55                   	push   %ebp
  1088df:	6a 28                	push   $0x28
  1088e1:	57                   	push   %edi
  1088e2:	e8 a9 be ff ff       	call   104790 <debug_normal>
    KERN_DEBUG("\t%08x:\tss:    \t\t%08x\n", &tf->ss, tf->ss);
  1088e7:	0f b7 06             	movzwl (%esi),%eax
  1088ea:	83 c4 14             	add    $0x14,%esp
  1088ed:	50                   	push   %eax
  1088ee:	8d 83 6d 67 ff ff    	lea    -0x9893(%ebx),%eax
  1088f4:	56                   	push   %esi
  1088f5:	50                   	push   %eax
  1088f6:	6a 29                	push   $0x29
  1088f8:	57                   	push   %edi
  1088f9:	e8 92 be ff ff       	call   104790 <debug_normal>
}
  1088fe:	83 c4 2c             	add    $0x2c,%esp
  108901:	5b                   	pop    %ebx
  108902:	5e                   	pop    %esi
  108903:	5f                   	pop    %edi
  108904:	5d                   	pop    %ebp
  108905:	c3                   	ret
  108906:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10890d:	00 
  10890e:	66 90                	xchg   %ax,%ax

00108910 <default_exception_handler>:

void default_exception_handler(tf_t *tf)
{
  108910:	56                   	push   %esi
  108911:	53                   	push   %ebx
  108912:	e8 8b 7a ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108917:	81 c3 dd e6 00 00    	add    $0xe6dd,%ebx
  10891d:	83 ec 04             	sub    $0x4,%esp
  108920:	8b 74 24 10          	mov    0x10(%esp),%esi
    unsigned int cur_pid;

    cur_pid = get_curid();
  108924:	e8 f7 f0 ff ff       	call   107a20 <get_curid>
    if (tf == NULL)
  108929:	85 f6                	test   %esi,%esi
  10892b:	74 07                	je     108934 <default_exception_handler+0x24>
  10892d:	89 f0                	mov    %esi,%eax
  10892f:	e8 fc fd ff ff       	call   108730 <trap_dump.part.0>
    trap_dump(tf);

    KERN_PANIC("Trap %d @ 0x%08x.\n", tf->trapno, tf->eip);
  108934:	83 ec 0c             	sub    $0xc,%esp
  108937:	8d 83 83 67 ff ff    	lea    -0x987d(%ebx),%eax
  10893d:	ff 76 30             	push   0x30(%esi)
  108940:	ff 76 28             	push   0x28(%esi)
  108943:	50                   	push   %eax
  108944:	8d 83 b8 72 ff ff    	lea    -0x8d48(%ebx),%eax
  10894a:	6a 33                	push   $0x33
  10894c:	50                   	push   %eax
  10894d:	e8 9e be ff ff       	call   1047f0 <debug_panic>
}
  108952:	83 c4 24             	add    $0x24,%esp
  108955:	5b                   	pop    %ebx
  108956:	5e                   	pop    %esi
  108957:	c3                   	ret
  108958:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10895f:	00 

00108960 <pgflt_handler>:

void pgflt_handler(tf_t *tf)
{
  108960:	55                   	push   %ebp
  108961:	57                   	push   %edi
  108962:	56                   	push   %esi
  108963:	53                   	push   %ebx
  108964:	e8 39 7a ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108969:	81 c3 8b e6 00 00    	add    $0xe68b,%ebx
  10896f:	83 ec 0c             	sub    $0xc,%esp
    unsigned int cur_pid;
    unsigned int errno;
    unsigned int fault_va;

    cur_pid = get_curid();
  108972:	e8 a9 f0 ff ff       	call   107a20 <get_curid>
  108977:	89 c6                	mov    %eax,%esi
    errno = tf->err;
  108979:	8b 44 24 20          	mov    0x20(%esp),%eax
  10897d:	8b 78 2c             	mov    0x2c(%eax),%edi
    fault_va = rcr2();
  108980:	e8 2b cc ff ff       	call   1055b0 <rcr2>
  108985:	89 c5                	mov    %eax,%ebp

    // Uncomment this line to see information about the page fault
    // KERN_DEBUG("Page fault: VA 0x%08x, errno 0x%08x, process %d, EIP 0x%08x.\n",
    //            fault_va, errno, cur_pid, uctx_pool[cur_pid].eip);

    if (errno & PFE_PR) {
  108987:	f7 c7 01 00 00 00    	test   $0x1,%edi
  10898d:	75 21                	jne    1089b0 <pgflt_handler+0x50>
        KERN_PANIC("Permission denied: va = 0x%08x, errno = 0x%08x.\n",
                   fault_va, errno);
        return;
    }

    if (alloc_page(cur_pid, fault_va, PTE_W | PTE_U | PTE_P) == MagicNumber) {
  10898f:	83 ec 04             	sub    $0x4,%esp
  108992:	6a 07                	push   $0x7
  108994:	50                   	push   %eax
  108995:	56                   	push   %esi
  108996:	e8 55 e9 ff ff       	call   1072f0 <alloc_page>
  10899b:	83 c4 10             	add    $0x10,%esp
  10899e:	3d 01 00 10 00       	cmp    $0x100001,%eax
  1089a3:	74 3b                	je     1089e0 <pgflt_handler+0x80>
        KERN_PANIC("Page allocation failed: va = 0x%08x, errno = 0x%08x.\n",
                   fault_va, errno);
    }
}
  1089a5:	83 c4 0c             	add    $0xc,%esp
  1089a8:	5b                   	pop    %ebx
  1089a9:	5e                   	pop    %esi
  1089aa:	5f                   	pop    %edi
  1089ab:	5d                   	pop    %ebp
  1089ac:	c3                   	ret
  1089ad:	8d 76 00             	lea    0x0(%esi),%esi
    if (tf == NULL)
  1089b0:	8b 44 24 20          	mov    0x20(%esp),%eax
  1089b4:	e8 77 fd ff ff       	call   108730 <trap_dump.part.0>
        KERN_PANIC("Permission denied: va = 0x%08x, errno = 0x%08x.\n",
  1089b9:	83 ec 0c             	sub    $0xc,%esp
  1089bc:	8d 83 e0 72 ff ff    	lea    -0x8d20(%ebx),%eax
  1089c2:	57                   	push   %edi
  1089c3:	55                   	push   %ebp
  1089c4:	50                   	push   %eax
  1089c5:	8d 83 b8 72 ff ff    	lea    -0x8d48(%ebx),%eax
  1089cb:	6a 46                	push   $0x46
  1089cd:	50                   	push   %eax
  1089ce:	e8 1d be ff ff       	call   1047f0 <debug_panic>
        return;
  1089d3:	83 c4 20             	add    $0x20,%esp
}
  1089d6:	83 c4 0c             	add    $0xc,%esp
  1089d9:	5b                   	pop    %ebx
  1089da:	5e                   	pop    %esi
  1089db:	5f                   	pop    %edi
  1089dc:	5d                   	pop    %ebp
  1089dd:	c3                   	ret
  1089de:	66 90                	xchg   %ax,%ax
        KERN_PANIC("Page allocation failed: va = 0x%08x, errno = 0x%08x.\n",
  1089e0:	83 ec 0c             	sub    $0xc,%esp
  1089e3:	8d 83 14 73 ff ff    	lea    -0x8cec(%ebx),%eax
  1089e9:	57                   	push   %edi
  1089ea:	55                   	push   %ebp
  1089eb:	50                   	push   %eax
  1089ec:	8d 83 b8 72 ff ff    	lea    -0x8d48(%ebx),%eax
  1089f2:	6a 4c                	push   $0x4c
  1089f4:	50                   	push   %eax
  1089f5:	e8 f6 bd ff ff       	call   1047f0 <debug_panic>
  1089fa:	83 c4 20             	add    $0x20,%esp
}
  1089fd:	83 c4 0c             	add    $0xc,%esp
  108a00:	5b                   	pop    %ebx
  108a01:	5e                   	pop    %esi
  108a02:	5f                   	pop    %edi
  108a03:	5d                   	pop    %ebp
  108a04:	c3                   	ret
  108a05:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  108a0c:	00 
  108a0d:	8d 76 00             	lea    0x0(%esi),%esi

00108a10 <exception_handler>:
/**
 * We currently only handle the page fault exception.
 * All other exceptions should be routed to the default exception handler.
 */
void exception_handler(tf_t *tf)
{
  108a10:	56                   	push   %esi
  108a11:	53                   	push   %ebx
  108a12:	e8 8b 79 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108a17:	81 c3 dd e5 00 00    	add    $0xe5dd,%ebx
  108a1d:	83 ec 04             	sub    $0x4,%esp
  108a20:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (tf->trapno == T_PGFLT)
  108a24:	83 7e 28 0e          	cmpl   $0xe,0x28(%esi)
  108a28:	74 36                	je     108a60 <exception_handler+0x50>
    cur_pid = get_curid();
  108a2a:	e8 f1 ef ff ff       	call   107a20 <get_curid>
    if (tf == NULL)
  108a2f:	89 f0                	mov    %esi,%eax
  108a31:	e8 fa fc ff ff       	call   108730 <trap_dump.part.0>
    KERN_PANIC("Trap %d @ 0x%08x.\n", tf->trapno, tf->eip);
  108a36:	83 ec 0c             	sub    $0xc,%esp
  108a39:	8d 83 83 67 ff ff    	lea    -0x987d(%ebx),%eax
  108a3f:	ff 76 30             	push   0x30(%esi)
  108a42:	ff 76 28             	push   0x28(%esi)
  108a45:	50                   	push   %eax
  108a46:	8d 83 b8 72 ff ff    	lea    -0x8d48(%ebx),%eax
  108a4c:	6a 33                	push   $0x33
  108a4e:	50                   	push   %eax
  108a4f:	e8 9c bd ff ff       	call   1047f0 <debug_panic>
        pgflt_handler(tf);
    else
        default_exception_handler(tf);
}
  108a54:	83 c4 24             	add    $0x24,%esp
  108a57:	5b                   	pop    %ebx
  108a58:	5e                   	pop    %esi
  108a59:	c3                   	ret
  108a5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        pgflt_handler(tf);
  108a60:	89 74 24 10          	mov    %esi,0x10(%esp)
}
  108a64:	83 c4 04             	add    $0x4,%esp
  108a67:	5b                   	pop    %ebx
  108a68:	5e                   	pop    %esi
        pgflt_handler(tf);
  108a69:	e9 f2 fe ff ff       	jmp    108960 <pgflt_handler>
  108a6e:	66 90                	xchg   %ax,%ax

00108a70 <interrupt_handler>:
/**
 * Any interrupt request other than the spurious or timer should be
 * routed to the default interrupt handler.
 */
void interrupt_handler(tf_t *tf)
{
  108a70:	53                   	push   %ebx
  108a71:	e8 2c 79 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108a76:	81 c3 7e e5 00 00    	add    $0xe57e,%ebx
  108a7c:	83 ec 08             	sub    $0x8,%esp
    switch (tf->trapno) {
  108a7f:	8b 44 24 10          	mov    0x10(%esp),%eax
  108a83:	8b 40 28             	mov    0x28(%eax),%eax
  108a86:	83 f8 2e             	cmp    $0x2e,%eax
  108a89:	74 2d                	je     108ab8 <interrupt_handler+0x48>
  108a8b:	77 1b                	ja     108aa8 <interrupt_handler+0x38>
  108a8d:	83 f8 20             	cmp    $0x20,%eax
  108a90:	74 3e                	je     108ad0 <interrupt_handler+0x60>
  108a92:	83 f8 27             	cmp    $0x27,%eax
  108a95:	74 05                	je     108a9c <interrupt_handler+0x2c>
    intr_eoi();
  108a97:	e8 e4 8e ff ff       	call   101980 <intr_eoi>
        intr_eoi();
        break;
    default:
        default_intr_handler();
    }
}
  108a9c:	83 c4 08             	add    $0x8,%esp
  108a9f:	5b                   	pop    %ebx
  108aa0:	c3                   	ret
  108aa1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    switch (tf->trapno) {
  108aa8:	83 f8 2f             	cmp    $0x2f,%eax
  108aab:	74 ef                	je     108a9c <interrupt_handler+0x2c>
    intr_eoi();
  108aad:	e8 ce 8e ff ff       	call   101980 <intr_eoi>
    return 0;
  108ab2:	eb e8                	jmp    108a9c <interrupt_handler+0x2c>
  108ab4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        ide_intr();
  108ab8:	e8 f3 b4 ff ff       	call   103fb0 <ide_intr>
        intr_eoi();
  108abd:	e8 be 8e ff ff       	call   101980 <intr_eoi>
}
  108ac2:	83 c4 08             	add    $0x8,%esp
  108ac5:	5b                   	pop    %ebx
  108ac6:	c3                   	ret
  108ac7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  108ace:	00 
  108acf:	90                   	nop
    intr_eoi();
  108ad0:	e8 ab 8e ff ff       	call   101980 <intr_eoi>
    sched_update();
  108ad5:	e8 46 f1 ff ff       	call   107c20 <sched_update>
}
  108ada:	83 c4 08             	add    $0x8,%esp
  108add:	5b                   	pop    %ebx
  108ade:	c3                   	ret
  108adf:	90                   	nop

00108ae0 <trap>:

unsigned int last_active[NUM_CPUS];

void trap(tf_t *tf)
{
  108ae0:	55                   	push   %ebp
  108ae1:	57                   	push   %edi
  108ae2:	56                   	push   %esi
  108ae3:	53                   	push   %ebx
  108ae4:	e8 b9 78 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108ae9:	81 c3 0b e5 00 00    	add    $0xe50b,%ebx
  108aef:	83 ec 1c             	sub    $0x1c,%esp
    unsigned int cur_pid = get_curid();
  108af2:	e8 29 ef ff ff       	call   107a20 <get_curid>
    unsigned int cpu_idx = get_pcpu_idx();
    trap_cb_t handler;

    unsigned int last_pid = last_active[cpu_idx];
  108af7:	8d ab 2c 70 d5 00    	lea    0xd5702c(%ebx),%ebp
    unsigned int cur_pid = get_curid();
  108afd:	89 44 24 0c          	mov    %eax,0xc(%esp)
    unsigned int cpu_idx = get_pcpu_idx();
  108b01:	e8 5a d7 ff ff       	call   106260 <get_pcpu_idx>
    unsigned int last_pid = last_active[cpu_idx];
  108b06:	8b 7c 85 00          	mov    0x0(%ebp,%eax,4),%edi
    unsigned int cpu_idx = get_pcpu_idx();
  108b0a:	89 c6                	mov    %eax,%esi

    if (last_pid != 0)
  108b0c:	85 ff                	test   %edi,%edi
  108b0e:	75 48                	jne    108b58 <trap+0x78>
    {
        set_pdir_base(0);  // switch to the kernel's page table
        last_active[cpu_idx] = 0;
    }

    handler = TRAP_HANDLER[get_pcpu_idx()][tf->trapno];
  108b10:	e8 4b d7 ff ff       	call   106260 <get_pcpu_idx>
  108b15:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  108b19:	c1 e0 08             	shl    $0x8,%eax
  108b1c:	8b 51 28             	mov    0x28(%ecx),%edx
  108b1f:	c7 c1 40 e0 e6 00    	mov    $0xe6e040,%ecx
  108b25:	01 d0                	add    %edx,%eax
  108b27:	8b 04 81             	mov    (%ecx,%eax,4),%eax

    if (handler) {
  108b2a:	85 c0                	test   %eax,%eax
  108b2c:	74 62                	je     108b90 <trap+0xb0>
        handler(tf);
  108b2e:	83 ec 0c             	sub    $0xc,%esp
  108b31:	ff 74 24 3c          	push   0x3c(%esp)
  108b35:	ff d0                	call   *%eax
  108b37:	83 c4 10             	add    $0x10,%esp
    } else {
        KERN_WARN("No handler for user trap 0x%x, process %d, eip 0x%08x.\n",
                  tf->trapno, cur_pid, tf->eip);
    }

    if (last_pid != 0)
  108b3a:	85 ff                	test   %edi,%edi
  108b3c:	75 32                	jne    108b70 <trap+0x90>
        kstack_switch(cur_pid);
        set_pdir_base(cur_pid);
        last_active[cpu_idx] = last_pid;
    }

    trap_return((void *) tf);
  108b3e:	83 ec 0c             	sub    $0xc,%esp
  108b41:	ff 74 24 3c          	push   0x3c(%esp)
  108b45:	e8 46 97 ff ff       	call   102290 <trap_return>
}
  108b4a:	83 c4 2c             	add    $0x2c,%esp
  108b4d:	5b                   	pop    %ebx
  108b4e:	5e                   	pop    %esi
  108b4f:	5f                   	pop    %edi
  108b50:	5d                   	pop    %ebp
  108b51:	c3                   	ret
  108b52:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        set_pdir_base(0);  // switch to the kernel's page table
  108b58:	83 ec 0c             	sub    $0xc,%esp
  108b5b:	6a 00                	push   $0x0
  108b5d:	e8 2e e1 ff ff       	call   106c90 <set_pdir_base>
        last_active[cpu_idx] = 0;
  108b62:	c7 44 b5 00 00 00 00 	movl   $0x0,0x0(%ebp,%esi,4)
  108b69:	00 
  108b6a:	83 c4 10             	add    $0x10,%esp
  108b6d:	eb a1                	jmp    108b10 <trap+0x30>
  108b6f:	90                   	nop
        kstack_switch(cur_pid);
  108b70:	83 ec 0c             	sub    $0xc,%esp
  108b73:	ff 74 24 18          	push   0x18(%esp)
  108b77:	e8 b4 c4 ff ff       	call   105030 <kstack_switch>
        set_pdir_base(cur_pid);
  108b7c:	58                   	pop    %eax
  108b7d:	ff 74 24 18          	push   0x18(%esp)
  108b81:	e8 0a e1 ff ff       	call   106c90 <set_pdir_base>
        last_active[cpu_idx] = last_pid;
  108b86:	89 7c b5 00          	mov    %edi,0x0(%ebp,%esi,4)
  108b8a:	83 c4 10             	add    $0x10,%esp
  108b8d:	eb af                	jmp    108b3e <trap+0x5e>
  108b8f:	90                   	nop
        KERN_WARN("No handler for user trap 0x%x, process %d, eip 0x%08x.\n",
  108b90:	83 ec 08             	sub    $0x8,%esp
  108b93:	8b 44 24 38          	mov    0x38(%esp),%eax
  108b97:	ff 70 30             	push   0x30(%eax)
  108b9a:	8d 83 4c 73 ff ff    	lea    -0x8cb4(%ebx),%eax
  108ba0:	ff 74 24 18          	push   0x18(%esp)
  108ba4:	52                   	push   %edx
  108ba5:	50                   	push   %eax
  108ba6:	8d 83 b8 72 ff ff    	lea    -0x8d48(%ebx),%eax
  108bac:	68 9c 00 00 00       	push   $0x9c
  108bb1:	50                   	push   %eax
  108bb2:	e8 49 bd ff ff       	call   104900 <debug_warn>
  108bb7:	83 c4 20             	add    $0x20,%esp
  108bba:	e9 7b ff ff ff       	jmp    108b3a <trap+0x5a>
  108bbf:	90                   	nop

00108bc0 <trap_init_array>:
int inited = FALSE;

trap_cb_t TRAP_HANDLER[NUM_CPUS][256];

void trap_init_array(void)
{
  108bc0:	53                   	push   %ebx
  108bc1:	e8 dc 77 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108bc6:	81 c3 2e e4 00 00    	add    $0xe42e,%ebx
  108bcc:	83 ec 08             	sub    $0x8,%esp
    KERN_ASSERT(inited == FALSE);
  108bcf:	8b 83 4c 90 d5 00    	mov    0xd5904c(%ebx),%eax
  108bd5:	85 c0                	test   %eax,%eax
  108bd7:	75 27                	jne    108c00 <trap_init_array+0x40>
    memzero(&TRAP_HANDLER, sizeof(trap_cb_t) * 8 * 256);
  108bd9:	83 ec 08             	sub    $0x8,%esp
  108bdc:	8d 83 4c 70 d5 00    	lea    0xd5704c(%ebx),%eax
  108be2:	68 00 20 00 00       	push   $0x2000
  108be7:	50                   	push   %eax
  108be8:	e8 13 ba ff ff       	call   104600 <memzero>
    inited = TRUE;
  108bed:	c7 83 4c 90 d5 00 01 	movl   $0x1,0xd5904c(%ebx)
  108bf4:	00 00 00 
}
  108bf7:	83 c4 18             	add    $0x18,%esp
  108bfa:	5b                   	pop    %ebx
  108bfb:	c3                   	ret
  108bfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    KERN_ASSERT(inited == FALSE);
  108c00:	8d 83 96 67 ff ff    	lea    -0x986a(%ebx),%eax
  108c06:	50                   	push   %eax
  108c07:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  108c0d:	50                   	push   %eax
  108c0e:	8d 83 84 73 ff ff    	lea    -0x8c7c(%ebx),%eax
  108c14:	6a 11                	push   $0x11
  108c16:	50                   	push   %eax
  108c17:	e8 d4 bb ff ff       	call   1047f0 <debug_panic>
  108c1c:	83 c4 10             	add    $0x10,%esp
  108c1f:	eb b8                	jmp    108bd9 <trap_init_array+0x19>
  108c21:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  108c28:	00 
  108c29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00108c30 <trap_handler_register>:

void trap_handler_register(int cpu_idx, int trapno, trap_cb_t cb)
{
  108c30:	55                   	push   %ebp
  108c31:	57                   	push   %edi
  108c32:	56                   	push   %esi
  108c33:	53                   	push   %ebx
  108c34:	e8 69 77 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108c39:	81 c3 bb e3 00 00    	add    $0xe3bb,%ebx
  108c3f:	83 ec 0c             	sub    $0xc,%esp
  108c42:	8b 74 24 20          	mov    0x20(%esp),%esi
  108c46:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  108c4a:	8b 7c 24 28          	mov    0x28(%esp),%edi
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < 8);
  108c4e:	83 fe 07             	cmp    $0x7,%esi
  108c51:	77 25                	ja     108c78 <trap_handler_register+0x48>
    KERN_ASSERT(0 <= trapno && trapno < 256);
  108c53:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  108c59:	77 44                	ja     108c9f <trap_handler_register+0x6f>
    KERN_ASSERT(cb != NULL);
  108c5b:	85 ff                	test   %edi,%edi
  108c5d:	74 63                	je     108cc2 <trap_handler_register+0x92>

    TRAP_HANDLER[cpu_idx][trapno] = cb;
  108c5f:	c1 e6 08             	shl    $0x8,%esi
  108c62:	01 ee                	add    %ebp,%esi
  108c64:	89 bc b3 4c 70 d5 00 	mov    %edi,0xd5704c(%ebx,%esi,4)
}
  108c6b:	83 c4 0c             	add    $0xc,%esp
  108c6e:	5b                   	pop    %ebx
  108c6f:	5e                   	pop    %esi
  108c70:	5f                   	pop    %edi
  108c71:	5d                   	pop    %ebp
  108c72:	c3                   	ret
  108c73:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < 8);
  108c78:	8d 83 a6 67 ff ff    	lea    -0x985a(%ebx),%eax
  108c7e:	50                   	push   %eax
  108c7f:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  108c85:	50                   	push   %eax
  108c86:	8d 83 84 73 ff ff    	lea    -0x8c7c(%ebx),%eax
  108c8c:	6a 18                	push   $0x18
  108c8e:	50                   	push   %eax
  108c8f:	e8 5c bb ff ff       	call   1047f0 <debug_panic>
  108c94:	83 c4 10             	add    $0x10,%esp
    KERN_ASSERT(0 <= trapno && trapno < 256);
  108c97:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  108c9d:	76 bc                	jbe    108c5b <trap_handler_register+0x2b>
  108c9f:	8d 83 c2 67 ff ff    	lea    -0x983e(%ebx),%eax
  108ca5:	50                   	push   %eax
  108ca6:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  108cac:	50                   	push   %eax
  108cad:	8d 83 84 73 ff ff    	lea    -0x8c7c(%ebx),%eax
  108cb3:	6a 19                	push   $0x19
  108cb5:	50                   	push   %eax
  108cb6:	e8 35 bb ff ff       	call   1047f0 <debug_panic>
  108cbb:	83 c4 10             	add    $0x10,%esp
    KERN_ASSERT(cb != NULL);
  108cbe:	85 ff                	test   %edi,%edi
  108cc0:	75 9d                	jne    108c5f <trap_handler_register+0x2f>
  108cc2:	8d 83 de 67 ff ff    	lea    -0x9822(%ebx),%eax
  108cc8:	50                   	push   %eax
  108cc9:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  108ccf:	50                   	push   %eax
  108cd0:	8d 83 84 73 ff ff    	lea    -0x8c7c(%ebx),%eax
  108cd6:	6a 1a                	push   $0x1a
  108cd8:	50                   	push   %eax
  108cd9:	e8 12 bb ff ff       	call   1047f0 <debug_panic>
  108cde:	83 c4 10             	add    $0x10,%esp
  108ce1:	e9 79 ff ff ff       	jmp    108c5f <trap_handler_register+0x2f>
  108ce6:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  108ced:	00 
  108cee:	66 90                	xchg   %ax,%ax

00108cf0 <trap_init>:

void trap_init(unsigned int cpu_idx)
{
  108cf0:	55                   	push   %ebp
  108cf1:	57                   	push   %edi
  108cf2:	56                   	push   %esi
  108cf3:	53                   	push   %ebx
  108cf4:	e8 a9 76 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  108cf9:	81 c3 fb e2 00 00    	add    $0xe2fb,%ebx
  108cff:	83 ec 1c             	sub    $0x1c,%esp
    int trapno;

    if (cpu_idx == 0) {
  108d02:	8b 7c 24 30          	mov    0x30(%esp),%edi
  108d06:	85 ff                	test   %edi,%edi
  108d08:	0f 84 62 02 00 00    	je     108f70 <trap_init+0x280>
        trap_init_array();
    }

    KERN_INFO_CPU("Register trap handlers...\n", cpu_idx);
  108d0e:	83 ec 08             	sub    $0x8,%esp
  108d11:	8d 83 a4 73 ff ff    	lea    -0x8c5c(%ebx),%eax
  108d17:	ff 74 24 38          	push   0x38(%esp)
  108d1b:	50                   	push   %eax
  108d1c:	e8 2f ba ff ff       	call   104750 <debug_info>
  108d21:	83 c4 10             	add    $0x10,%esp
  108d24:	8d 83 4c 70 d5 00    	lea    0xd5704c(%ebx),%eax
  108d2a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  108d2e:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  108d32:	8b 44 24 0c          	mov    0xc(%esp),%eax

    for (trapno = 0; trapno < 256; trapno++) {
        // Exceptions
        if ((T_DIVIDE <= trapno && trapno <= T_SIMD) || trapno == T_SECEV) {
            trap_handler_register(cpu_idx, trapno, exception_handler);
  108d36:	31 f6                	xor    %esi,%esi
  108d38:	c1 e5 0a             	shl    $0xa,%ebp
  108d3b:	01 c5                	add    %eax,%ebp
  108d3d:	c7 c0 10 8a 10 00    	mov    $0x108a10,%eax
  108d43:	89 04 24             	mov    %eax,(%esp)
  108d46:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  108d4d:	00 
  108d4e:	66 90                	xchg   %ax,%ax
        if ((T_DIVIDE <= trapno && trapno <= T_SIMD) || trapno == T_SECEV) {
  108d50:	89 f7                	mov    %esi,%edi
  108d52:	83 fe 13             	cmp    $0x13,%esi
  108d55:	0f 86 b2 00 00 00    	jbe    108e0d <trap_init+0x11d>
  108d5b:	83 fe 1e             	cmp    $0x1e,%esi
  108d5e:	0f 84 a9 00 00 00    	je     108e0d <trap_init+0x11d>
        }
        // Interrupts
        else if ((T_IRQ0 + IRQ_TIMER <= trapno && trapno <= T_IRQ0 + IRQ_RTC)
  108d64:	8d 47 e0             	lea    -0x20(%edi),%eax
  108d67:	83 f8 17             	cmp    $0x17,%eax
  108d6a:	76 74                	jbe    108de0 <trap_init+0xf0>
    for (trapno = 0; trapno < 256; trapno++) {
  108d6c:	83 c6 01             	add    $0x1,%esi
  108d6f:	81 fe 00 01 00 00    	cmp    $0x100,%esi
  108d75:	75 d9                	jne    108d50 <trap_init+0x60>
        else if (trapno == T_SYSCALL) {
            trap_handler_register(cpu_idx, trapno, syscall_dispatch);
        }
    }

    KERN_INFO_CPU("Done.\n", cpu_idx);
  108d77:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  108d7b:	85 c9                	test   %ecx,%ecx
  108d7d:	0f 85 7d 01 00 00    	jne    108f00 <trap_init+0x210>
  108d83:	83 ec 0c             	sub    $0xc,%esp
  108d86:	8d b3 e9 67 ff ff    	lea    -0x9817(%ebx),%esi
  108d8c:	56                   	push   %esi
  108d8d:	e8 be b9 ff ff       	call   104750 <debug_info>
    KERN_INFO_CPU("Enabling interrupts...\n", cpu_idx);
  108d92:	8d 83 f4 73 ff ff    	lea    -0x8c0c(%ebx),%eax
  108d98:	89 04 24             	mov    %eax,(%esp)
  108d9b:	e8 b0 b9 ff ff       	call   104750 <debug_info>

    /* enable interrupts */
    intr_enable(IRQ_TIMER, cpu_idx);
  108da0:	58                   	pop    %eax
  108da1:	5a                   	pop    %edx
  108da2:	6a 00                	push   $0x0
  108da4:	6a 00                	push   $0x0
  108da6:	e8 45 8a ff ff       	call   1017f0 <intr_enable>
    intr_enable(IRQ_KBD, cpu_idx);
  108dab:	59                   	pop    %ecx
  108dac:	5f                   	pop    %edi
  108dad:	6a 00                	push   $0x0
  108daf:	6a 01                	push   $0x1
  108db1:	e8 3a 8a ff ff       	call   1017f0 <intr_enable>
    intr_enable(IRQ_SERIAL13, cpu_idx);
  108db6:	5d                   	pop    %ebp
  108db7:	58                   	pop    %eax
  108db8:	6a 00                	push   $0x0
  108dba:	6a 04                	push   $0x4
  108dbc:	e8 2f 8a ff ff       	call   1017f0 <intr_enable>
    intr_enable(IRQ_IDE1, cpu_idx);
  108dc1:	58                   	pop    %eax
  108dc2:	5a                   	pop    %edx
  108dc3:	6a 00                	push   $0x0
  108dc5:	6a 0e                	push   $0xe
  108dc7:	e8 24 8a ff ff       	call   1017f0 <intr_enable>

    KERN_INFO_CPU("Done.\n", cpu_idx);
  108dcc:	89 34 24             	mov    %esi,(%esp)
  108dcf:	e8 7c b9 ff ff       	call   104750 <debug_info>
  108dd4:	83 c4 10             	add    $0x10,%esp
}
  108dd7:	83 c4 1c             	add    $0x1c,%esp
  108dda:	5b                   	pop    %ebx
  108ddb:	5e                   	pop    %esi
  108ddc:	5f                   	pop    %edi
  108ddd:	5d                   	pop    %ebp
  108dde:	c3                   	ret
  108ddf:	90                   	nop
        else if ((T_IRQ0 + IRQ_TIMER <= trapno && trapno <= T_IRQ0 + IRQ_RTC)
  108de0:	ba 00 0e 71 ff       	mov    $0xff710e00,%edx
  108de5:	0f a3 c2             	bt     %eax,%edx
  108de8:	0f 82 ba 00 00 00    	jb     108ea8 <trap_init+0x1b8>
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < 8);
  108dee:	83 7c 24 30 07       	cmpl   $0x7,0x30(%esp)
  108df3:	77 3b                	ja     108e30 <trap_init+0x140>
    TRAP_HANDLER[cpu_idx][trapno] = cb;
  108df5:	c7 c0 70 8a 10 00    	mov    $0x108a70,%eax
    for (trapno = 0; trapno < 256; trapno++) {
  108dfb:	83 c6 01             	add    $0x1,%esi
    TRAP_HANDLER[cpu_idx][trapno] = cb;
  108dfe:	89 44 bd 00          	mov    %eax,0x0(%ebp,%edi,4)
        if ((T_DIVIDE <= trapno && trapno <= T_SIMD) || trapno == T_SECEV) {
  108e02:	89 f7                	mov    %esi,%edi
  108e04:	83 fe 13             	cmp    $0x13,%esi
  108e07:	0f 87 4e ff ff ff    	ja     108d5b <trap_init+0x6b>
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < 8);
  108e0d:	83 7c 24 30 07       	cmpl   $0x7,0x30(%esp)
  108e12:	77 44                	ja     108e58 <trap_init+0x168>
    TRAP_HANDLER[cpu_idx][trapno] = cb;
  108e14:	8b 04 24             	mov    (%esp),%eax
  108e17:	89 44 b5 00          	mov    %eax,0x0(%ebp,%esi,4)
    for (trapno = 0; trapno < 256; trapno++) {
  108e1b:	83 c6 01             	add    $0x1,%esi
        if ((T_DIVIDE <= trapno && trapno <= T_SIMD) || trapno == T_SECEV) {
  108e1e:	89 f7                	mov    %esi,%edi
  108e20:	83 fe 13             	cmp    $0x13,%esi
  108e23:	0f 87 3b ff ff ff    	ja     108d64 <trap_init+0x74>
  108e29:	eb e9                	jmp    108e14 <trap_init+0x124>
  108e2b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < 8);
  108e30:	8d 8b a6 67 ff ff    	lea    -0x985a(%ebx),%ecx
  108e36:	8d 93 b8 60 ff ff    	lea    -0x9f48(%ebx),%edx
  108e3c:	8d 83 84 73 ff ff    	lea    -0x8c7c(%ebx),%eax
  108e42:	51                   	push   %ecx
  108e43:	52                   	push   %edx
  108e44:	6a 18                	push   $0x18
  108e46:	50                   	push   %eax
  108e47:	e8 a4 b9 ff ff       	call   1047f0 <debug_panic>
  108e4c:	83 c4 10             	add    $0x10,%esp
  108e4f:	eb a4                	jmp    108df5 <trap_init+0x105>
  108e51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  108e58:	8d 93 b8 60 ff ff    	lea    -0x9f48(%ebx),%edx
  108e5e:	8d 83 84 73 ff ff    	lea    -0x8c7c(%ebx),%eax
  108e64:	89 f7                	mov    %esi,%edi
  108e66:	89 ee                	mov    %ebp,%esi
  108e68:	89 54 24 04          	mov    %edx,0x4(%esp)
  108e6c:	8d 8b a6 67 ff ff    	lea    -0x985a(%ebx),%ecx
  108e72:	89 44 24 08          	mov    %eax,0x8(%esp)
  108e76:	89 cd                	mov    %ecx,%ebp
  108e78:	55                   	push   %ebp
  108e79:	ff 74 24 08          	push   0x8(%esp)
  108e7d:	6a 18                	push   $0x18
  108e7f:	ff 74 24 14          	push   0x14(%esp)
  108e83:	e8 68 b9 ff ff       	call   1047f0 <debug_panic>
    TRAP_HANDLER[cpu_idx][trapno] = cb;
  108e88:	8b 44 24 10          	mov    0x10(%esp),%eax
        if ((T_DIVIDE <= trapno && trapno <= T_SIMD) || trapno == T_SECEV) {
  108e8c:	83 c4 10             	add    $0x10,%esp
    TRAP_HANDLER[cpu_idx][trapno] = cb;
  108e8f:	89 04 be             	mov    %eax,(%esi,%edi,4)
    for (trapno = 0; trapno < 256; trapno++) {
  108e92:	83 c7 01             	add    $0x1,%edi
        if ((T_DIVIDE <= trapno && trapno <= T_SIMD) || trapno == T_SECEV) {
  108e95:	83 ff 13             	cmp    $0x13,%edi
  108e98:	76 de                	jbe    108e78 <trap_init+0x188>
  108e9a:	89 f5                	mov    %esi,%ebp
  108e9c:	89 fe                	mov    %edi,%esi
  108e9e:	e9 c1 fe ff ff       	jmp    108d64 <trap_init+0x74>
  108ea3:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        else if (trapno == T_SYSCALL) {
  108ea8:	83 fe 30             	cmp    $0x30,%esi
  108eab:	0f 85 22 01 00 00    	jne    108fd3 <trap_init+0x2e3>
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < 8);
  108eb1:	83 7c 24 30 07       	cmpl   $0x7,0x30(%esp)
  108eb6:	77 27                	ja     108edf <trap_init+0x1ef>
    TRAP_HANDLER[cpu_idx][trapno] = cb;
  108eb8:	8b 44 24 30          	mov    0x30(%esp),%eax
  108ebc:	c7 c2 a0 85 10 00    	mov    $0x1085a0,%edx
  108ec2:	bf 31 00 00 00       	mov    $0x31,%edi
  108ec7:	be 31 00 00 00       	mov    $0x31,%esi
  108ecc:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  108ed0:	c1 e0 0a             	shl    $0xa,%eax
  108ed3:	89 94 08 c0 00 00 00 	mov    %edx,0xc0(%eax,%ecx,1)
  108eda:	e9 85 fe ff ff       	jmp    108d64 <trap_init+0x74>
    KERN_ASSERT(0 <= cpu_idx && cpu_idx < 8);
  108edf:	8d 83 a6 67 ff ff    	lea    -0x985a(%ebx),%eax
  108ee5:	50                   	push   %eax
  108ee6:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  108eec:	50                   	push   %eax
  108eed:	8d 83 84 73 ff ff    	lea    -0x8c7c(%ebx),%eax
  108ef3:	6a 18                	push   $0x18
  108ef5:	50                   	push   %eax
  108ef6:	e8 f5 b8 ff ff       	call   1047f0 <debug_panic>
  108efb:	83 c4 10             	add    $0x10,%esp
  108efe:	eb b8                	jmp    108eb8 <trap_init+0x1c8>
    KERN_INFO_CPU("Done.\n", cpu_idx);
  108f00:	83 ec 08             	sub    $0x8,%esp
  108f03:	8d b3 fb 67 ff ff    	lea    -0x9805(%ebx),%esi
  108f09:	ff 74 24 38          	push   0x38(%esp)
  108f0d:	56                   	push   %esi
  108f0e:	e8 3d b8 ff ff       	call   104750 <debug_info>
    KERN_INFO_CPU("Enabling interrupts...\n", cpu_idx);
  108f13:	58                   	pop    %eax
  108f14:	8d 83 18 74 ff ff    	lea    -0x8be8(%ebx),%eax
  108f1a:	5a                   	pop    %edx
  108f1b:	ff 74 24 38          	push   0x38(%esp)
  108f1f:	50                   	push   %eax
  108f20:	e8 2b b8 ff ff       	call   104750 <debug_info>
    intr_enable(IRQ_TIMER, cpu_idx);
  108f25:	59                   	pop    %ecx
  108f26:	5f                   	pop    %edi
  108f27:	ff 74 24 38          	push   0x38(%esp)
  108f2b:	6a 00                	push   $0x0
  108f2d:	e8 be 88 ff ff       	call   1017f0 <intr_enable>
    intr_enable(IRQ_KBD, cpu_idx);
  108f32:	5d                   	pop    %ebp
  108f33:	58                   	pop    %eax
  108f34:	ff 74 24 38          	push   0x38(%esp)
  108f38:	6a 01                	push   $0x1
  108f3a:	e8 b1 88 ff ff       	call   1017f0 <intr_enable>
    intr_enable(IRQ_SERIAL13, cpu_idx);
  108f3f:	58                   	pop    %eax
  108f40:	5a                   	pop    %edx
  108f41:	ff 74 24 38          	push   0x38(%esp)
  108f45:	6a 04                	push   $0x4
  108f47:	e8 a4 88 ff ff       	call   1017f0 <intr_enable>
    intr_enable(IRQ_IDE1, cpu_idx);
  108f4c:	59                   	pop    %ecx
  108f4d:	5f                   	pop    %edi
  108f4e:	ff 74 24 38          	push   0x38(%esp)
  108f52:	6a 0e                	push   $0xe
  108f54:	e8 97 88 ff ff       	call   1017f0 <intr_enable>
    KERN_INFO_CPU("Done.\n", cpu_idx);
  108f59:	5d                   	pop    %ebp
  108f5a:	58                   	pop    %eax
  108f5b:	ff 74 24 38          	push   0x38(%esp)
  108f5f:	56                   	push   %esi
  108f60:	e8 eb b7 ff ff       	call   104750 <debug_info>
  108f65:	83 c4 10             	add    $0x10,%esp
}
  108f68:	83 c4 1c             	add    $0x1c,%esp
  108f6b:	5b                   	pop    %ebx
  108f6c:	5e                   	pop    %esi
  108f6d:	5f                   	pop    %edi
  108f6e:	5d                   	pop    %ebp
  108f6f:	c3                   	ret
    KERN_ASSERT(inited == FALSE);
  108f70:	8b b3 4c 90 d5 00    	mov    0xd5904c(%ebx),%esi
  108f76:	85 f6                	test   %esi,%esi
  108f78:	75 38                	jne    108fb2 <trap_init+0x2c2>
    memzero(&TRAP_HANDLER, sizeof(trap_cb_t) * 8 * 256);
  108f7a:	83 ec 08             	sub    $0x8,%esp
  108f7d:	8d 83 4c 70 d5 00    	lea    0xd5704c(%ebx),%eax
  108f83:	68 00 20 00 00       	push   $0x2000
  108f88:	89 44 24 18          	mov    %eax,0x18(%esp)
  108f8c:	50                   	push   %eax
  108f8d:	e8 6e b6 ff ff       	call   104600 <memzero>
    KERN_INFO_CPU("Register trap handlers...\n", cpu_idx);
  108f92:	8d 83 cc 73 ff ff    	lea    -0x8c34(%ebx),%eax
    inited = TRUE;
  108f98:	c7 83 4c 90 d5 00 01 	movl   $0x1,0xd5904c(%ebx)
  108f9f:	00 00 00 
    KERN_INFO_CPU("Register trap handlers...\n", cpu_idx);
  108fa2:	89 04 24             	mov    %eax,(%esp)
  108fa5:	e8 a6 b7 ff ff       	call   104750 <debug_info>
  108faa:	83 c4 10             	add    $0x10,%esp
  108fad:	e9 7c fd ff ff       	jmp    108d2e <trap_init+0x3e>
    KERN_ASSERT(inited == FALSE);
  108fb2:	8d 83 96 67 ff ff    	lea    -0x986a(%ebx),%eax
  108fb8:	50                   	push   %eax
  108fb9:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  108fbf:	50                   	push   %eax
  108fc0:	8d 83 84 73 ff ff    	lea    -0x8c7c(%ebx),%eax
  108fc6:	6a 11                	push   $0x11
  108fc8:	50                   	push   %eax
  108fc9:	e8 22 b8 ff ff       	call   1047f0 <debug_panic>
  108fce:	83 c4 10             	add    $0x10,%esp
  108fd1:	eb a7                	jmp    108f7a <trap_init+0x28a>
    for (trapno = 0; trapno < 256; trapno++) {
  108fd3:	83 c6 01             	add    $0x1,%esi
  108fd6:	e9 75 fd ff ff       	jmp    108d50 <trap_init+0x60>
  108fdb:	66 90                	xchg   %ax,%ax
  108fdd:	66 90                	xchg   %ax,%ax
  108fdf:	90                   	nop

00108fe0 <bufcache_init>:
    // head.next is most recently used.
    struct buf head;
} bcache;

void bufcache_init(void)
{
  108fe0:	57                   	push   %edi
  108fe1:	56                   	push   %esi
  108fe2:	e8 ce ab ff ff       	call   103bb5 <__x86.get_pc_thunk.si>
  108fe7:	81 c6 0d e0 00 00    	add    $0xe00d,%esi
  108fed:	53                   	push   %ebx
    struct buf *b;

    spinlock_init(&bcache.lock);
  108fee:	83 ec 0c             	sub    $0xc,%esp
  108ff1:	8d be 6c 90 d5 00    	lea    0xd5906c(%esi),%edi
  108ff7:	89 f3                	mov    %esi,%ebx
  108ff9:	57                   	push   %edi
  108ffa:	e8 c1 ce ff ff       	call   105ec0 <spinlock_init>

    // Create linked list of buffers
    bcache.head.prev = &bcache.head;
  108fff:	8d 97 f8 14 00 00    	lea    0x14f8(%edi),%edx
  109005:	83 c4 10             	add    $0x10,%esp
    bcache.head.next = &bcache.head;
    for (b = bcache.buf; b < bcache.buf + NBUF; b++) {
  109008:	8d 47 08             	lea    0x8(%edi),%eax
    bcache.head.prev = &bcache.head;
  10900b:	89 96 70 a5 d5 00    	mov    %edx,0xd5a570(%esi)
    for (b = bcache.buf; b < bcache.buf + NBUF; b++) {
  109011:	8d 9e 64 a5 d5 00    	lea    0xd5a564(%esi),%ebx
  109017:	eb 09                	jmp    109022 <bufcache_init+0x42>
  109019:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  109020:	89 c8                	mov    %ecx,%eax
  109022:	8d 88 18 02 00 00    	lea    0x218(%eax),%ecx
        b->next = bcache.head.next;
  109028:	89 50 10             	mov    %edx,0x10(%eax)
        b->prev = &bcache.head;
  10902b:	89 58 0c             	mov    %ebx,0xc(%eax)
        b->dev = -1;
  10902e:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%eax)
        bcache.head.next->prev = b;
  109035:	89 42 0c             	mov    %eax,0xc(%edx)
    for (b = bcache.buf; b < bcache.buf + NBUF; b++) {
  109038:	89 c2                	mov    %eax,%edx
  10903a:	39 d9                	cmp    %ebx,%ecx
  10903c:	75 e2                	jne    109020 <bufcache_init+0x40>
        bcache.head.next = b;
    }
}
  10903e:	5b                   	pop    %ebx
  10903f:	89 86 74 a5 d5 00    	mov    %eax,0xd5a574(%esi)
  109045:	5e                   	pop    %esi
  109046:	5f                   	pop    %edi
  109047:	c3                   	ret
  109048:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10904f:	00 

00109050 <bufcache_read>:

/**
 * Return a B_BUSY buf with the contents of the indicated disk sector.
 */
struct buf *bufcache_read(uint32_t dev, uint32_t sector)
{
  109050:	55                   	push   %ebp
  109051:	57                   	push   %edi
  109052:	56                   	push   %esi
  109053:	53                   	push   %ebx
  109054:	e8 49 73 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109059:	81 c3 9b df 00 00    	add    $0xdf9b,%ebx
  10905f:	83 ec 28             	sub    $0x28,%esp
  109062:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
    spinlock_acquire(&bcache.lock);
  109066:	8d 83 6c 90 d5 00    	lea    0xd5906c(%ebx),%eax
  10906c:	8d bb 64 a5 d5 00    	lea    0xd5a564(%ebx),%edi
  109072:	89 44 24 14          	mov    %eax,0x14(%esp)
  109076:	50                   	push   %eax
  109077:	e8 d4 ce ff ff       	call   105f50 <spinlock_acquire>
  10907c:	8b 44 24 44          	mov    0x44(%esp),%eax
  109080:	83 c4 10             	add    $0x10,%esp
  109083:	8d 15 6c 90 d5 00    	lea    0xd5906c,%edx
    for (b = bcache.head.next; b != &bcache.head; b = b->next) {
  109089:	8b b4 1a 08 15 00 00 	mov    0x1508(%edx,%ebx,1),%esi
  109090:	39 fe                	cmp    %edi,%esi
  109092:	75 13                	jne    1090a7 <bufcache_read+0x57>
  109094:	eb 4a                	jmp    1090e0 <bufcache_read+0x90>
  109096:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10909d:	00 
  10909e:	66 90                	xchg   %ax,%ax
  1090a0:	8b 76 10             	mov    0x10(%esi),%esi
  1090a3:	39 fe                	cmp    %edi,%esi
  1090a5:	74 39                	je     1090e0 <bufcache_read+0x90>
        if (b->dev == dev && b->sector == sector) {
  1090a7:	3b 6e 04             	cmp    0x4(%esi),%ebp
  1090aa:	75 f4                	jne    1090a0 <bufcache_read+0x50>
  1090ac:	3b 46 08             	cmp    0x8(%esi),%eax
  1090af:	75 ef                	jne    1090a0 <bufcache_read+0x50>
            if (!(b->flags & B_BUSY)) {
  1090b1:	8b 0e                	mov    (%esi),%ecx
  1090b3:	f6 c1 01             	test   $0x1,%cl
  1090b6:	0f 84 8a 00 00 00    	je     109146 <bufcache_read+0xf6>
  1090bc:	89 54 24 0c          	mov    %edx,0xc(%esp)
            thread_sleep(b, &bcache.lock);
  1090c0:	83 ec 08             	sub    $0x8,%esp
  1090c3:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  1090c7:	ff 74 24 10          	push   0x10(%esp)
  1090cb:	56                   	push   %esi
  1090cc:	e8 bf eb ff ff       	call   107c90 <thread_sleep>
            goto loop;
  1090d1:	83 c4 10             	add    $0x10,%esp
  1090d4:	8b 44 24 34          	mov    0x34(%esp),%eax
  1090d8:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1090dc:	eb ab                	jmp    109089 <bufcache_read+0x39>
  1090de:	66 90                	xchg   %ax,%ax
    for (b = bcache.head.prev; b != &bcache.head; b = b->prev) {
  1090e0:	8b b3 70 a5 d5 00    	mov    0xd5a570(%ebx),%esi
  1090e6:	39 fe                	cmp    %edi,%esi
  1090e8:	75 0d                	jne    1090f7 <bufcache_read+0xa7>
  1090ea:	eb 70                	jmp    10915c <bufcache_read+0x10c>
  1090ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  1090f0:	8b 76 0c             	mov    0xc(%esi),%esi
  1090f3:	39 fe                	cmp    %edi,%esi
  1090f5:	74 65                	je     10915c <bufcache_read+0x10c>
        if ((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0) {
  1090f7:	f6 06 05             	testb  $0x5,(%esi)
  1090fa:	75 f4                	jne    1090f0 <bufcache_read+0xa0>
            spinlock_release(&bcache.lock);
  1090fc:	83 ec 0c             	sub    $0xc,%esp
            b->dev = dev;
  1090ff:	89 6e 04             	mov    %ebp,0x4(%esi)
            b->sector = sector;
  109102:	89 46 08             	mov    %eax,0x8(%esi)
            b->flags = B_BUSY;
  109105:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
            spinlock_release(&bcache.lock);
  10910b:	ff 74 24 14          	push   0x14(%esp)
  10910f:	e8 bc ce ff ff       	call   105fd0 <spinlock_release>
            return b;
  109114:	83 c4 10             	add    $0x10,%esp
    struct buf *b;

    b = bufcache_get(dev, sector);
    if (!(b->flags & B_VALID)) {
  109117:	f6 06 02             	testb  $0x2,(%esi)
  10911a:	74 14                	je     109130 <bufcache_read+0xe0>
        ide_rw(b);
    }
    return b;
}
  10911c:	83 c4 1c             	add    $0x1c,%esp
  10911f:	89 f0                	mov    %esi,%eax
  109121:	5b                   	pop    %ebx
  109122:	5e                   	pop    %esi
  109123:	5f                   	pop    %edi
  109124:	5d                   	pop    %ebp
  109125:	c3                   	ret
  109126:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10912d:	00 
  10912e:	66 90                	xchg   %ax,%ax
        ide_rw(b);
  109130:	83 ec 0c             	sub    $0xc,%esp
  109133:	56                   	push   %esi
  109134:	e8 57 af ff ff       	call   104090 <ide_rw>
  109139:	83 c4 10             	add    $0x10,%esp
}
  10913c:	89 f0                	mov    %esi,%eax
  10913e:	83 c4 1c             	add    $0x1c,%esp
  109141:	5b                   	pop    %ebx
  109142:	5e                   	pop    %esi
  109143:	5f                   	pop    %edi
  109144:	5d                   	pop    %ebp
  109145:	c3                   	ret
                spinlock_release(&bcache.lock);
  109146:	83 ec 0c             	sub    $0xc,%esp
                b->flags |= B_BUSY;
  109149:	83 c9 01             	or     $0x1,%ecx
  10914c:	89 0e                	mov    %ecx,(%esi)
                spinlock_release(&bcache.lock);
  10914e:	ff 74 24 14          	push   0x14(%esp)
  109152:	e8 79 ce ff ff       	call   105fd0 <spinlock_release>
                return b;
  109157:	83 c4 10             	add    $0x10,%esp
  10915a:	eb bb                	jmp    109117 <bufcache_read+0xc7>
    KERN_PANIC("bufcache_get: no buffers");
  10915c:	50                   	push   %eax
  10915d:	8d 83 0e 68 ff ff    	lea    -0x97f2(%ebx),%eax
  109163:	50                   	push   %eax
  109164:	8d 83 27 68 ff ff    	lea    -0x97d9(%ebx),%eax
  10916a:	6a 5d                	push   $0x5d
  10916c:	50                   	push   %eax
  10916d:	e8 7e b6 ff ff       	call   1047f0 <debug_panic>
    if (!(b->flags & B_VALID)) {
  109172:	a1 00 00 00 00       	mov    0x0,%eax
  109177:	0f 0b                	ud2
  109179:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00109180 <bufcache_write>:

/**
 * Write b's contents to disk. Must be B_BUSY.
 */
void bufcache_write(struct buf *b)
{
  109180:	56                   	push   %esi
  109181:	53                   	push   %ebx
  109182:	e8 1b 72 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109187:	81 c3 6d de 00 00    	add    $0xde6d,%ebx
  10918d:	83 ec 04             	sub    $0x4,%esp
  109190:	8b 74 24 10          	mov    0x10(%esp),%esi
    if ((b->flags & B_BUSY) == 0)
  109194:	8b 06                	mov    (%esi),%eax
  109196:	a8 01                	test   $0x1,%al
  109198:	74 16                	je     1091b0 <bufcache_write+0x30>
        KERN_PANIC("bwrite");

    b->flags |= B_DIRTY;
    ide_rw(b);
  10919a:	83 ec 0c             	sub    $0xc,%esp
    b->flags |= B_DIRTY;
  10919d:	83 c8 04             	or     $0x4,%eax
  1091a0:	89 06                	mov    %eax,(%esi)
    ide_rw(b);
  1091a2:	56                   	push   %esi
  1091a3:	e8 e8 ae ff ff       	call   104090 <ide_rw>
}
  1091a8:	83 c4 14             	add    $0x14,%esp
  1091ab:	5b                   	pop    %ebx
  1091ac:	5e                   	pop    %esi
  1091ad:	c3                   	ret
  1091ae:	66 90                	xchg   %ax,%ax
        KERN_PANIC("bwrite");
  1091b0:	83 ec 04             	sub    $0x4,%esp
  1091b3:	8d 83 3a 68 ff ff    	lea    -0x97c6(%ebx),%eax
  1091b9:	50                   	push   %eax
  1091ba:	8d 83 27 68 ff ff    	lea    -0x97d9(%ebx),%eax
  1091c0:	6a 75                	push   $0x75
  1091c2:	50                   	push   %eax
  1091c3:	e8 28 b6 ff ff       	call   1047f0 <debug_panic>
    b->flags |= B_DIRTY;
  1091c8:	8b 06                	mov    (%esi),%eax
  1091ca:	83 c4 10             	add    $0x10,%esp
  1091cd:	eb cb                	jmp    10919a <bufcache_write+0x1a>
  1091cf:	90                   	nop

001091d0 <bufcache_release>:
/**
 * Release a B_BUSY buffer.
 * Move to the head of the MRU list.
 */
void bufcache_release(struct buf *b)
{
  1091d0:	57                   	push   %edi
  1091d1:	56                   	push   %esi
  1091d2:	53                   	push   %ebx
  1091d3:	8b 74 24 10          	mov    0x10(%esp),%esi
  1091d7:	e8 c6 71 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1091dc:	81 c3 18 de 00 00    	add    $0xde18,%ebx
    if ((b->flags & B_BUSY) == 0)
  1091e2:	f6 06 01             	testb  $0x1,(%esi)
  1091e5:	74 59                	je     109240 <bufcache_release+0x70>
        KERN_PANIC("brelse");

    spinlock_acquire(&bcache.lock);
  1091e7:	83 ec 0c             	sub    $0xc,%esp
  1091ea:	8d bb 6c 90 d5 00    	lea    0xd5906c(%ebx),%edi
  1091f0:	57                   	push   %edi
  1091f1:	e8 5a cd ff ff       	call   105f50 <spinlock_acquire>

    b->next->prev = b->prev;
  1091f6:	8b 56 10             	mov    0x10(%esi),%edx
  1091f9:	8b 46 0c             	mov    0xc(%esi),%eax
  1091fc:	89 42 0c             	mov    %eax,0xc(%edx)
    b->prev->next = b->next;
  1091ff:	89 50 10             	mov    %edx,0x10(%eax)
    b->next = bcache.head.next;
  109202:	8b 83 74 a5 d5 00    	mov    0xd5a574(%ebx),%eax
    b->prev = &bcache.head;
  109208:	8d 97 f8 14 00 00    	lea    0x14f8(%edi),%edx
  10920e:	89 56 0c             	mov    %edx,0xc(%esi)
    b->next = bcache.head.next;
  109211:	89 46 10             	mov    %eax,0x10(%esi)
    bcache.head.next->prev = b;
  109214:	89 70 0c             	mov    %esi,0xc(%eax)
    bcache.head.next = b;
  109217:	89 b3 74 a5 d5 00    	mov    %esi,0xd5a574(%ebx)

    b->flags &= ~B_BUSY;
  10921d:	83 26 fe             	andl   $0xfffffffe,(%esi)
    thread_wakeup(b);
  109220:	89 34 24             	mov    %esi,(%esp)
  109223:	e8 78 eb ff ff       	call   107da0 <thread_wakeup>

    spinlock_release(&bcache.lock);
  109228:	89 3c 24             	mov    %edi,(%esp)
  10922b:	e8 a0 cd ff ff       	call   105fd0 <spinlock_release>
}
  109230:	83 c4 10             	add    $0x10,%esp
  109233:	5b                   	pop    %ebx
  109234:	5e                   	pop    %esi
  109235:	5f                   	pop    %edi
  109236:	c3                   	ret
  109237:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10923e:	00 
  10923f:	90                   	nop
        KERN_PANIC("brelse");
  109240:	83 ec 04             	sub    $0x4,%esp
  109243:	8d 83 41 68 ff ff    	lea    -0x97bf(%ebx),%eax
  109249:	50                   	push   %eax
  10924a:	8d 83 27 68 ff ff    	lea    -0x97d9(%ebx),%eax
  109250:	68 82 00 00 00       	push   $0x82
  109255:	50                   	push   %eax
  109256:	e8 95 b5 ff ff       	call   1047f0 <debug_panic>
  10925b:	83 c4 10             	add    $0x10,%esp
  10925e:	eb 87                	jmp    1091e7 <bufcache_release+0x17>

00109260 <install_trans>:
    recover_from_log();
}

// Copy committed blocks from log to their home location.
static void install_trans(void)
{
  109260:	55                   	push   %ebp
  109261:	57                   	push   %edi
  109262:	56                   	push   %esi
  109263:	53                   	push   %ebx
  109264:	e8 39 71 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109269:	81 c3 8b dd 00 00    	add    $0xdd8b,%ebx
  10926f:	83 ec 1c             	sub    $0x1c,%esp
    int tail;

    for (tail = 0; tail < log.lh.n; tail++) {
  109272:	8b b3 a4 a7 d5 00    	mov    0xd5a7a4(%ebx),%esi
  109278:	85 f6                	test   %esi,%esi
  10927a:	7e 79                	jle    1092f5 <install_trans+0x95>
  10927c:	31 ed                	xor    %ebp,%ebp
  10927e:	8d 3d 8c a7 d5 00    	lea    0xd5a78c,%edi
  109284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        struct buf *lbuf = bufcache_read(log.dev, log.start + tail + 1);  // read log block
  109288:	8b 44 1f 08          	mov    0x8(%edi,%ebx,1),%eax
  10928c:	83 ec 08             	sub    $0x8,%esp
  10928f:	01 e8                	add    %ebp,%eax
  109291:	83 c0 01             	add    $0x1,%eax
  109294:	50                   	push   %eax
  109295:	ff 74 1f 14          	push   0x14(%edi,%ebx,1)
  109299:	e8 b2 fd ff ff       	call   109050 <bufcache_read>
  10929e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        struct buf *dbuf = bufcache_read(log.dev, log.lh.sector[tail]);   // read dst
  1092a2:	58                   	pop    %eax
  1092a3:	5a                   	pop    %edx
  1092a4:	ff b4 ab a8 a7 d5 00 	push   0xd5a7a8(%ebx,%ebp,4)
    for (tail = 0; tail < log.lh.n; tail++) {
  1092ab:	83 c5 01             	add    $0x1,%ebp
        struct buf *dbuf = bufcache_read(log.dev, log.lh.sector[tail]);   // read dst
  1092ae:	ff 74 1f 14          	push   0x14(%edi,%ebx,1)
  1092b2:	e8 99 fd ff ff       	call   109050 <bufcache_read>
        memmove(dbuf->data, lbuf->data, BSIZE);                           // copy block to dst
  1092b7:	83 c4 0c             	add    $0xc,%esp
  1092ba:	68 00 02 00 00       	push   $0x200
        struct buf *dbuf = bufcache_read(log.dev, log.lh.sector[tail]);   // read dst
  1092bf:	89 c6                	mov    %eax,%esi
        memmove(dbuf->data, lbuf->data, BSIZE);                           // copy block to dst
  1092c1:	8b 44 24 14          	mov    0x14(%esp),%eax
  1092c5:	83 c0 18             	add    $0x18,%eax
  1092c8:	50                   	push   %eax
  1092c9:	8d 46 18             	lea    0x18(%esi),%eax
  1092cc:	50                   	push   %eax
  1092cd:	e8 9e b1 ff ff       	call   104470 <memmove>
        bufcache_write(dbuf);                                             // write dst to disk
  1092d2:	89 34 24             	mov    %esi,(%esp)
  1092d5:	e8 a6 fe ff ff       	call   109180 <bufcache_write>
        bufcache_release(lbuf);
  1092da:	59                   	pop    %ecx
  1092db:	ff 74 24 18          	push   0x18(%esp)
  1092df:	e8 ec fe ff ff       	call   1091d0 <bufcache_release>
        bufcache_release(dbuf);
  1092e4:	89 34 24             	mov    %esi,(%esp)
  1092e7:	e8 e4 fe ff ff       	call   1091d0 <bufcache_release>
    for (tail = 0; tail < log.lh.n; tail++) {
  1092ec:	83 c4 10             	add    $0x10,%esp
  1092ef:	39 6c 1f 18          	cmp    %ebp,0x18(%edi,%ebx,1)
  1092f3:	7f 93                	jg     109288 <install_trans+0x28>
    }
}
  1092f5:	83 c4 1c             	add    $0x1c,%esp
  1092f8:	5b                   	pop    %ebx
  1092f9:	5e                   	pop    %esi
  1092fa:	5f                   	pop    %edi
  1092fb:	5d                   	pop    %ebp
  1092fc:	c3                   	ret
  1092fd:	8d 76 00             	lea    0x0(%esi),%esi

00109300 <write_head>:
}

// Write in-memory log header to disk.
// This is the true point at which the current transaction commits.
static void write_head(void)
{
  109300:	57                   	push   %edi
  109301:	56                   	push   %esi
  109302:	e8 ae a8 ff ff       	call   103bb5 <__x86.get_pc_thunk.si>
  109307:	81 c6 ed dc 00 00    	add    $0xdced,%esi
  10930d:	53                   	push   %ebx
    struct buf *buf = bufcache_read(log.dev, log.start);
  10930e:	83 ec 08             	sub    $0x8,%esp
  109311:	ff b6 94 a7 d5 00    	push   0xd5a794(%esi)
  109317:	89 f3                	mov    %esi,%ebx
  109319:	ff b6 a0 a7 d5 00    	push   0xd5a7a0(%esi)
  10931f:	e8 2c fd ff ff       	call   109050 <bufcache_read>
    struct logheader *hb = (struct logheader *) (buf->data);
    int i;
    hb->n = log.lh.n;
  109324:	8b 8e a4 a7 d5 00    	mov    0xd5a7a4(%esi),%ecx
    for (i = 0; i < log.lh.n; i++) {
  10932a:	83 c4 10             	add    $0x10,%esp
    struct buf *buf = bufcache_read(log.dev, log.start);
  10932d:	89 c7                	mov    %eax,%edi
    hb->n = log.lh.n;
  10932f:	89 48 18             	mov    %ecx,0x18(%eax)
    for (i = 0; i < log.lh.n; i++) {
  109332:	85 c9                	test   %ecx,%ecx
  109334:	7e 21                	jle    109357 <write_head+0x57>
  109336:	8d 96 a8 a7 d5 00    	lea    0xd5a7a8(%esi),%edx
  10933c:	8d 40 1c             	lea    0x1c(%eax),%eax
  10933f:	8d 5c 8f 1c          	lea    0x1c(%edi,%ecx,4),%ebx
  109343:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        hb->sector[i] = log.lh.sector[i];
  109348:	8b 0a                	mov    (%edx),%ecx
    for (i = 0; i < log.lh.n; i++) {
  10934a:	83 c0 04             	add    $0x4,%eax
  10934d:	83 c2 04             	add    $0x4,%edx
        hb->sector[i] = log.lh.sector[i];
  109350:	89 48 fc             	mov    %ecx,-0x4(%eax)
    for (i = 0; i < log.lh.n; i++) {
  109353:	39 d8                	cmp    %ebx,%eax
  109355:	75 f1                	jne    109348 <write_head+0x48>
    }
    bufcache_write(buf);
  109357:	83 ec 0c             	sub    $0xc,%esp
  10935a:	89 f3                	mov    %esi,%ebx
  10935c:	57                   	push   %edi
  10935d:	e8 1e fe ff ff       	call   109180 <bufcache_write>
    bufcache_release(buf);
  109362:	89 3c 24             	mov    %edi,(%esp)
  109365:	e8 66 fe ff ff       	call   1091d0 <bufcache_release>
}
  10936a:	83 c4 10             	add    $0x10,%esp
  10936d:	5b                   	pop    %ebx
  10936e:	5e                   	pop    %esi
  10936f:	5f                   	pop    %edi
  109370:	c3                   	ret
  109371:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  109378:	00 
  109379:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00109380 <log_init>:
{
  109380:	57                   	push   %edi
  109381:	56                   	push   %esi
  109382:	53                   	push   %ebx
  109383:	e8 1a 70 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109388:	81 c3 6c dc 00 00    	add    $0xdc6c,%ebx
  10938e:	83 ec 1c             	sub    $0x1c,%esp
    spinlock_init(&log.lock);
  109391:	8d b3 8c a7 d5 00    	lea    0xd5a78c(%ebx),%esi
  109397:	56                   	push   %esi
  109398:	e8 23 cb ff ff       	call   105ec0 <spinlock_init>
    read_superblock(ROOTDEV, &sb);
  10939d:	58                   	pop    %eax
  10939e:	5a                   	pop    %edx
  10939f:	8d 44 24 08          	lea    0x8(%esp),%eax
  1093a3:	50                   	push   %eax
  1093a4:	6a 01                	push   $0x1
  1093a6:	e8 85 02 00 00       	call   109630 <read_superblock>
    log.start = sb.size - sb.nlog;
  1093ab:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  1093af:	8b 44 24 10          	mov    0x10(%esp),%eax
    log.dev = ROOTDEV;
  1093b3:	c7 83 a0 a7 d5 00 01 	movl   $0x1,0xd5a7a0(%ebx)
  1093ba:	00 00 00 
    struct buf *buf = bufcache_read(log.dev, log.start);
  1093bd:	59                   	pop    %ecx
  1093be:	5f                   	pop    %edi
    log.start = sb.size - sb.nlog;
  1093bf:	29 d0                	sub    %edx,%eax
    log.size = sb.nlog;
  1093c1:	89 93 98 a7 d5 00    	mov    %edx,0xd5a798(%ebx)
    struct buf *buf = bufcache_read(log.dev, log.start);
  1093c7:	50                   	push   %eax
  1093c8:	6a 01                	push   $0x1
    log.start = sb.size - sb.nlog;
  1093ca:	89 83 94 a7 d5 00    	mov    %eax,0xd5a794(%ebx)
    struct buf *buf = bufcache_read(log.dev, log.start);
  1093d0:	e8 7b fc ff ff       	call   109050 <bufcache_read>
    for (i = 0; i < log.lh.n; i++) {
  1093d5:	83 c4 10             	add    $0x10,%esp
    log.lh.n = lh->n;
  1093d8:	8b 48 18             	mov    0x18(%eax),%ecx
    struct buf *buf = bufcache_read(log.dev, log.start);
  1093db:	89 c7                	mov    %eax,%edi
    log.lh.n = lh->n;
  1093dd:	89 8b a4 a7 d5 00    	mov    %ecx,0xd5a7a4(%ebx)
    for (i = 0; i < log.lh.n; i++) {
  1093e3:	85 c9                	test   %ecx,%ecx
  1093e5:	7e 18                	jle    1093ff <log_init+0x7f>
  1093e7:	8d 40 1c             	lea    0x1c(%eax),%eax
  1093ea:	8d 56 1c             	lea    0x1c(%esi),%edx
  1093ed:	8d 34 88             	lea    (%eax,%ecx,4),%esi
        log.lh.sector[i] = lh->sector[i];
  1093f0:	8b 08                	mov    (%eax),%ecx
    for (i = 0; i < log.lh.n; i++) {
  1093f2:	83 c0 04             	add    $0x4,%eax
  1093f5:	83 c2 04             	add    $0x4,%edx
        log.lh.sector[i] = lh->sector[i];
  1093f8:	89 4a fc             	mov    %ecx,-0x4(%edx)
    for (i = 0; i < log.lh.n; i++) {
  1093fb:	39 f0                	cmp    %esi,%eax
  1093fd:	75 f1                	jne    1093f0 <log_init+0x70>
    bufcache_release(buf);
  1093ff:	83 ec 0c             	sub    $0xc,%esp
  109402:	57                   	push   %edi
  109403:	e8 c8 fd ff ff       	call   1091d0 <bufcache_release>

static void recover_from_log(void)
{
    read_head();
    install_trans();  // if committed, copy from log to disk
  109408:	e8 53 fe ff ff       	call   109260 <install_trans>
    log.lh.n = 0;
  10940d:	c7 83 a4 a7 d5 00 00 	movl   $0x0,0xd5a7a4(%ebx)
  109414:	00 00 00 
    write_head();     // clear the log
  109417:	e8 e4 fe ff ff       	call   109300 <write_head>
}
  10941c:	83 c4 20             	add    $0x20,%esp
  10941f:	5b                   	pop    %ebx
  109420:	5e                   	pop    %esi
  109421:	5f                   	pop    %edi
  109422:	c3                   	ret
  109423:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10942a:	00 
  10942b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

00109430 <begin_trans>:
}

void begin_trans(void)
{
  109430:	57                   	push   %edi
  109431:	56                   	push   %esi
  109432:	53                   	push   %ebx
  109433:	e8 6a 6f ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109438:	81 c3 bc db 00 00    	add    $0xdbbc,%ebx
    spinlock_acquire(&log.lock);
  10943e:	83 ec 0c             	sub    $0xc,%esp
  109441:	8d b3 8c a7 d5 00    	lea    0xd5a78c(%ebx),%esi
  109447:	56                   	push   %esi
  109448:	e8 03 cb ff ff       	call   105f50 <spinlock_acquire>
    while (log.busy) {
  10944d:	8b 93 9c a7 d5 00    	mov    0xd5a79c(%ebx),%edx
  109453:	83 c4 10             	add    $0x10,%esp
  109456:	85 d2                	test   %edx,%edx
  109458:	74 1b                	je     109475 <begin_trans+0x45>
  10945a:	8d 3d 8c a7 d5 00    	lea    0xd5a78c,%edi
        thread_sleep(&log, &log.lock);
  109460:	83 ec 08             	sub    $0x8,%esp
  109463:	56                   	push   %esi
  109464:	56                   	push   %esi
  109465:	e8 26 e8 ff ff       	call   107c90 <thread_sleep>
    while (log.busy) {
  10946a:	8b 44 1f 10          	mov    0x10(%edi,%ebx,1),%eax
  10946e:	83 c4 10             	add    $0x10,%esp
  109471:	85 c0                	test   %eax,%eax
  109473:	75 eb                	jne    109460 <begin_trans+0x30>
    }
    log.busy = 1;
  109475:	c7 83 9c a7 d5 00 01 	movl   $0x1,0xd5a79c(%ebx)
  10947c:	00 00 00 
    spinlock_release(&log.lock);
  10947f:	83 ec 0c             	sub    $0xc,%esp
  109482:	56                   	push   %esi
  109483:	e8 48 cb ff ff       	call   105fd0 <spinlock_release>
}
  109488:	83 c4 10             	add    $0x10,%esp
  10948b:	5b                   	pop    %ebx
  10948c:	5e                   	pop    %esi
  10948d:	5f                   	pop    %edi
  10948e:	c3                   	ret
  10948f:	90                   	nop

00109490 <commit_trans>:

void commit_trans(void)
{
  109490:	56                   	push   %esi
  109491:	53                   	push   %ebx
  109492:	e8 0b 6f ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109497:	81 c3 5d db 00 00    	add    $0xdb5d,%ebx
  10949d:	83 ec 04             	sub    $0x4,%esp
    if (log.lh.n > 0) {
  1094a0:	8b 83 a4 a7 d5 00    	mov    0xd5a7a4(%ebx),%eax
  1094a6:	85 c0                	test   %eax,%eax
  1094a8:	7e 19                	jle    1094c3 <commit_trans+0x33>
        write_head();     // Write header to disk -- the real commit
  1094aa:	e8 51 fe ff ff       	call   109300 <write_head>
        install_trans();  // Now install writes to home locations
  1094af:	e8 ac fd ff ff       	call   109260 <install_trans>
        log.lh.n = 0;
  1094b4:	c7 83 a4 a7 d5 00 00 	movl   $0x0,0xd5a7a4(%ebx)
  1094bb:	00 00 00 
        write_head();     // Erase the transaction from the log
  1094be:	e8 3d fe ff ff       	call   109300 <write_head>
    }

    spinlock_acquire(&log.lock);
  1094c3:	83 ec 0c             	sub    $0xc,%esp
  1094c6:	8d b3 8c a7 d5 00    	lea    0xd5a78c(%ebx),%esi
  1094cc:	56                   	push   %esi
  1094cd:	e8 7e ca ff ff       	call   105f50 <spinlock_acquire>
    log.busy = 0;
    thread_wakeup(&log);
  1094d2:	89 34 24             	mov    %esi,(%esp)
    log.busy = 0;
  1094d5:	c7 83 9c a7 d5 00 00 	movl   $0x0,0xd5a79c(%ebx)
  1094dc:	00 00 00 
    thread_wakeup(&log);
  1094df:	e8 bc e8 ff ff       	call   107da0 <thread_wakeup>
    spinlock_release(&log.lock);
  1094e4:	89 34 24             	mov    %esi,(%esp)
  1094e7:	e8 e4 ca ff ff       	call   105fd0 <spinlock_release>
}
  1094ec:	83 c4 14             	add    $0x14,%esp
  1094ef:	5b                   	pop    %ebx
  1094f0:	5e                   	pop    %esi
  1094f1:	c3                   	ret
  1094f2:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1094f9:	00 
  1094fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00109500 <log_write>:
//   bp = bufcache_read(...)
//   modify bp->data[]
//   log_write(bp)
//   bufcache_release(bp)
void log_write(struct buf *b)
{
  109500:	55                   	push   %ebp
  109501:	57                   	push   %edi
  109502:	56                   	push   %esi
  109503:	53                   	push   %ebx
  109504:	e8 99 6e ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109509:	81 c3 eb da 00 00    	add    $0xdaeb,%ebx
  10950f:	83 ec 0c             	sub    $0xc,%esp
  109512:	8b 7c 24 20          	mov    0x20(%esp),%edi
    int i;

    if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
  109516:	8b 83 a4 a7 d5 00    	mov    0xd5a7a4(%ebx),%eax
  10951c:	8b 93 98 a7 d5 00    	mov    0xd5a798(%ebx),%edx
  109522:	83 f8 09             	cmp    $0x9,%eax
  109525:	0f 8f a5 00 00 00    	jg     1095d0 <log_write+0xd0>
  10952b:	8d 4a ff             	lea    -0x1(%edx),%ecx
  10952e:	39 c8                	cmp    %ecx,%eax
  109530:	0f 8d 9a 00 00 00    	jge    1095d0 <log_write+0xd0>
        KERN_PANIC("too big a transaction. %d < %d <= %d",
                   log.size, log.lh.n, LOGSIZE);
    if (!log.busy)
  109536:	8b 83 9c a7 d5 00    	mov    0xd5a79c(%ebx),%eax
  10953c:	85 c0                	test   %eax,%eax
  10953e:	0f 84 bc 00 00 00    	je     109600 <log_write+0x100>
        KERN_PANIC("write outside of trans");

    for (i = 0; i < log.lh.n; i++) {
  109544:	8b 93 a4 a7 d5 00    	mov    0xd5a7a4(%ebx),%edx
        if (log.lh.sector[i] == b->sector)  // log absorbtion?
            break;
    }
    log.lh.sector[i] = b->sector;
  10954a:	8b 47 08             	mov    0x8(%edi),%eax
    for (i = 0; i < log.lh.n; i++) {
  10954d:	31 f6                	xor    %esi,%esi
  10954f:	85 d2                	test   %edx,%edx
  109551:	7f 0c                	jg     10955f <log_write+0x5f>
  109553:	eb 13                	jmp    109568 <log_write+0x68>
  109555:	8d 76 00             	lea    0x0(%esi),%esi
  109558:	83 c6 01             	add    $0x1,%esi
  10955b:	39 d6                	cmp    %edx,%esi
  10955d:	74 09                	je     109568 <log_write+0x68>
        if (log.lh.sector[i] == b->sector)  // log absorbtion?
  10955f:	39 84 b3 a8 a7 d5 00 	cmp    %eax,0xd5a7a8(%ebx,%esi,4)
  109566:	75 f0                	jne    109558 <log_write+0x58>
    log.lh.sector[i] = b->sector;
  109568:	89 84 b3 a8 a7 d5 00 	mov    %eax,0xd5a7a8(%ebx,%esi,4)
    struct buf *lbuf = bufcache_read(b->dev, log.start + i + 1);
  10956f:	8b 83 94 a7 d5 00    	mov    0xd5a794(%ebx),%eax
  109575:	83 ec 08             	sub    $0x8,%esp
  109578:	01 f0                	add    %esi,%eax
  10957a:	83 c0 01             	add    $0x1,%eax
  10957d:	50                   	push   %eax
  10957e:	ff 77 04             	push   0x4(%edi)
  109581:	e8 ca fa ff ff       	call   109050 <bufcache_read>
    memmove(lbuf->data, b->data, BSIZE);
  109586:	83 c4 0c             	add    $0xc,%esp
    struct buf *lbuf = bufcache_read(b->dev, log.start + i + 1);
  109589:	89 c5                	mov    %eax,%ebp
    memmove(lbuf->data, b->data, BSIZE);
  10958b:	8d 47 18             	lea    0x18(%edi),%eax
  10958e:	68 00 02 00 00       	push   $0x200
  109593:	50                   	push   %eax
  109594:	8d 45 18             	lea    0x18(%ebp),%eax
  109597:	50                   	push   %eax
  109598:	e8 d3 ae ff ff       	call   104470 <memmove>
    bufcache_write(lbuf);
  10959d:	89 2c 24             	mov    %ebp,(%esp)
  1095a0:	e8 db fb ff ff       	call   109180 <bufcache_write>
    bufcache_release(lbuf);
  1095a5:	89 2c 24             	mov    %ebp,(%esp)
  1095a8:	e8 23 fc ff ff       	call   1091d0 <bufcache_release>
    if (i == log.lh.n)
  1095ad:	83 c4 10             	add    $0x10,%esp
  1095b0:	39 b3 a4 a7 d5 00    	cmp    %esi,0xd5a7a4(%ebx)
  1095b6:	75 09                	jne    1095c1 <log_write+0xc1>
        log.lh.n++;
  1095b8:	83 c6 01             	add    $0x1,%esi
  1095bb:	89 b3 a4 a7 d5 00    	mov    %esi,0xd5a7a4(%ebx)
    b->flags |= B_DIRTY;  // XXX: prevent eviction
  1095c1:	83 0f 04             	orl    $0x4,(%edi)
}
  1095c4:	83 c4 0c             	add    $0xc,%esp
  1095c7:	5b                   	pop    %ebx
  1095c8:	5e                   	pop    %esi
  1095c9:	5f                   	pop    %edi
  1095ca:	5d                   	pop    %ebp
  1095cb:	c3                   	ret
  1095cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        KERN_PANIC("too big a transaction. %d < %d <= %d",
  1095d0:	83 ec 08             	sub    $0x8,%esp
  1095d3:	6a 0a                	push   $0xa
  1095d5:	50                   	push   %eax
  1095d6:	8d 83 3c 74 ff ff    	lea    -0x8bc4(%ebx),%eax
  1095dc:	52                   	push   %edx
  1095dd:	50                   	push   %eax
  1095de:	8d 83 48 68 ff ff    	lea    -0x97b8(%ebx),%eax
  1095e4:	68 9d 00 00 00       	push   $0x9d
  1095e9:	50                   	push   %eax
  1095ea:	e8 01 b2 ff ff       	call   1047f0 <debug_panic>
    if (!log.busy)
  1095ef:	8b 83 9c a7 d5 00    	mov    0xd5a79c(%ebx),%eax
        KERN_PANIC("too big a transaction. %d < %d <= %d",
  1095f5:	83 c4 20             	add    $0x20,%esp
    if (!log.busy)
  1095f8:	85 c0                	test   %eax,%eax
  1095fa:	0f 85 44 ff ff ff    	jne    109544 <log_write+0x44>
        KERN_PANIC("write outside of trans");
  109600:	83 ec 04             	sub    $0x4,%esp
  109603:	8d 83 56 68 ff ff    	lea    -0x97aa(%ebx),%eax
  109609:	50                   	push   %eax
  10960a:	8d 83 48 68 ff ff    	lea    -0x97b8(%ebx),%eax
  109610:	68 a0 00 00 00       	push   $0xa0
  109615:	50                   	push   %eax
  109616:	e8 d5 b1 ff ff       	call   1047f0 <debug_panic>
  10961b:	83 c4 10             	add    $0x10,%esp
  10961e:	e9 21 ff ff ff       	jmp    109544 <log_write+0x44>
  109623:	66 90                	xchg   %ax,%ax
  109625:	66 90                	xchg   %ax,%ax
  109627:	66 90                	xchg   %ax,%ax
  109629:	66 90                	xchg   %ax,%ax
  10962b:	66 90                	xchg   %ax,%ax
  10962d:	66 90                	xchg   %ax,%ax
  10962f:	90                   	nop

00109630 <read_superblock>:
#include "dinode.h"
#include "log.h"

// Read the super block.
void read_superblock(int dev, struct superblock *sb)
{
  109630:	56                   	push   %esi
  109631:	53                   	push   %ebx
  109632:	e8 6b 6d ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109637:	81 c3 bd d9 00 00    	add    $0xd9bd,%ebx
  10963d:	83 ec 0c             	sub    $0xc,%esp
    struct buf *bp;

    bp = bufcache_read(dev, 1);  // Block 1 is super block.
  109640:	6a 01                	push   $0x1
  109642:	ff 74 24 1c          	push   0x1c(%esp)
  109646:	e8 05 fa ff ff       	call   109050 <bufcache_read>
    memmove(sb, bp->data, sizeof(*sb));
  10964b:	83 c4 0c             	add    $0xc,%esp
    bp = bufcache_read(dev, 1);  // Block 1 is super block.
  10964e:	89 c6                	mov    %eax,%esi
    memmove(sb, bp->data, sizeof(*sb));
  109650:	8d 40 18             	lea    0x18(%eax),%eax
  109653:	6a 10                	push   $0x10
  109655:	50                   	push   %eax
  109656:	ff 74 24 20          	push   0x20(%esp)
  10965a:	e8 11 ae ff ff       	call   104470 <memmove>
    bufcache_release(bp);
  10965f:	89 34 24             	mov    %esi,(%esp)
  109662:	e8 69 fb ff ff       	call   1091d0 <bufcache_release>
}
  109667:	83 c4 14             	add    $0x14,%esp
  10966a:	5b                   	pop    %ebx
  10966b:	5e                   	pop    %esi
  10966c:	c3                   	ret
  10966d:	8d 76 00             	lea    0x0(%esi),%esi

00109670 <block_zero>:

// Zero a block.
void block_zero(uint32_t dev, uint32_t bno)
{
  109670:	56                   	push   %esi
  109671:	53                   	push   %ebx
  109672:	e8 2b 6d ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109677:	81 c3 7d d9 00 00    	add    $0xd97d,%ebx
  10967d:	83 ec 0c             	sub    $0xc,%esp
    struct buf *bp;

    bp = bufcache_read(dev, bno);
  109680:	ff 74 24 1c          	push   0x1c(%esp)
  109684:	ff 74 24 1c          	push   0x1c(%esp)
  109688:	e8 c3 f9 ff ff       	call   109050 <bufcache_read>
    memset(bp->data, 0, BSIZE);
  10968d:	83 c4 0c             	add    $0xc,%esp
    bp = bufcache_read(dev, bno);
  109690:	89 c6                	mov    %eax,%esi
    memset(bp->data, 0, BSIZE);
  109692:	8d 40 18             	lea    0x18(%eax),%eax
  109695:	68 00 02 00 00       	push   $0x200
  10969a:	6a 00                	push   $0x0
  10969c:	50                   	push   %eax
  10969d:	e8 8e ad ff ff       	call   104430 <memset>
    log_write(bp);
  1096a2:	89 34 24             	mov    %esi,(%esp)
  1096a5:	e8 56 fe ff ff       	call   109500 <log_write>
    bufcache_release(bp);
  1096aa:	89 34 24             	mov    %esi,(%esp)
  1096ad:	e8 1e fb ff ff       	call   1091d0 <bufcache_release>
}
  1096b2:	83 c4 14             	add    $0x14,%esp
  1096b5:	5b                   	pop    %ebx
  1096b6:	5e                   	pop    %esi
  1096b7:	c3                   	ret
  1096b8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1096bf:	00 

001096c0 <block_alloc>:

// Allocate a zeroed disk block.
uint32_t block_alloc(uint32_t dev)
{
  1096c0:	55                   	push   %ebp
  1096c1:	57                   	push   %edi
  1096c2:	56                   	push   %esi
  1096c3:	53                   	push   %ebx
  1096c4:	e8 d9 6c ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  1096c9:	81 c3 2b d9 00 00    	add    $0xd92b,%ebx
  1096cf:	83 ec 34             	sub    $0x34,%esp
    bp = bufcache_read(dev, 1);  // Block 1 is super block.
  1096d2:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1096d6:	6a 01                	push   $0x1
  1096d8:	ff 74 24 4c          	push   0x4c(%esp)
  1096dc:	e8 6f f9 ff ff       	call   109050 <bufcache_read>
    memmove(sb, bp->data, sizeof(*sb));
  1096e1:	83 c4 0c             	add    $0xc,%esp
    bp = bufcache_read(dev, 1);  // Block 1 is super block.
  1096e4:	89 c6                	mov    %eax,%esi
    memmove(sb, bp->data, sizeof(*sb));
  1096e6:	83 c0 18             	add    $0x18,%eax
  1096e9:	6a 10                	push   $0x10
  1096eb:	50                   	push   %eax
  1096ec:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  1096f0:	50                   	push   %eax
  1096f1:	e8 7a ad ff ff       	call   104470 <memmove>
    bufcache_release(bp);
  1096f6:	89 34 24             	mov    %esi,(%esp)
  1096f9:	e8 d2 fa ff ff       	call   1091d0 <bufcache_release>
    struct buf *bp;
    struct superblock sb;

    bp = 0;
    read_superblock(dev, &sb);
    for (b = 0; b < sb.size; b += BPB) {
  1096fe:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  109702:	83 c4 10             	add    $0x10,%esp
  109705:	85 c9                	test   %ecx,%ecx
  109707:	0f 84 98 00 00 00    	je     1097a5 <block_alloc+0xe5>
  10970d:	31 ed                	xor    %ebp,%ebp
        bp = bufcache_read(dev, BBLOCK(b, sb.ninodes));
  10970f:	83 ec 08             	sub    $0x8,%esp
  109712:	89 ea                	mov    %ebp,%edx
  109714:	89 ee                	mov    %ebp,%esi
  109716:	8b 44 24 20          	mov    0x20(%esp),%eax
  10971a:	c1 fa 0c             	sar    $0xc,%edx
  10971d:	c1 e8 03             	shr    $0x3,%eax
  109720:	8d 44 10 03          	lea    0x3(%eax,%edx,1),%eax
  109724:	50                   	push   %eax
  109725:	ff 74 24 4c          	push   0x4c(%esp)
  109729:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  10972d:	e8 1e f9 ff ff       	call   109050 <bufcache_read>
  109732:	89 c7                	mov    %eax,%edi
        for (bi = 0; bi < BPB && b + bi < sb.size; bi++) {
  109734:	8b 44 24 20          	mov    0x20(%esp),%eax
  109738:	89 44 24 14          	mov    %eax,0x14(%esp)
  10973c:	83 c4 10             	add    $0x10,%esp
  10973f:	31 c0                	xor    %eax,%eax
  109741:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
  109745:	eb 32                	jmp    109779 <block_alloc+0xb9>
  109747:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10974e:	00 
  10974f:	90                   	nop
            m = 1 << (bi % 8);
  109750:	89 c1                	mov    %eax,%ecx
  109752:	bb 01 00 00 00       	mov    $0x1,%ebx
  109757:	83 e1 07             	and    $0x7,%ecx
  10975a:	d3 e3                	shl    %cl,%ebx
            if ((bp->data[bi / 8] & m) == 0) {  // Is block free?
  10975c:	89 c1                	mov    %eax,%ecx
  10975e:	c1 f9 03             	sar    $0x3,%ecx
  109761:	0f b6 6c 0f 18       	movzbl 0x18(%edi,%ecx,1),%ebp
  109766:	89 ea                	mov    %ebp,%edx
  109768:	85 dd                	test   %ebx,%ebp
  10976a:	74 64                	je     1097d0 <block_alloc+0x110>
        for (bi = 0; bi < BPB && b + bi < sb.size; bi++) {
  10976c:	83 c0 01             	add    $0x1,%eax
  10976f:	83 c6 01             	add    $0x1,%esi
  109772:	3d 00 10 00 00       	cmp    $0x1000,%eax
  109777:	74 08                	je     109781 <block_alloc+0xc1>
  109779:	8b 54 24 04          	mov    0x4(%esp),%edx
  10977d:	39 d6                	cmp    %edx,%esi
  10977f:	72 cf                	jb     109750 <block_alloc+0x90>
                bufcache_release(bp);
                block_zero(dev, b + bi);
                return b + bi;
            }
        }
        bufcache_release(bp);
  109781:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  109785:	83 ec 0c             	sub    $0xc,%esp
  109788:	57                   	push   %edi
  109789:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    for (b = 0; b < sb.size; b += BPB) {
  10978d:	81 c5 00 10 00 00    	add    $0x1000,%ebp
        bufcache_release(bp);
  109793:	e8 38 fa ff ff       	call   1091d0 <bufcache_release>
    for (b = 0; b < sb.size; b += BPB) {
  109798:	83 c4 10             	add    $0x10,%esp
  10979b:	3b 6c 24 10          	cmp    0x10(%esp),%ebp
  10979f:	0f 82 6a ff ff ff    	jb     10970f <block_alloc+0x4f>
    }
    KERN_PANIC("balloc: out of blocks");
  1097a5:	83 ec 04             	sub    $0x4,%esp
    return 0;
  1097a8:	31 f6                	xor    %esi,%esi
    KERN_PANIC("balloc: out of blocks");
  1097aa:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  1097ae:	8d 83 6d 68 ff ff    	lea    -0x9793(%ebx),%eax
  1097b4:	50                   	push   %eax
  1097b5:	8d 83 83 68 ff ff    	lea    -0x977d(%ebx),%eax
  1097bb:	6a 35                	push   $0x35
  1097bd:	50                   	push   %eax
  1097be:	e8 2d b0 ff ff       	call   1047f0 <debug_panic>
    return 0;
  1097c3:	83 c4 10             	add    $0x10,%esp
}
  1097c6:	89 f0                	mov    %esi,%eax
  1097c8:	83 c4 2c             	add    $0x2c,%esp
  1097cb:	5b                   	pop    %ebx
  1097cc:	5e                   	pop    %esi
  1097cd:	5f                   	pop    %edi
  1097ce:	5d                   	pop    %ebp
  1097cf:	c3                   	ret
                log_write(bp);
  1097d0:	83 ec 0c             	sub    $0xc,%esp
                bp->data[bi / 8] |= m;          // Mark block in use.
  1097d3:	09 da                	or     %ebx,%edx
  1097d5:	88 54 0f 18          	mov    %dl,0x18(%edi,%ecx,1)
                log_write(bp);
  1097d9:	57                   	push   %edi
  1097da:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  1097de:	e8 1d fd ff ff       	call   109500 <log_write>
                bufcache_release(bp);
  1097e3:	89 3c 24             	mov    %edi,(%esp)
  1097e6:	e8 e5 f9 ff ff       	call   1091d0 <bufcache_release>
    bp = bufcache_read(dev, bno);
  1097eb:	58                   	pop    %eax
  1097ec:	5a                   	pop    %edx
  1097ed:	56                   	push   %esi
  1097ee:	ff 74 24 4c          	push   0x4c(%esp)
  1097f2:	e8 59 f8 ff ff       	call   109050 <bufcache_read>
    memset(bp->data, 0, BSIZE);
  1097f7:	83 c4 0c             	add    $0xc,%esp
    bp = bufcache_read(dev, bno);
  1097fa:	89 c7                	mov    %eax,%edi
    memset(bp->data, 0, BSIZE);
  1097fc:	8d 40 18             	lea    0x18(%eax),%eax
  1097ff:	68 00 02 00 00       	push   $0x200
  109804:	6a 00                	push   $0x0
  109806:	50                   	push   %eax
  109807:	e8 24 ac ff ff       	call   104430 <memset>
    log_write(bp);
  10980c:	89 3c 24             	mov    %edi,(%esp)
  10980f:	e8 ec fc ff ff       	call   109500 <log_write>
    bufcache_release(bp);
  109814:	89 3c 24             	mov    %edi,(%esp)
  109817:	e8 b4 f9 ff ff       	call   1091d0 <bufcache_release>
}
  10981c:	83 c4 10             	add    $0x10,%esp
}
  10981f:	89 f0                	mov    %esi,%eax
  109821:	83 c4 2c             	add    $0x2c,%esp
  109824:	5b                   	pop    %ebx
  109825:	5e                   	pop    %esi
  109826:	5f                   	pop    %edi
  109827:	5d                   	pop    %ebp
  109828:	c3                   	ret
  109829:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00109830 <block_free>:

// Free a disk block.
void block_free(uint32_t dev, uint32_t b)
{
  109830:	55                   	push   %ebp
  109831:	57                   	push   %edi
  109832:	56                   	push   %esi
  109833:	53                   	push   %ebx
  109834:	e8 69 6b ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109839:	81 c3 bb d7 00 00    	add    $0xd7bb,%ebx
  10983f:	83 ec 34             	sub    $0x34,%esp
  109842:	8b 7c 24 48          	mov    0x48(%esp),%edi
  109846:	8b 74 24 4c          	mov    0x4c(%esp),%esi
    bp = bufcache_read(dev, 1);  // Block 1 is super block.
  10984a:	6a 01                	push   $0x1
  10984c:	57                   	push   %edi
  10984d:	e8 fe f7 ff ff       	call   109050 <bufcache_read>
    memmove(sb, bp->data, sizeof(*sb));
  109852:	83 c4 0c             	add    $0xc,%esp
    bp = bufcache_read(dev, 1);  // Block 1 is super block.
  109855:	89 c5                	mov    %eax,%ebp
    memmove(sb, bp->data, sizeof(*sb));
  109857:	83 c0 18             	add    $0x18,%eax
  10985a:	6a 10                	push   $0x10
  10985c:	50                   	push   %eax
  10985d:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  109861:	50                   	push   %eax
  109862:	e8 09 ac ff ff       	call   104470 <memmove>
    bufcache_release(bp);
  109867:	89 2c 24             	mov    %ebp,(%esp)
  10986a:	e8 61 f9 ff ff       	call   1091d0 <bufcache_release>
    struct buf *bp;
    struct superblock sb;
    int bi, m;

    read_superblock(dev, &sb);
    bp = bufcache_read(dev, BBLOCK(b, sb.ninodes));
  10986f:	58                   	pop    %eax
  109870:	5a                   	pop    %edx
  109871:	89 f2                	mov    %esi,%edx
  109873:	8b 44 24 20          	mov    0x20(%esp),%eax
  109877:	c1 ea 0c             	shr    $0xc,%edx
  10987a:	c1 e8 03             	shr    $0x3,%eax
  10987d:	8d 44 10 03          	lea    0x3(%eax,%edx,1),%eax
  109881:	50                   	push   %eax
  109882:	57                   	push   %edi
  109883:	e8 c8 f7 ff ff       	call   109050 <bufcache_read>
    bi = b % BPB;
    m = 1 << (bi % 8);
  109888:	89 f1                	mov    %esi,%ecx
    if ((bp->data[bi / 8] & m) == 0)
  10988a:	c1 fe 03             	sar    $0x3,%esi
  10988d:	83 c4 10             	add    $0x10,%esp
    bp = bufcache_read(dev, BBLOCK(b, sb.ninodes));
  109890:	89 c7                	mov    %eax,%edi
    m = 1 << (bi % 8);
  109892:	83 e1 07             	and    $0x7,%ecx
  109895:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((bp->data[bi / 8] & m) == 0)
  10989a:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
    m = 1 << (bi % 8);
  1098a0:	d3 e0                	shl    %cl,%eax
    if ((bp->data[bi / 8] & m) == 0)
  1098a2:	0f b6 4c 37 18       	movzbl 0x18(%edi,%esi,1),%ecx
  1098a7:	89 ca                	mov    %ecx,%edx
  1098a9:	85 c1                	test   %eax,%ecx
  1098ab:	74 23                	je     1098d0 <block_free+0xa0>
        KERN_PANIC("freeing free block");
    bp->data[bi / 8] &= ~m;
  1098ad:	f7 d0                	not    %eax
    log_write(bp);
  1098af:	83 ec 0c             	sub    $0xc,%esp
    bp->data[bi / 8] &= ~m;
  1098b2:	21 d0                	and    %edx,%eax
  1098b4:	88 44 37 18          	mov    %al,0x18(%edi,%esi,1)
    log_write(bp);
  1098b8:	57                   	push   %edi
  1098b9:	e8 42 fc ff ff       	call   109500 <log_write>
    bufcache_release(bp);
  1098be:	89 3c 24             	mov    %edi,(%esp)
  1098c1:	e8 0a f9 ff ff       	call   1091d0 <bufcache_release>
}
  1098c6:	83 c4 3c             	add    $0x3c,%esp
  1098c9:	5b                   	pop    %ebx
  1098ca:	5e                   	pop    %esi
  1098cb:	5f                   	pop    %edi
  1098cc:	5d                   	pop    %ebp
  1098cd:	c3                   	ret
  1098ce:	66 90                	xchg   %ax,%ax
  1098d0:	89 44 24 0c          	mov    %eax,0xc(%esp)
        KERN_PANIC("freeing free block");
  1098d4:	8d 93 93 68 ff ff    	lea    -0x976d(%ebx),%edx
  1098da:	83 ec 04             	sub    $0x4,%esp
  1098dd:	52                   	push   %edx
  1098de:	8d 93 83 68 ff ff    	lea    -0x977d(%ebx),%edx
  1098e4:	6a 45                	push   $0x45
  1098e6:	52                   	push   %edx
  1098e7:	e8 04 af ff ff       	call   1047f0 <debug_panic>
    bp->data[bi / 8] &= ~m;
  1098ec:	83 c4 10             	add    $0x10,%esp
  1098ef:	0f b6 54 37 18       	movzbl 0x18(%edi,%esi,1),%edx
  1098f4:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1098f8:	eb b3                	jmp    1098ad <block_free+0x7d>
  1098fa:	66 90                	xchg   %ax,%ax
  1098fc:	66 90                	xchg   %ax,%ax
  1098fe:	66 90                	xchg   %ax,%ax

00109900 <bmap>:
/**
 * Return the disk block address of the nth block in inode ip.
 * If there is no such block, bmap allocates one.
 */
static uint32_t bmap(struct inode *ip, uint32_t bn)
{
  109900:	55                   	push   %ebp
  109901:	57                   	push   %edi
  109902:	89 c7                	mov    %eax,%edi
  109904:	56                   	push   %esi
  109905:	53                   	push   %ebx
  109906:	e8 97 6a ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10990b:	81 c3 e9 d6 00 00    	add    $0xd6e9,%ebx
  109911:	83 ec 1c             	sub    $0x1c,%esp
    uint32_t addr, *a;
    struct buf *bp;

    if (bn < NDIRECT) {
  109914:	83 fa 0b             	cmp    $0xb,%edx
  109917:	76 77                	jbe    109990 <bmap+0x90>
        if ((addr = ip->addrs[bn]) == 0)
            ip->addrs[bn] = addr = block_alloc(ip->dev);
        return addr;
    }
    bn -= NDIRECT;
  109919:	8d 72 f4             	lea    -0xc(%edx),%esi

    if (bn < NINDIRECT) {
  10991c:	83 fe 7f             	cmp    $0x7f,%esi
  10991f:	77 3f                	ja     109960 <bmap+0x60>
        // Load indirect block, allocating if necessary.
        if ((addr = ip->addrs[NDIRECT]) == 0)
  109921:	8b 40 4c             	mov    0x4c(%eax),%eax
  109924:	85 c0                	test   %eax,%eax
  109926:	0f 84 c4 00 00 00    	je     1099f0 <bmap+0xf0>
            ip->addrs[NDIRECT] = addr = block_alloc(ip->dev);
        bp = bufcache_read(ip->dev, addr);
  10992c:	83 ec 08             	sub    $0x8,%esp
  10992f:	50                   	push   %eax
  109930:	ff 37                	push   (%edi)
  109932:	e8 19 f7 ff ff       	call   109050 <bufcache_read>
        a = (uint32_t *) bp->data;
        if ((addr = a[bn]) == 0) {
  109937:	83 c4 10             	add    $0x10,%esp
  10993a:	8d 74 b0 18          	lea    0x18(%eax,%esi,4),%esi
        bp = bufcache_read(ip->dev, addr);
  10993e:	89 c2                	mov    %eax,%edx
        if ((addr = a[bn]) == 0) {
  109940:	8b 2e                	mov    (%esi),%ebp
  109942:	85 ed                	test   %ebp,%ebp
  109944:	74 7a                	je     1099c0 <bmap+0xc0>
            a[bn] = addr = block_alloc(ip->dev);
            log_write(bp);
        }
        bufcache_release(bp);
  109946:	83 ec 0c             	sub    $0xc,%esp
  109949:	52                   	push   %edx
  10994a:	e8 81 f8 ff ff       	call   1091d0 <bufcache_release>
        return addr;
  10994f:	83 c4 10             	add    $0x10,%esp
    }

    KERN_PANIC("bmap: out of range");
    return 0;
}
  109952:	83 c4 1c             	add    $0x1c,%esp
  109955:	89 e8                	mov    %ebp,%eax
  109957:	5b                   	pop    %ebx
  109958:	5e                   	pop    %esi
  109959:	5f                   	pop    %edi
  10995a:	5d                   	pop    %ebp
  10995b:	c3                   	ret
  10995c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    KERN_PANIC("bmap: out of range");
  109960:	83 ec 04             	sub    $0x4,%esp
  109963:	8d 83 a6 68 ff ff    	lea    -0x975a(%ebx),%eax
    return 0;
  109969:	31 ed                	xor    %ebp,%ebp
    KERN_PANIC("bmap: out of range");
  10996b:	50                   	push   %eax
  10996c:	8d 83 b9 68 ff ff    	lea    -0x9747(%ebx),%eax
  109972:	68 ff 00 00 00       	push   $0xff
  109977:	50                   	push   %eax
  109978:	e8 73 ae ff ff       	call   1047f0 <debug_panic>
    return 0;
  10997d:	83 c4 10             	add    $0x10,%esp
}
  109980:	89 e8                	mov    %ebp,%eax
  109982:	83 c4 1c             	add    $0x1c,%esp
  109985:	5b                   	pop    %ebx
  109986:	5e                   	pop    %esi
  109987:	5f                   	pop    %edi
  109988:	5d                   	pop    %ebp
  109989:	c3                   	ret
  10998a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        if ((addr = ip->addrs[bn]) == 0)
  109990:	8d 72 04             	lea    0x4(%edx),%esi
  109993:	8b 6c b0 0c          	mov    0xc(%eax,%esi,4),%ebp
  109997:	85 ed                	test   %ebp,%ebp
  109999:	75 b7                	jne    109952 <bmap+0x52>
            ip->addrs[bn] = addr = block_alloc(ip->dev);
  10999b:	83 ec 0c             	sub    $0xc,%esp
  10999e:	ff 30                	push   (%eax)
  1099a0:	e8 1b fd ff ff       	call   1096c0 <block_alloc>
  1099a5:	83 c4 10             	add    $0x10,%esp
  1099a8:	89 44 b7 0c          	mov    %eax,0xc(%edi,%esi,4)
  1099ac:	89 c5                	mov    %eax,%ebp
}
  1099ae:	83 c4 1c             	add    $0x1c,%esp
  1099b1:	5b                   	pop    %ebx
  1099b2:	89 e8                	mov    %ebp,%eax
  1099b4:	5e                   	pop    %esi
  1099b5:	5f                   	pop    %edi
  1099b6:	5d                   	pop    %ebp
  1099b7:	c3                   	ret
  1099b8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  1099bf:	00 
  1099c0:	89 44 24 0c          	mov    %eax,0xc(%esp)
            a[bn] = addr = block_alloc(ip->dev);
  1099c4:	83 ec 0c             	sub    $0xc,%esp
  1099c7:	ff 37                	push   (%edi)
  1099c9:	e8 f2 fc ff ff       	call   1096c0 <block_alloc>
            log_write(bp);
  1099ce:	8b 54 24 1c          	mov    0x1c(%esp),%edx
            a[bn] = addr = block_alloc(ip->dev);
  1099d2:	89 06                	mov    %eax,(%esi)
  1099d4:	89 c5                	mov    %eax,%ebp
            log_write(bp);
  1099d6:	89 14 24             	mov    %edx,(%esp)
  1099d9:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  1099dd:	e8 1e fb ff ff       	call   109500 <log_write>
  1099e2:	83 c4 10             	add    $0x10,%esp
  1099e5:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1099e9:	e9 58 ff ff ff       	jmp    109946 <bmap+0x46>
  1099ee:	66 90                	xchg   %ax,%ax
            ip->addrs[NDIRECT] = addr = block_alloc(ip->dev);
  1099f0:	83 ec 0c             	sub    $0xc,%esp
  1099f3:	ff 37                	push   (%edi)
  1099f5:	e8 c6 fc ff ff       	call   1096c0 <block_alloc>
  1099fa:	83 c4 10             	add    $0x10,%esp
  1099fd:	89 47 4c             	mov    %eax,0x4c(%edi)
  109a00:	e9 27 ff ff ff       	jmp    10992c <bmap+0x2c>
  109a05:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  109a0c:	00 
  109a0d:	8d 76 00             	lea    0x0(%esi),%esi

00109a10 <inode_init>:
{
  109a10:	53                   	push   %ebx
  109a11:	e8 8c 69 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109a16:	81 c3 de d5 00 00    	add    $0xd5de,%ebx
  109a1c:	83 ec 14             	sub    $0x14,%esp
    spinlock_init(&inode_cache.lock);
  109a1f:	8d 83 ec a7 d5 00    	lea    0xd5a7ec(%ebx),%eax
  109a25:	50                   	push   %eax
  109a26:	e8 95 c4 ff ff       	call   105ec0 <spinlock_init>
}
  109a2b:	83 c4 18             	add    $0x18,%esp
  109a2e:	5b                   	pop    %ebx
  109a2f:	c3                   	ret

00109a30 <inode_update>:
{
  109a30:	57                   	push   %edi
  109a31:	56                   	push   %esi
  109a32:	53                   	push   %ebx
  109a33:	8b 74 24 10          	mov    0x10(%esp),%esi
  109a37:	e8 66 69 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109a3c:	81 c3 b8 d5 00 00    	add    $0xd5b8,%ebx
    bp = bufcache_read(ip->dev, IBLOCK(ip->inum));
  109a42:	8b 46 04             	mov    0x4(%esi),%eax
    memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
  109a45:	83 c6 1c             	add    $0x1c,%esi
    bp = bufcache_read(ip->dev, IBLOCK(ip->inum));
  109a48:	83 ec 08             	sub    $0x8,%esp
  109a4b:	c1 e8 03             	shr    $0x3,%eax
  109a4e:	83 c0 02             	add    $0x2,%eax
  109a51:	50                   	push   %eax
  109a52:	ff 76 e4             	push   -0x1c(%esi)
  109a55:	e8 f6 f5 ff ff       	call   109050 <bufcache_read>
    dip->type = ip->type;
  109a5a:	8b 56 f8             	mov    -0x8(%esi),%edx
  109a5d:	8b 4e f4             	mov    -0xc(%esi),%ecx
    memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
  109a60:	83 c4 0c             	add    $0xc,%esp
    bp = bufcache_read(ip->dev, IBLOCK(ip->inum));
  109a63:	89 c7                	mov    %eax,%edi
    dip = (struct dinode *) bp->data + ip->inum % IPB;
  109a65:	8b 46 e8             	mov    -0x18(%esi),%eax
  109a68:	83 e0 07             	and    $0x7,%eax
  109a6b:	c1 e0 06             	shl    $0x6,%eax
  109a6e:	8d 44 07 18          	lea    0x18(%edi,%eax,1),%eax
    dip->type = ip->type;
  109a72:	89 50 04             	mov    %edx,0x4(%eax)
    dip->size = ip->size;
  109a75:	8b 56 fc             	mov    -0x4(%esi),%edx
    memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
  109a78:	83 c0 0c             	add    $0xc,%eax
    dip->type = ip->type;
  109a7b:	89 48 f4             	mov    %ecx,-0xc(%eax)
    dip->size = ip->size;
  109a7e:	89 50 fc             	mov    %edx,-0x4(%eax)
    memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
  109a81:	6a 34                	push   $0x34
  109a83:	56                   	push   %esi
  109a84:	50                   	push   %eax
  109a85:	e8 e6 a9 ff ff       	call   104470 <memmove>
    log_write(bp);
  109a8a:	89 3c 24             	mov    %edi,(%esp)
  109a8d:	e8 6e fa ff ff       	call   109500 <log_write>
    bufcache_release(bp);
  109a92:	89 3c 24             	mov    %edi,(%esp)
  109a95:	e8 36 f7 ff ff       	call   1091d0 <bufcache_release>
}
  109a9a:	83 c4 10             	add    $0x10,%esp
  109a9d:	5b                   	pop    %ebx
  109a9e:	5e                   	pop    %esi
  109a9f:	5f                   	pop    %edi
  109aa0:	c3                   	ret
  109aa1:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  109aa8:	00 
  109aa9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00109ab0 <inode_get>:
{
  109ab0:	55                   	push   %ebp
  109ab1:	57                   	push   %edi
    empty = 0;
  109ab2:	31 ff                	xor    %edi,%edi
{
  109ab4:	56                   	push   %esi
  109ab5:	53                   	push   %ebx
  109ab6:	e8 e7 68 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109abb:	81 c3 39 d5 00 00    	add    $0xd539,%ebx
  109ac1:	83 ec 28             	sub    $0x28,%esp
  109ac4:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
    spinlock_acquire(&inode_cache.lock);
  109ac8:	8d 83 ec a7 d5 00    	lea    0xd5a7ec(%ebx),%eax
  109ace:	89 44 24 18          	mov    %eax,0x18(%esp)
  109ad2:	89 c6                	mov    %eax,%esi
  109ad4:	50                   	push   %eax
    for (ip = &inode_cache.inode[0]; ip < &inode_cache.inode[NINODE]; ip++) {
  109ad5:	8d 76 08             	lea    0x8(%esi),%esi
    spinlock_acquire(&inode_cache.lock);
  109ad8:	e8 73 c4 ff ff       	call   105f50 <spinlock_acquire>
  109add:	83 c4 10             	add    $0x10,%esp
  109ae0:	8d 93 bc 25 d6 00    	lea    0xd625bc(%ebx),%edx
  109ae6:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  109aea:	eb 12                	jmp    109afe <inode_get+0x4e>
  109aec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if (ip->ref > 0 && ip->dev == dev && ip->inum == inum) {
  109af0:	39 2e                	cmp    %ebp,(%esi)
  109af2:	74 7c                	je     109b70 <inode_get+0xc0>
    for (ip = &inode_cache.inode[0]; ip < &inode_cache.inode[NINODE]; ip++) {
  109af4:	81 c6 84 02 00 00    	add    $0x284,%esi
  109afa:	39 d6                	cmp    %edx,%esi
  109afc:	74 22                	je     109b20 <inode_get+0x70>
        if (ip->ref > 0 && ip->dev == dev && ip->inum == inum) {
  109afe:	8b 46 08             	mov    0x8(%esi),%eax
  109b01:	85 c0                	test   %eax,%eax
  109b03:	7f eb                	jg     109af0 <inode_get+0x40>
        if (empty == 0 && ip->ref == 0)  // Remember empty slot.
  109b05:	85 ff                	test   %edi,%edi
  109b07:	75 eb                	jne    109af4 <inode_get+0x44>
  109b09:	85 c0                	test   %eax,%eax
  109b0b:	0f 85 89 00 00 00    	jne    109b9a <inode_get+0xea>
            empty = ip;
  109b11:	89 f7                	mov    %esi,%edi
    for (ip = &inode_cache.inode[0]; ip < &inode_cache.inode[NINODE]; ip++) {
  109b13:	81 c6 84 02 00 00    	add    $0x284,%esi
  109b19:	39 d6                	cmp    %edx,%esi
  109b1b:	75 e1                	jne    109afe <inode_get+0x4e>
  109b1d:	8d 76 00             	lea    0x0(%esi),%esi
    if (empty == 0)
  109b20:	85 ff                	test   %edi,%edi
  109b22:	0f 84 8c 00 00 00    	je     109bb4 <inode_get+0x104>
  109b28:	89 4c 24 34          	mov    %ecx,0x34(%esp)
    flock_init(&ip->flock);
  109b2c:	8d 47 50             	lea    0x50(%edi),%eax
  109b2f:	83 ec 0c             	sub    $0xc,%esp
  109b32:	50                   	push   %eax
  109b33:	e8 98 23 00 00       	call   10bed0 <flock_init>
    ip->inum = inum;
  109b38:	8b 4c 24 44          	mov    0x44(%esp),%ecx
    ip->dev = dev;
  109b3c:	89 2f                	mov    %ebp,(%edi)
    ip->ref = 1;
  109b3e:	c7 47 08 01 00 00 00 	movl   $0x1,0x8(%edi)
    ip->inum = inum;
  109b45:	89 4f 04             	mov    %ecx,0x4(%edi)
    ip->flags = 0;
  109b48:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
    spinlock_release(&inode_cache.lock);
  109b4f:	58                   	pop    %eax
  109b50:	ff 74 24 18          	push   0x18(%esp)
  109b54:	e8 77 c4 ff ff       	call   105fd0 <spinlock_release>
    return ip;
  109b59:	83 c4 10             	add    $0x10,%esp
}
  109b5c:	89 f8                	mov    %edi,%eax
  109b5e:	83 c4 1c             	add    $0x1c,%esp
  109b61:	5b                   	pop    %ebx
  109b62:	5e                   	pop    %esi
  109b63:	5f                   	pop    %edi
  109b64:	5d                   	pop    %ebp
  109b65:	c3                   	ret
  109b66:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  109b6d:	00 
  109b6e:	66 90                	xchg   %ax,%ax
        if (ip->ref > 0 && ip->dev == dev && ip->inum == inum) {
  109b70:	39 4e 04             	cmp    %ecx,0x4(%esi)
  109b73:	0f 85 7b ff ff ff    	jne    109af4 <inode_get+0x44>
            ip->ref++;
  109b79:	83 c0 01             	add    $0x1,%eax
            spinlock_release(&inode_cache.lock);
  109b7c:	83 ec 0c             	sub    $0xc,%esp
            return ip;
  109b7f:	89 f7                	mov    %esi,%edi
            ip->ref++;
  109b81:	89 46 08             	mov    %eax,0x8(%esi)
            spinlock_release(&inode_cache.lock);
  109b84:	ff 74 24 18          	push   0x18(%esp)
  109b88:	e8 43 c4 ff ff       	call   105fd0 <spinlock_release>
            return ip;
  109b8d:	83 c4 10             	add    $0x10,%esp
}
  109b90:	89 f8                	mov    %edi,%eax
  109b92:	83 c4 1c             	add    $0x1c,%esp
  109b95:	5b                   	pop    %ebx
  109b96:	5e                   	pop    %esi
  109b97:	5f                   	pop    %edi
  109b98:	5d                   	pop    %ebp
  109b99:	c3                   	ret
    for (ip = &inode_cache.inode[0]; ip < &inode_cache.inode[NINODE]; ip++) {
  109b9a:	81 c6 84 02 00 00    	add    $0x284,%esi
  109ba0:	39 d6                	cmp    %edx,%esi
  109ba2:	74 10                	je     109bb4 <inode_get+0x104>
        if (ip->ref > 0 && ip->dev == dev && ip->inum == inum) {
  109ba4:	8b 46 08             	mov    0x8(%esi),%eax
  109ba7:	85 c0                	test   %eax,%eax
  109ba9:	0f 8f 41 ff ff ff    	jg     109af0 <inode_get+0x40>
  109baf:	e9 55 ff ff ff       	jmp    109b09 <inode_get+0x59>
  109bb4:	89 4c 24 34          	mov    %ecx,0x34(%esp)
        KERN_PANIC("inode_get: no inodes");
  109bb8:	8d 83 c9 68 ff ff    	lea    -0x9737(%ebx),%eax
  109bbe:	83 ec 04             	sub    $0x4,%esp
  109bc1:	31 ff                	xor    %edi,%edi
  109bc3:	50                   	push   %eax
  109bc4:	8d 83 b9 68 ff ff    	lea    -0x9747(%ebx),%eax
  109bca:	6a 6a                	push   $0x6a
  109bcc:	50                   	push   %eax
  109bcd:	e8 1e ac ff ff       	call   1047f0 <debug_panic>
  109bd2:	83 c4 10             	add    $0x10,%esp
  109bd5:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  109bd9:	e9 4a ff ff ff       	jmp    109b28 <inode_get+0x78>
  109bde:	66 90                	xchg   %ax,%ax

00109be0 <inode_alloc>:
{
  109be0:	55                   	push   %ebp
  109be1:	57                   	push   %edi
  109be2:	56                   	push   %esi
  109be3:	53                   	push   %ebx
  109be4:	e8 b9 67 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109be9:	81 c3 0b d4 00 00    	add    $0xd40b,%ebx
  109bef:	83 ec 34             	sub    $0x34,%esp
  109bf2:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  109bf6:	8b 7c 24 48          	mov    0x48(%esp),%edi
  109bfa:	89 44 24 10          	mov    %eax,0x10(%esp)
    read_superblock(dev, &sb);
  109bfe:	8d 44 24 18          	lea    0x18(%esp),%eax
  109c02:	50                   	push   %eax
  109c03:	57                   	push   %edi
  109c04:	e8 27 fa ff ff       	call   109630 <read_superblock>
    for (inum = 1; inum < sb.ninodes; inum++) {
  109c09:	83 c4 10             	add    $0x10,%esp
  109c0c:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
  109c11:	0f 86 89 00 00 00    	jbe    109ca0 <inode_alloc+0xc0>
  109c17:	bd 01 00 00 00       	mov    $0x1,%ebp
  109c1c:	eb 17                	jmp    109c35 <inode_alloc+0x55>
  109c1e:	66 90                	xchg   %ax,%ax
        bufcache_release(bp);
  109c20:	83 ec 0c             	sub    $0xc,%esp
    for (inum = 1; inum < sb.ninodes; inum++) {
  109c23:	83 c5 01             	add    $0x1,%ebp
        bufcache_release(bp);
  109c26:	56                   	push   %esi
  109c27:	e8 a4 f5 ff ff       	call   1091d0 <bufcache_release>
    for (inum = 1; inum < sb.ninodes; inum++) {
  109c2c:	83 c4 10             	add    $0x10,%esp
  109c2f:	3b 6c 24 18          	cmp    0x18(%esp),%ebp
  109c33:	73 6b                	jae    109ca0 <inode_alloc+0xc0>
        bp = bufcache_read(dev, IBLOCK(inum));
  109c35:	89 e8                	mov    %ebp,%eax
  109c37:	83 ec 08             	sub    $0x8,%esp
  109c3a:	c1 e8 03             	shr    $0x3,%eax
  109c3d:	83 c0 02             	add    $0x2,%eax
  109c40:	50                   	push   %eax
  109c41:	57                   	push   %edi
  109c42:	e8 09 f4 ff ff       	call   109050 <bufcache_read>
        if (dip->type == 0) {  // a free inode
  109c47:	83 c4 10             	add    $0x10,%esp
        bp = bufcache_read(dev, IBLOCK(inum));
  109c4a:	89 c6                	mov    %eax,%esi
        dip = (struct dinode *) bp->data + inum % IPB;
  109c4c:	89 e8                	mov    %ebp,%eax
  109c4e:	83 e0 07             	and    $0x7,%eax
  109c51:	c1 e0 06             	shl    $0x6,%eax
  109c54:	8d 4c 06 18          	lea    0x18(%esi,%eax,1),%ecx
        if (dip->type == 0) {  // a free inode
  109c58:	66 83 39 00          	cmpw   $0x0,(%ecx)
  109c5c:	75 c2                	jne    109c20 <inode_alloc+0x40>
            memset(dip, 0, sizeof(*dip));
  109c5e:	83 ec 04             	sub    $0x4,%esp
  109c61:	6a 40                	push   $0x40
  109c63:	6a 00                	push   $0x0
  109c65:	51                   	push   %ecx
  109c66:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  109c6a:	e8 c1 a7 ff ff       	call   104430 <memset>
            dip->type = type;
  109c6f:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  109c73:	0f b7 44 24 18       	movzwl 0x18(%esp),%eax
  109c78:	66 89 01             	mov    %ax,(%ecx)
            log_write(bp);  // mark it allocated on the disk
  109c7b:	89 34 24             	mov    %esi,(%esp)
  109c7e:	e8 7d f8 ff ff       	call   109500 <log_write>
            bufcache_release(bp);
  109c83:	89 34 24             	mov    %esi,(%esp)
  109c86:	e8 45 f5 ff ff       	call   1091d0 <bufcache_release>
            return inode_get(dev, inum);
  109c8b:	58                   	pop    %eax
  109c8c:	5a                   	pop    %edx
  109c8d:	55                   	push   %ebp
  109c8e:	57                   	push   %edi
  109c8f:	e8 1c fe ff ff       	call   109ab0 <inode_get>
  109c94:	83 c4 10             	add    $0x10,%esp
}
  109c97:	83 c4 2c             	add    $0x2c,%esp
  109c9a:	5b                   	pop    %ebx
  109c9b:	5e                   	pop    %esi
  109c9c:	5f                   	pop    %edi
  109c9d:	5d                   	pop    %ebp
  109c9e:	c3                   	ret
  109c9f:	90                   	nop
    KERN_PANIC("inode_alloc: no inodes");
  109ca0:	83 ec 04             	sub    $0x4,%esp
  109ca3:	8d 83 de 68 ff ff    	lea    -0x9722(%ebx),%eax
  109ca9:	50                   	push   %eax
  109caa:	8d 83 b9 68 ff ff    	lea    -0x9747(%ebx),%eax
  109cb0:	6a 39                	push   $0x39
  109cb2:	50                   	push   %eax
  109cb3:	e8 38 ab ff ff       	call   1047f0 <debug_panic>
    return NULL;
  109cb8:	83 c4 10             	add    $0x10,%esp
  109cbb:	31 c0                	xor    %eax,%eax
}
  109cbd:	83 c4 2c             	add    $0x2c,%esp
  109cc0:	5b                   	pop    %ebx
  109cc1:	5e                   	pop    %esi
  109cc2:	5f                   	pop    %edi
  109cc3:	5d                   	pop    %ebp
  109cc4:	c3                   	ret
  109cc5:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  109ccc:	00 
  109ccd:	8d 76 00             	lea    0x0(%esi),%esi

00109cd0 <inode_dup>:
{
  109cd0:	57                   	push   %edi
  109cd1:	56                   	push   %esi
  109cd2:	53                   	push   %ebx
  109cd3:	8b 74 24 10          	mov    0x10(%esp),%esi
  109cd7:	e8 c6 66 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109cdc:	81 c3 18 d3 00 00    	add    $0xd318,%ebx
    spinlock_acquire(&inode_cache.lock);
  109ce2:	83 ec 0c             	sub    $0xc,%esp
  109ce5:	8d bb ec a7 d5 00    	lea    0xd5a7ec(%ebx),%edi
  109ceb:	57                   	push   %edi
  109cec:	e8 5f c2 ff ff       	call   105f50 <spinlock_acquire>
    ip->ref++;
  109cf1:	83 46 08 01          	addl   $0x1,0x8(%esi)
    spinlock_release(&inode_cache.lock);
  109cf5:	89 3c 24             	mov    %edi,(%esp)
  109cf8:	e8 d3 c2 ff ff       	call   105fd0 <spinlock_release>
    return ip;
  109cfd:	83 c4 10             	add    $0x10,%esp
}
  109d00:	89 f0                	mov    %esi,%eax
  109d02:	5b                   	pop    %ebx
  109d03:	5e                   	pop    %esi
  109d04:	5f                   	pop    %edi
  109d05:	c3                   	ret
  109d06:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  109d0d:	00 
  109d0e:	66 90                	xchg   %ax,%ax

00109d10 <inode_lock>:
{
  109d10:	57                   	push   %edi
  109d11:	56                   	push   %esi
  109d12:	53                   	push   %ebx
  109d13:	8b 74 24 10          	mov    0x10(%esp),%esi
  109d17:	e8 86 66 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109d1c:	81 c3 d8 d2 00 00    	add    $0xd2d8,%ebx
    if (ip == 0 || ip->ref < 1)
  109d22:	85 f6                	test   %esi,%esi
  109d24:	74 5a                	je     109d80 <inode_lock+0x70>
  109d26:	8b 46 08             	mov    0x8(%esi),%eax
  109d29:	85 c0                	test   %eax,%eax
  109d2b:	7e 53                	jle    109d80 <inode_lock+0x70>
    spinlock_acquire(&inode_cache.lock);
  109d2d:	83 ec 0c             	sub    $0xc,%esp
  109d30:	8d bb ec a7 d5 00    	lea    0xd5a7ec(%ebx),%edi
  109d36:	57                   	push   %edi
  109d37:	e8 14 c2 ff ff       	call   105f50 <spinlock_acquire>
    while (ip->flags & I_BUSY)
  109d3c:	8b 46 0c             	mov    0xc(%esi),%eax
  109d3f:	83 c4 10             	add    $0x10,%esp
  109d42:	a8 01                	test   $0x1,%al
  109d44:	74 1e                	je     109d64 <inode_lock+0x54>
  109d46:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  109d4d:	00 
  109d4e:	66 90                	xchg   %ax,%ax
        thread_sleep(ip, &inode_cache.lock);
  109d50:	83 ec 08             	sub    $0x8,%esp
  109d53:	57                   	push   %edi
  109d54:	56                   	push   %esi
  109d55:	e8 36 df ff ff       	call   107c90 <thread_sleep>
    while (ip->flags & I_BUSY)
  109d5a:	8b 46 0c             	mov    0xc(%esi),%eax
  109d5d:	83 c4 10             	add    $0x10,%esp
  109d60:	a8 01                	test   $0x1,%al
  109d62:	75 ec                	jne    109d50 <inode_lock+0x40>
    spinlock_release(&inode_cache.lock);
  109d64:	83 ec 0c             	sub    $0xc,%esp
    ip->flags |= I_BUSY;
  109d67:	83 c8 01             	or     $0x1,%eax
  109d6a:	89 46 0c             	mov    %eax,0xc(%esi)
    spinlock_release(&inode_cache.lock);
  109d6d:	57                   	push   %edi
  109d6e:	e8 5d c2 ff ff       	call   105fd0 <spinlock_release>
    if (!(ip->flags & I_VALID)) {
  109d73:	83 c4 10             	add    $0x10,%esp
  109d76:	f6 46 0c 02          	testb  $0x2,0xc(%esi)
  109d7a:	74 24                	je     109da0 <inode_lock+0x90>
}
  109d7c:	5b                   	pop    %ebx
  109d7d:	5e                   	pop    %esi
  109d7e:	5f                   	pop    %edi
  109d7f:	c3                   	ret
        KERN_PANIC("inode_lock");
  109d80:	83 ec 04             	sub    $0x4,%esp
  109d83:	8d 83 f5 68 ff ff    	lea    -0x970b(%ebx),%eax
  109d89:	50                   	push   %eax
  109d8a:	8d 83 b9 68 ff ff    	lea    -0x9747(%ebx),%eax
  109d90:	68 8d 00 00 00       	push   $0x8d
  109d95:	50                   	push   %eax
  109d96:	e8 55 aa ff ff       	call   1047f0 <debug_panic>
  109d9b:	83 c4 10             	add    $0x10,%esp
  109d9e:	eb 8d                	jmp    109d2d <inode_lock+0x1d>
        bp = bufcache_read(ip->dev, IBLOCK(ip->inum));
  109da0:	8b 46 04             	mov    0x4(%esi),%eax
  109da3:	83 ec 08             	sub    $0x8,%esp
  109da6:	c1 e8 03             	shr    $0x3,%eax
  109da9:	83 c0 02             	add    $0x2,%eax
  109dac:	50                   	push   %eax
  109dad:	ff 36                	push   (%esi)
  109daf:	e8 9c f2 ff ff       	call   109050 <bufcache_read>
        memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
  109db4:	83 c4 0c             	add    $0xc,%esp
        bp = bufcache_read(ip->dev, IBLOCK(ip->inum));
  109db7:	89 c7                	mov    %eax,%edi
        dip = (struct dinode *) bp->data + ip->inum % IPB;
  109db9:	8b 46 04             	mov    0x4(%esi),%eax
  109dbc:	83 e0 07             	and    $0x7,%eax
  109dbf:	c1 e0 06             	shl    $0x6,%eax
  109dc2:	8d 44 07 18          	lea    0x18(%edi,%eax,1),%eax
        ip->type = dip->type;
  109dc6:	8b 50 04             	mov    0x4(%eax),%edx
  109dc9:	8b 08                	mov    (%eax),%ecx
        memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
  109dcb:	83 c0 0c             	add    $0xc,%eax
        ip->type = dip->type;
  109dce:	89 56 14             	mov    %edx,0x14(%esi)
        ip->size = dip->size;
  109dd1:	8b 50 fc             	mov    -0x4(%eax),%edx
        ip->type = dip->type;
  109dd4:	89 4e 10             	mov    %ecx,0x10(%esi)
        ip->size = dip->size;
  109dd7:	89 56 18             	mov    %edx,0x18(%esi)
        memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
  109dda:	6a 34                	push   $0x34
  109ddc:	50                   	push   %eax
  109ddd:	8d 46 1c             	lea    0x1c(%esi),%eax
  109de0:	50                   	push   %eax
  109de1:	e8 8a a6 ff ff       	call   104470 <memmove>
        bufcache_release(bp);
  109de6:	89 3c 24             	mov    %edi,(%esp)
  109de9:	e8 e2 f3 ff ff       	call   1091d0 <bufcache_release>
        ip->flags |= I_VALID;
  109dee:	83 4e 0c 02          	orl    $0x2,0xc(%esi)
        if (ip->type == 0)
  109df2:	83 c4 10             	add    $0x10,%esp
  109df5:	66 83 7e 10 00       	cmpw   $0x0,0x10(%esi)
  109dfa:	75 80                	jne    109d7c <inode_lock+0x6c>
            KERN_PANIC("inode_lock: no type");
  109dfc:	83 ec 04             	sub    $0x4,%esp
  109dff:	8d 83 00 69 ff ff    	lea    -0x9700(%ebx),%eax
  109e05:	50                   	push   %eax
  109e06:	8d 83 b9 68 ff ff    	lea    -0x9747(%ebx),%eax
  109e0c:	68 a1 00 00 00       	push   $0xa1
  109e11:	50                   	push   %eax
  109e12:	e8 d9 a9 ff ff       	call   1047f0 <debug_panic>
  109e17:	83 c4 10             	add    $0x10,%esp
}
  109e1a:	5b                   	pop    %ebx
  109e1b:	5e                   	pop    %esi
  109e1c:	5f                   	pop    %edi
  109e1d:	c3                   	ret
  109e1e:	66 90                	xchg   %ax,%ax

00109e20 <inode_unlock>:
{
  109e20:	57                   	push   %edi
  109e21:	56                   	push   %esi
  109e22:	53                   	push   %ebx
  109e23:	8b 74 24 10          	mov    0x10(%esp),%esi
  109e27:	e8 76 65 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109e2c:	81 c3 c8 d1 00 00    	add    $0xd1c8,%ebx
    if (ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
  109e32:	85 f6                	test   %esi,%esi
  109e34:	74 06                	je     109e3c <inode_unlock+0x1c>
  109e36:	f6 46 0c 01          	testb  $0x1,0xc(%esi)
  109e3a:	75 4c                	jne    109e88 <inode_unlock+0x68>
        KERN_PANIC("inode_unlock");
  109e3c:	83 ec 04             	sub    $0x4,%esp
  109e3f:	8d 83 14 69 ff ff    	lea    -0x96ec(%ebx),%eax
  109e45:	50                   	push   %eax
  109e46:	8d 83 b9 68 ff ff    	lea    -0x9747(%ebx),%eax
  109e4c:	68 ac 00 00 00       	push   $0xac
  109e51:	50                   	push   %eax
  109e52:	e8 99 a9 ff ff       	call   1047f0 <debug_panic>
  109e57:	83 c4 10             	add    $0x10,%esp
    spinlock_acquire(&inode_cache.lock);
  109e5a:	83 ec 0c             	sub    $0xc,%esp
  109e5d:	8d bb ec a7 d5 00    	lea    0xd5a7ec(%ebx),%edi
  109e63:	57                   	push   %edi
  109e64:	e8 e7 c0 ff ff       	call   105f50 <spinlock_acquire>
    ip->flags &= ~I_BUSY;
  109e69:	83 66 0c fe          	andl   $0xfffffffe,0xc(%esi)
    thread_wakeup(ip);
  109e6d:	89 34 24             	mov    %esi,(%esp)
  109e70:	e8 2b df ff ff       	call   107da0 <thread_wakeup>
    spinlock_release(&inode_cache.lock);
  109e75:	89 3c 24             	mov    %edi,(%esp)
  109e78:	e8 53 c1 ff ff       	call   105fd0 <spinlock_release>
}
  109e7d:	83 c4 10             	add    $0x10,%esp
  109e80:	5b                   	pop    %ebx
  109e81:	5e                   	pop    %esi
  109e82:	5f                   	pop    %edi
  109e83:	c3                   	ret
  109e84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
  109e88:	8b 46 08             	mov    0x8(%esi),%eax
  109e8b:	85 c0                	test   %eax,%eax
  109e8d:	7f cb                	jg     109e5a <inode_unlock+0x3a>
  109e8f:	eb ab                	jmp    109e3c <inode_unlock+0x1c>
  109e91:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  109e98:	00 
  109e99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00109ea0 <inode_put>:
{
  109ea0:	55                   	push   %ebp
  109ea1:	57                   	push   %edi
  109ea2:	56                   	push   %esi
  109ea3:	53                   	push   %ebx
  109ea4:	e8 f9 64 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  109ea9:	81 c3 4b d1 00 00    	add    $0xd14b,%ebx
  109eaf:	83 ec 28             	sub    $0x28,%esp
  109eb2:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    spinlock_acquire(&inode_cache.lock);
  109eb6:	8d bb ec a7 d5 00    	lea    0xd5a7ec(%ebx),%edi
  109ebc:	57                   	push   %edi
  109ebd:	e8 8e c0 ff ff       	call   105f50 <spinlock_acquire>
    if (ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0) {
  109ec2:	8b 46 08             	mov    0x8(%esi),%eax
  109ec5:	83 c4 10             	add    $0x10,%esp
  109ec8:	83 f8 01             	cmp    $0x1,%eax
  109ecb:	74 1b                	je     109ee8 <inode_put+0x48>
    spinlock_release(&inode_cache.lock);
  109ecd:	83 ec 0c             	sub    $0xc,%esp
    ip->ref--;
  109ed0:	83 e8 01             	sub    $0x1,%eax
  109ed3:	89 46 08             	mov    %eax,0x8(%esi)
    spinlock_release(&inode_cache.lock);
  109ed6:	57                   	push   %edi
  109ed7:	e8 f4 c0 ff ff       	call   105fd0 <spinlock_release>
}
  109edc:	83 c4 2c             	add    $0x2c,%esp
  109edf:	5b                   	pop    %ebx
  109ee0:	5e                   	pop    %esi
  109ee1:	5f                   	pop    %edi
  109ee2:	5d                   	pop    %ebp
  109ee3:	c3                   	ret
  109ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0) {
  109ee8:	8b 56 0c             	mov    0xc(%esi),%edx
  109eeb:	f6 c2 02             	test   $0x2,%dl
  109eee:	74 dd                	je     109ecd <inode_put+0x2d>
  109ef0:	66 83 7e 16 00       	cmpw   $0x0,0x16(%esi)
  109ef5:	75 d6                	jne    109ecd <inode_put+0x2d>
        if (ip->flags & I_BUSY)
  109ef7:	f6 c2 01             	test   $0x1,%dl
  109efa:	0f 85 97 00 00 00    	jne    109f97 <inode_put+0xf7>
        ip->flags |= I_BUSY;
  109f00:	83 ca 01             	or     $0x1,%edx
        spinlock_release(&inode_cache.lock);
  109f03:	83 ec 0c             	sub    $0xc,%esp
  109f06:	8d 6e 1c             	lea    0x1c(%esi),%ebp
        ip->flags |= I_BUSY;
  109f09:	89 56 0c             	mov    %edx,0xc(%esi)
        spinlock_release(&inode_cache.lock);
  109f0c:	57                   	push   %edi
  109f0d:	e8 be c0 ff ff       	call   105fd0 <spinlock_release>
{
    int i, j;
    struct buf *bp;
    uint32_t *a;

    for (i = 0; i < NDIRECT; i++) {
  109f12:	8d 56 4c             	lea    0x4c(%esi),%edx
  109f15:	83 c4 10             	add    $0x10,%esp
  109f18:	eb 0d                	jmp    109f27 <inode_put+0x87>
  109f1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  109f20:	83 c5 04             	add    $0x4,%ebp
  109f23:	39 d5                	cmp    %edx,%ebp
  109f25:	74 29                	je     109f50 <inode_put+0xb0>
        if (ip->addrs[i]) {
  109f27:	8b 45 00             	mov    0x0(%ebp),%eax
  109f2a:	85 c0                	test   %eax,%eax
  109f2c:	74 f2                	je     109f20 <inode_put+0x80>
  109f2e:	89 54 24 08          	mov    %edx,0x8(%esp)
            block_free(ip->dev, ip->addrs[i]);
  109f32:	83 ec 08             	sub    $0x8,%esp
  109f35:	50                   	push   %eax
  109f36:	ff 36                	push   (%esi)
  109f38:	e8 f3 f8 ff ff       	call   109830 <block_free>
            ip->addrs[i] = 0;
  109f3d:	83 c4 10             	add    $0x10,%esp
  109f40:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
  109f47:	8b 54 24 08          	mov    0x8(%esp),%edx
  109f4b:	eb d3                	jmp    109f20 <inode_put+0x80>
  109f4d:	8d 76 00             	lea    0x0(%esi),%esi
        }
    }

    if (ip->addrs[NDIRECT]) {
  109f50:	8b 46 4c             	mov    0x4c(%esi),%eax
  109f53:	85 c0                	test   %eax,%eax
  109f55:	75 66                	jne    109fbd <inode_put+0x11d>
        block_free(ip->dev, ip->addrs[NDIRECT]);
        ip->addrs[NDIRECT] = 0;
    }

    ip->size = 0;
    inode_update(ip);
  109f57:	83 ec 0c             	sub    $0xc,%esp
    ip->size = 0;
  109f5a:	c7 46 18 00 00 00 00 	movl   $0x0,0x18(%esi)
    inode_update(ip);
  109f61:	56                   	push   %esi
  109f62:	e8 c9 fa ff ff       	call   109a30 <inode_update>
        ip->type = 0;
  109f67:	31 c0                	xor    %eax,%eax
  109f69:	66 89 46 10          	mov    %ax,0x10(%esi)
        inode_update(ip);
  109f6d:	89 34 24             	mov    %esi,(%esp)
  109f70:	e8 bb fa ff ff       	call   109a30 <inode_update>
        spinlock_acquire(&inode_cache.lock);
  109f75:	89 3c 24             	mov    %edi,(%esp)
  109f78:	e8 d3 bf ff ff       	call   105f50 <spinlock_acquire>
        ip->flags = 0;
  109f7d:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
        thread_wakeup(ip);
  109f84:	89 34 24             	mov    %esi,(%esp)
  109f87:	e8 14 de ff ff       	call   107da0 <thread_wakeup>
    ip->ref--;
  109f8c:	8b 46 08             	mov    0x8(%esi),%eax
  109f8f:	83 c4 10             	add    $0x10,%esp
  109f92:	e9 36 ff ff ff       	jmp    109ecd <inode_put+0x2d>
            KERN_PANIC("inode_put busy");
  109f97:	83 ec 04             	sub    $0x4,%esp
  109f9a:	8d 83 21 69 ff ff    	lea    -0x96df(%ebx),%eax
  109fa0:	50                   	push   %eax
  109fa1:	8d 83 b9 68 ff ff    	lea    -0x9747(%ebx),%eax
  109fa7:	68 c1 00 00 00       	push   $0xc1
  109fac:	50                   	push   %eax
  109fad:	e8 3e a8 ff ff       	call   1047f0 <debug_panic>
        ip->flags |= I_BUSY;
  109fb2:	8b 56 0c             	mov    0xc(%esi),%edx
  109fb5:	83 c4 10             	add    $0x10,%esp
  109fb8:	e9 43 ff ff ff       	jmp    109f00 <inode_put+0x60>
        bp = bufcache_read(ip->dev, ip->addrs[NDIRECT]);
  109fbd:	83 ec 08             	sub    $0x8,%esp
  109fc0:	50                   	push   %eax
  109fc1:	ff 36                	push   (%esi)
  109fc3:	e8 88 f0 ff ff       	call   109050 <bufcache_read>
  109fc8:	89 c2                	mov    %eax,%edx
  109fca:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        for (j = 0; j < NINDIRECT; j++) {
  109fce:	8d 40 18             	lea    0x18(%eax),%eax
  109fd1:	83 c4 10             	add    $0x10,%esp
  109fd4:	8d aa 18 02 00 00    	lea    0x218(%edx),%ebp
  109fda:	eb 0b                	jmp    109fe7 <inode_put+0x147>
  109fdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  109fe0:	83 c0 04             	add    $0x4,%eax
  109fe3:	39 e8                	cmp    %ebp,%eax
  109fe5:	74 1e                	je     10a005 <inode_put+0x165>
            if (a[j])
  109fe7:	8b 08                	mov    (%eax),%ecx
  109fe9:	85 c9                	test   %ecx,%ecx
  109feb:	74 f3                	je     109fe0 <inode_put+0x140>
  109fed:	89 44 24 08          	mov    %eax,0x8(%esp)
                block_free(ip->dev, a[j]);
  109ff1:	83 ec 08             	sub    $0x8,%esp
  109ff4:	51                   	push   %ecx
  109ff5:	ff 36                	push   (%esi)
  109ff7:	e8 34 f8 ff ff       	call   109830 <block_free>
  109ffc:	83 c4 10             	add    $0x10,%esp
  109fff:	8b 44 24 08          	mov    0x8(%esp),%eax
  10a003:	eb db                	jmp    109fe0 <inode_put+0x140>
        bufcache_release(bp);
  10a005:	83 ec 0c             	sub    $0xc,%esp
  10a008:	ff 74 24 18          	push   0x18(%esp)
  10a00c:	e8 bf f1 ff ff       	call   1091d0 <bufcache_release>
        block_free(ip->dev, ip->addrs[NDIRECT]);
  10a011:	5a                   	pop    %edx
  10a012:	59                   	pop    %ecx
  10a013:	ff 76 4c             	push   0x4c(%esi)
  10a016:	ff 36                	push   (%esi)
  10a018:	e8 13 f8 ff ff       	call   109830 <block_free>
        ip->addrs[NDIRECT] = 0;
  10a01d:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
  10a024:	83 c4 10             	add    $0x10,%esp
  10a027:	e9 2b ff ff ff       	jmp    109f57 <inode_put+0xb7>
  10a02c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0010a030 <inode_unlockput>:
{
  10a030:	53                   	push   %ebx
  10a031:	83 ec 14             	sub    $0x14,%esp
  10a034:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    inode_unlock(ip);
  10a038:	53                   	push   %ebx
  10a039:	e8 e2 fd ff ff       	call   109e20 <inode_unlock>
    inode_put(ip);
  10a03e:	89 5c 24 20          	mov    %ebx,0x20(%esp)
}
  10a042:	83 c4 18             	add    $0x18,%esp
  10a045:	5b                   	pop    %ebx
    inode_put(ip);
  10a046:	e9 55 fe ff ff       	jmp    109ea0 <inode_put>
  10a04b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

0010a050 <inode_stat>:

/**
 * Copy stat information from inode.
 */
void inode_stat(struct inode *ip, struct file_stat *st)
{
  10a050:	53                   	push   %ebx
  10a051:	8b 54 24 08          	mov    0x8(%esp),%edx
  10a055:	8b 44 24 0c          	mov    0xc(%esp),%eax
    st->dev = ip->dev;
  10a059:	8b 4a 04             	mov    0x4(%edx),%ecx
  10a05c:	8b 1a                	mov    (%edx),%ebx
  10a05e:	89 48 08             	mov    %ecx,0x8(%eax)
    st->ino = ip->inum;
    st->type = ip->type;
  10a061:	0f b7 4a 10          	movzwl 0x10(%edx),%ecx
    st->dev = ip->dev;
  10a065:	89 58 04             	mov    %ebx,0x4(%eax)
    st->type = ip->type;
  10a068:	66 89 08             	mov    %cx,(%eax)
    st->nlink = ip->nlink;
  10a06b:	0f b7 4a 16          	movzwl 0x16(%edx),%ecx
    st->size = ip->size;
  10a06f:	8b 52 18             	mov    0x18(%edx),%edx
    st->nlink = ip->nlink;
  10a072:	66 89 48 0c          	mov    %cx,0xc(%eax)
    st->size = ip->size;
  10a076:	89 50 10             	mov    %edx,0x10(%eax)
}
  10a079:	5b                   	pop    %ebx
  10a07a:	c3                   	ret
  10a07b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

0010a080 <inode_read>:

/**
 * Read data from inode.
 */
int inode_read(struct inode *ip, char *dst, uint32_t off, uint32_t n)
{
  10a080:	55                   	push   %ebp
  10a081:	57                   	push   %edi
  10a082:	56                   	push   %esi
  10a083:	53                   	push   %ebx
  10a084:	e8 19 63 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a089:	81 c3 6b cf 00 00    	add    $0xcf6b,%ebx
  10a08f:	83 ec 2c             	sub    $0x2c,%esp
  10a092:	8b 4c 24 40          	mov    0x40(%esp),%ecx
  10a096:	8b 44 24 44          	mov    0x44(%esp),%eax
  10a09a:	8b 6c 24 48          	mov    0x48(%esp),%ebp
    uint32_t tot, m;
    struct buf *bp;

    if (ip->type == T_DEV) {
  10a09e:	66 83 79 10 03       	cmpw   $0x3,0x10(%ecx)
{
  10a0a3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10a0a7:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    if (ip->type == T_DEV) {
  10a0ab:	0f 84 bf 00 00 00    	je     10a170 <inode_read+0xf0>
        if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
            return -1;
        return devsw[ip->major].read(ip, dst, n);
    }

    if (off > ip->size || off + n < off)
  10a0b1:	8b 79 18             	mov    0x18(%ecx),%edi
  10a0b4:	39 ef                	cmp    %ebp,%edi
  10a0b6:	0f 82 e4 00 00 00    	jb     10a1a0 <inode_read+0x120>
  10a0bc:	89 ee                	mov    %ebp,%esi
  10a0be:	31 d2                	xor    %edx,%edx
  10a0c0:	01 c6                	add    %eax,%esi
  10a0c2:	0f 92 c2             	setb   %dl
  10a0c5:	0f 82 d5 00 00 00    	jb     10a1a0 <inode_read+0x120>
        return -1;
    if (off + n > ip->size)
        n = ip->size - off;
  10a0cb:	89 7c 24 10          	mov    %edi,0x10(%esp)
  10a0cf:	29 ef                	sub    %ebp,%edi
  10a0d1:	39 74 24 10          	cmp    %esi,0x10(%esp)
  10a0d5:	0f 42 c7             	cmovb  %edi,%eax

    for (tot = 0; tot < n; tot += m, off += m, dst += m) {
  10a0d8:	85 c0                	test   %eax,%eax
  10a0da:	0f 84 88 00 00 00    	je     10a168 <inode_read+0xe8>
        bp = bufcache_read(ip->dev, bmap(ip, off / BSIZE));
        m = min(n - tot, BSIZE - off % BSIZE);
  10a0e0:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  10a0e4:	89 d7                	mov    %edx,%edi
  10a0e6:	89 44 24 10          	mov    %eax,0x10(%esp)
  10a0ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        bp = bufcache_read(ip->dev, bmap(ip, off / BSIZE));
  10a0f0:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  10a0f4:	89 ea                	mov    %ebp,%edx
  10a0f6:	c1 ea 09             	shr    $0x9,%edx
  10a0f9:	89 f0                	mov    %esi,%eax
  10a0fb:	e8 00 f8 ff ff       	call   109900 <bmap>
  10a100:	83 ec 08             	sub    $0x8,%esp
  10a103:	50                   	push   %eax
  10a104:	ff 36                	push   (%esi)
  10a106:	e8 45 ef ff ff       	call   109050 <bufcache_read>
        m = min(n - tot, BSIZE - off % BSIZE);
  10a10b:	89 e9                	mov    %ebp,%ecx
  10a10d:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
        bp = bufcache_read(ip->dev, bmap(ip, off / BSIZE));
  10a113:	89 c6                	mov    %eax,%esi
        m = min(n - tot, BSIZE - off % BSIZE);
  10a115:	58                   	pop    %eax
  10a116:	b8 00 02 00 00       	mov    $0x200,%eax
  10a11b:	5a                   	pop    %edx
  10a11c:	29 c8                	sub    %ecx,%eax
  10a11e:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  10a122:	50                   	push   %eax
  10a123:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10a127:	29 f8                	sub    %edi,%eax
  10a129:	50                   	push   %eax
  10a12a:	e8 41 b2 ff ff       	call   105370 <min>
        memmove(dst, bp->data + off % BSIZE, m);
  10a12f:	83 c4 0c             	add    $0xc,%esp
  10a132:	50                   	push   %eax
  10a133:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  10a137:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10a13b:	8d 44 0e 18          	lea    0x18(%esi,%ecx,1),%eax
  10a13f:	50                   	push   %eax
  10a140:	ff 74 24 18          	push   0x18(%esp)
  10a144:	e8 27 a3 ff ff       	call   104470 <memmove>
        bufcache_release(bp);
  10a149:	89 34 24             	mov    %esi,(%esp)
  10a14c:	e8 7f f0 ff ff       	call   1091d0 <bufcache_release>
    for (tot = 0; tot < n; tot += m, off += m, dst += m) {
  10a151:	8b 54 24 24          	mov    0x24(%esp),%edx
  10a155:	01 54 24 1c          	add    %edx,0x1c(%esp)
  10a159:	83 c4 10             	add    $0x10,%esp
  10a15c:	8b 44 24 10          	mov    0x10(%esp),%eax
  10a160:	01 d7                	add    %edx,%edi
  10a162:	01 d5                	add    %edx,%ebp
  10a164:	39 c7                	cmp    %eax,%edi
  10a166:	72 88                	jb     10a0f0 <inode_read+0x70>
    }
    return n;
}
  10a168:	83 c4 2c             	add    $0x2c,%esp
  10a16b:	5b                   	pop    %ebx
  10a16c:	5e                   	pop    %esi
  10a16d:	5f                   	pop    %edi
  10a16e:	5d                   	pop    %ebp
  10a16f:	c3                   	ret
        if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
  10a170:	0f bf 51 12          	movswl 0x12(%ecx),%edx
  10a174:	66 83 fa 09          	cmp    $0x9,%dx
  10a178:	77 26                	ja     10a1a0 <inode_read+0x120>
  10a17a:	8b 9b bc 25 d6 00    	mov    0xd625bc(%ebx),%ebx
  10a180:	8b 14 d3             	mov    (%ebx,%edx,8),%edx
  10a183:	85 d2                	test   %edx,%edx
  10a185:	74 19                	je     10a1a0 <inode_read+0x120>
        return devsw[ip->major].read(ip, dst, n);
  10a187:	89 44 24 48          	mov    %eax,0x48(%esp)
  10a18b:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10a18f:	89 4c 24 40          	mov    %ecx,0x40(%esp)
  10a193:	89 44 24 44          	mov    %eax,0x44(%esp)
}
  10a197:	83 c4 2c             	add    $0x2c,%esp
  10a19a:	5b                   	pop    %ebx
  10a19b:	5e                   	pop    %esi
  10a19c:	5f                   	pop    %edi
  10a19d:	5d                   	pop    %ebp
        return devsw[ip->major].read(ip, dst, n);
  10a19e:	ff e2                	jmp    *%edx
            return -1;
  10a1a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  10a1a5:	eb c1                	jmp    10a168 <inode_read+0xe8>
  10a1a7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a1ae:	00 
  10a1af:	90                   	nop

0010a1b0 <inode_write>:

/**
 * Write data to inode.
 */
int inode_write(struct inode *ip, char *src, uint32_t off, uint32_t n)
{
  10a1b0:	55                   	push   %ebp
  10a1b1:	57                   	push   %edi
  10a1b2:	56                   	push   %esi
  10a1b3:	53                   	push   %ebx
  10a1b4:	e8 e9 61 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a1b9:	81 c3 3b ce 00 00    	add    $0xce3b,%ebx
  10a1bf:	83 ec 2c             	sub    $0x2c,%esp
  10a1c2:	8b 44 24 44          	mov    0x44(%esp),%eax
  10a1c6:	8b 4c 24 40          	mov    0x40(%esp),%ecx
  10a1ca:	8b 6c 24 48          	mov    0x48(%esp),%ebp
  10a1ce:	89 44 24 10          	mov    %eax,0x10(%esp)
  10a1d2:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    uint32_t tot, m;
    struct buf *bp;

    if (ip->type == T_DEV) {
  10a1d6:	66 83 79 10 03       	cmpw   $0x3,0x10(%ecx)
{
  10a1db:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (ip->type == T_DEV) {
  10a1df:	0f 84 d3 00 00 00    	je     10a2b8 <inode_write+0x108>
        if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
            return -1;
        return devsw[ip->major].write(ip, src, n);
    }

    if (off > ip->size || off + n < off)
  10a1e5:	39 69 18             	cmp    %ebp,0x18(%ecx)
  10a1e8:	0f 82 13 01 00 00    	jb     10a301 <inode_write+0x151>
  10a1ee:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  10a1f2:	31 c0                	xor    %eax,%eax
  10a1f4:	89 fa                	mov    %edi,%edx
  10a1f6:	01 ea                	add    %ebp,%edx
  10a1f8:	0f 92 c0             	setb   %al
  10a1fb:	89 c6                	mov    %eax,%esi
        return -1;
    if (off + n > MAXFILE * BSIZE)
  10a1fd:	81 fa 00 18 01 00    	cmp    $0x11800,%edx
  10a203:	0f 87 f8 00 00 00    	ja     10a301 <inode_write+0x151>
  10a209:	85 f6                	test   %esi,%esi
  10a20b:	0f 85 f0 00 00 00    	jne    10a301 <inode_write+0x151>
        return -1;

    for (tot = 0; tot < n; tot += m, off += m, src += m) {
  10a211:	85 ff                	test   %edi,%edi
  10a213:	0f 84 90 00 00 00    	je     10a2a9 <inode_write+0xf9>
        bp = bufcache_read(ip->dev, bmap(ip, off / BSIZE));
        m = min(n - tot, BSIZE - off % BSIZE);
  10a219:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    for (tot = 0; tot < n; tot += m, off += m, src += m) {
  10a21d:	31 ff                	xor    %edi,%edi
  10a21f:	90                   	nop
        bp = bufcache_read(ip->dev, bmap(ip, off / BSIZE));
  10a220:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  10a224:	89 ea                	mov    %ebp,%edx
  10a226:	c1 ea 09             	shr    $0x9,%edx
  10a229:	89 f0                	mov    %esi,%eax
  10a22b:	e8 d0 f6 ff ff       	call   109900 <bmap>
  10a230:	83 ec 08             	sub    $0x8,%esp
  10a233:	50                   	push   %eax
  10a234:	ff 36                	push   (%esi)
  10a236:	e8 15 ee ff ff       	call   109050 <bufcache_read>
        m = min(n - tot, BSIZE - off % BSIZE);
  10a23b:	89 e9                	mov    %ebp,%ecx
        bp = bufcache_read(ip->dev, bmap(ip, off / BSIZE));
  10a23d:	89 c6                	mov    %eax,%esi
        m = min(n - tot, BSIZE - off % BSIZE);
  10a23f:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
  10a245:	58                   	pop    %eax
  10a246:	b8 00 02 00 00       	mov    $0x200,%eax
  10a24b:	5a                   	pop    %edx
  10a24c:	29 c8                	sub    %ecx,%eax
  10a24e:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  10a252:	50                   	push   %eax
  10a253:	8b 44 24 18          	mov    0x18(%esp),%eax
  10a257:	29 f8                	sub    %edi,%eax
  10a259:	50                   	push   %eax
  10a25a:	e8 11 b1 ff ff       	call   105370 <min>
        memmove(bp->data + off % BSIZE, src, m);
  10a25f:	83 c4 0c             	add    $0xc,%esp
  10a262:	50                   	push   %eax
  10a263:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10a267:	ff 74 24 18          	push   0x18(%esp)
  10a26b:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  10a26f:	8d 44 0e 18          	lea    0x18(%esi,%ecx,1),%eax
  10a273:	50                   	push   %eax
  10a274:	e8 f7 a1 ff ff       	call   104470 <memmove>
        log_write(bp);
  10a279:	89 34 24             	mov    %esi,(%esp)
  10a27c:	e8 7f f2 ff ff       	call   109500 <log_write>
        bufcache_release(bp);
  10a281:	89 34 24             	mov    %esi,(%esp)
  10a284:	e8 47 ef ff ff       	call   1091d0 <bufcache_release>
    for (tot = 0; tot < n; tot += m, off += m, src += m) {
  10a289:	8b 54 24 24          	mov    0x24(%esp),%edx
  10a28d:	01 54 24 20          	add    %edx,0x20(%esp)
  10a291:	83 c4 10             	add    $0x10,%esp
  10a294:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10a298:	01 d7                	add    %edx,%edi
  10a29a:	01 d5                	add    %edx,%ebp
  10a29c:	39 c7                	cmp    %eax,%edi
  10a29e:	72 80                	jb     10a220 <inode_write+0x70>
    }

    if (n > 0 && off > ip->size) {
  10a2a0:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  10a2a4:	39 69 18             	cmp    %ebp,0x18(%ecx)
  10a2a7:	72 47                	jb     10a2f0 <inode_write+0x140>
        ip->size = off;
        inode_update(ip);
    }
    return n;
  10a2a9:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  10a2ad:	83 c4 2c             	add    $0x2c,%esp
  10a2b0:	5b                   	pop    %ebx
  10a2b1:	5e                   	pop    %esi
  10a2b2:	5f                   	pop    %edi
  10a2b3:	5d                   	pop    %ebp
  10a2b4:	c3                   	ret
  10a2b5:	8d 76 00             	lea    0x0(%esi),%esi
        if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
  10a2b8:	0f bf 51 12          	movswl 0x12(%ecx),%edx
  10a2bc:	66 83 fa 09          	cmp    $0x9,%dx
  10a2c0:	77 3f                	ja     10a301 <inode_write+0x151>
  10a2c2:	8b 9b bc 25 d6 00    	mov    0xd625bc(%ebx),%ebx
  10a2c8:	8b 54 d3 04          	mov    0x4(%ebx,%edx,8),%edx
  10a2cc:	85 d2                	test   %edx,%edx
  10a2ce:	74 31                	je     10a301 <inode_write+0x151>
        return devsw[ip->major].write(ip, src, n);
  10a2d0:	89 44 24 48          	mov    %eax,0x48(%esp)
  10a2d4:	8b 44 24 10          	mov    0x10(%esp),%eax
  10a2d8:	89 4c 24 40          	mov    %ecx,0x40(%esp)
  10a2dc:	89 44 24 44          	mov    %eax,0x44(%esp)
}
  10a2e0:	83 c4 2c             	add    $0x2c,%esp
  10a2e3:	5b                   	pop    %ebx
  10a2e4:	5e                   	pop    %esi
  10a2e5:	5f                   	pop    %edi
  10a2e6:	5d                   	pop    %ebp
        return devsw[ip->major].write(ip, src, n);
  10a2e7:	ff e2                	jmp    *%edx
  10a2e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        inode_update(ip);
  10a2f0:	83 ec 0c             	sub    $0xc,%esp
        ip->size = off;
  10a2f3:	89 69 18             	mov    %ebp,0x18(%ecx)
        inode_update(ip);
  10a2f6:	51                   	push   %ecx
  10a2f7:	e8 34 f7 ff ff       	call   109a30 <inode_update>
  10a2fc:	83 c4 10             	add    $0x10,%esp
  10a2ff:	eb a8                	jmp    10a2a9 <inode_write+0xf9>
            return -1;
  10a301:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  10a306:	eb a5                	jmp    10a2ad <inode_write+0xfd>
  10a308:	66 90                	xchg   %ax,%ax
  10a30a:	66 90                	xchg   %ax,%ax
  10a30c:	66 90                	xchg   %ax,%ax
  10a30e:	66 90                	xchg   %ax,%ax

0010a310 <dir_namecmp>:
#include "dir.h"

// Directories

int dir_namecmp(const char *s, const char *t)
{
  10a310:	53                   	push   %ebx
  10a311:	e8 8c 60 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a316:	81 c3 de cc 00 00    	add    $0xccde,%ebx
  10a31c:	83 ec 0c             	sub    $0xc,%esp
    return strncmp(s, t, DIRSIZ);
  10a31f:	6a 0e                	push   $0xe
  10a321:	ff 74 24 1c          	push   0x1c(%esp)
  10a325:	ff 74 24 1c          	push   0x1c(%esp)
  10a329:	e8 c2 a1 ff ff       	call   1044f0 <strncmp>
}
  10a32e:	83 c4 18             	add    $0x18,%esp
  10a331:	5b                   	pop    %ebx
  10a332:	c3                   	ret
  10a333:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a33a:	00 
  10a33b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

0010a340 <dir_lookup>:
/**
 * Look for a directory entry in a directory.
 * If found, set *poff to byte offset of entry.
 */
struct inode *dir_lookup(struct inode *dp, char *name, uint32_t * poff)
{
  10a340:	55                   	push   %ebp
  10a341:	57                   	push   %edi
  10a342:	56                   	push   %esi
  10a343:	53                   	push   %ebx
  10a344:	e8 59 60 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a349:	81 c3 ab cc 00 00    	add    $0xccab,%ebx
  10a34f:	83 ec 2c             	sub    $0x2c,%esp
  10a352:	8b 7c 24 40          	mov    0x40(%esp),%edi
    uint32_t off;
    struct dirent de;

    if (dp->type != T_DIR)
  10a356:	66 83 7f 10 01       	cmpw   $0x1,0x10(%edi)
  10a35b:	74 1b                	je     10a378 <dir_lookup+0x38>
        KERN_PANIC("dir_lookup not DIR");
  10a35d:	83 ec 04             	sub    $0x4,%esp
  10a360:	8d 83 30 69 ff ff    	lea    -0x96d0(%ebx),%eax
  10a366:	50                   	push   %eax
  10a367:	8d 83 43 69 ff ff    	lea    -0x96bd(%ebx),%eax
  10a36d:	6a 18                	push   $0x18
  10a36f:	50                   	push   %eax
  10a370:	e8 7b a4 ff ff       	call   1047f0 <debug_panic>
  10a375:	83 c4 10             	add    $0x10,%esp

    for (off = 0; off < dp->size; off += sizeof(struct dirent)) {
  10a378:	8b 4f 18             	mov    0x18(%edi),%ecx
  10a37b:	85 c9                	test   %ecx,%ecx
  10a37d:	74 7f                	je     10a3fe <dir_lookup+0xbe>
  10a37f:	8d 44 24 12          	lea    0x12(%esp),%eax
  10a383:	31 f6                	xor    %esi,%esi
  10a385:	8d 6c 24 10          	lea    0x10(%esp),%ebp
  10a389:	89 44 24 04          	mov    %eax,0x4(%esp)
        KERN_ASSERT(inode_read(dp, (char *) &de, off, sizeof(struct dirent)) == sizeof(struct dirent));
  10a38d:	8d 83 64 74 ff ff    	lea    -0x8b9c(%ebx),%eax
  10a393:	89 44 24 08          	mov    %eax,0x8(%esp)
  10a397:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  10a39d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10a3a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  10a3a8:	6a 10                	push   $0x10
  10a3aa:	56                   	push   %esi
  10a3ab:	55                   	push   %ebp
  10a3ac:	57                   	push   %edi
  10a3ad:	e8 ce fc ff ff       	call   10a080 <inode_read>
  10a3b2:	83 c4 10             	add    $0x10,%esp
  10a3b5:	83 f8 10             	cmp    $0x10,%eax
  10a3b8:	74 19                	je     10a3d3 <dir_lookup+0x93>
  10a3ba:	8d 83 43 69 ff ff    	lea    -0x96bd(%ebx),%eax
  10a3c0:	ff 74 24 08          	push   0x8(%esp)
  10a3c4:	ff 74 24 10          	push   0x10(%esp)
  10a3c8:	6a 1b                	push   $0x1b
  10a3ca:	50                   	push   %eax
  10a3cb:	e8 20 a4 ff ff       	call   1047f0 <debug_panic>
  10a3d0:	83 c4 10             	add    $0x10,%esp
    return strncmp(s, t, DIRSIZ);
  10a3d3:	83 ec 04             	sub    $0x4,%esp
  10a3d6:	6a 0e                	push   $0xe
  10a3d8:	ff 74 24 4c          	push   0x4c(%esp)
  10a3dc:	ff 74 24 10          	push   0x10(%esp)
  10a3e0:	e8 0b a1 ff ff       	call   1044f0 <strncmp>
        if (dir_namecmp(de.name, name) == 0 && de.inum != 0) {
  10a3e5:	83 c4 10             	add    $0x10,%esp
  10a3e8:	85 c0                	test   %eax,%eax
  10a3ea:	75 0a                	jne    10a3f6 <dir_lookup+0xb6>
  10a3ec:	0f b7 44 24 10       	movzwl 0x10(%esp),%eax
  10a3f1:	66 85 c0             	test   %ax,%ax
  10a3f4:	75 1a                	jne    10a410 <dir_lookup+0xd0>
    for (off = 0; off < dp->size; off += sizeof(struct dirent)) {
  10a3f6:	83 c6 10             	add    $0x10,%esi
  10a3f9:	3b 77 18             	cmp    0x18(%edi),%esi
  10a3fc:	72 aa                	jb     10a3a8 <dir_lookup+0x68>
            return inode_get(dp->dev, de.inum);
        }
    }

    return NULL;
}
  10a3fe:	83 c4 2c             	add    $0x2c,%esp
    return NULL;
  10a401:	31 c0                	xor    %eax,%eax
}
  10a403:	5b                   	pop    %ebx
  10a404:	5e                   	pop    %esi
  10a405:	5f                   	pop    %edi
  10a406:	5d                   	pop    %ebp
  10a407:	c3                   	ret
  10a408:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a40f:	00 
            if (poff != NULL) {
  10a410:	8b 54 24 48          	mov    0x48(%esp),%edx
  10a414:	85 d2                	test   %edx,%edx
  10a416:	74 06                	je     10a41e <dir_lookup+0xde>
                *poff = off;
  10a418:	8b 54 24 48          	mov    0x48(%esp),%edx
  10a41c:	89 32                	mov    %esi,(%edx)
            return inode_get(dp->dev, de.inum);
  10a41e:	83 ec 08             	sub    $0x8,%esp
  10a421:	50                   	push   %eax
  10a422:	ff 37                	push   (%edi)
  10a424:	e8 87 f6 ff ff       	call   109ab0 <inode_get>
  10a429:	83 c4 10             	add    $0x10,%esp
}
  10a42c:	83 c4 2c             	add    $0x2c,%esp
  10a42f:	5b                   	pop    %ebx
  10a430:	5e                   	pop    %esi
  10a431:	5f                   	pop    %edi
  10a432:	5d                   	pop    %ebp
  10a433:	c3                   	ret
  10a434:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a43b:	00 
  10a43c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0010a440 <dir_link>:

// Write a new directory entry (name, inum) into the directory dp.
int dir_link(struct inode *dp, char *name, uint32_t inum)
{
  10a440:	55                   	push   %ebp
  10a441:	57                   	push   %edi
  10a442:	56                   	push   %esi
  10a443:	53                   	push   %ebx
  10a444:	e8 59 5f ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a449:	81 c3 ab cb 00 00    	add    $0xcbab,%ebx
  10a44f:	83 ec 40             	sub    $0x40,%esp
  10a452:	8b 74 24 54          	mov    0x54(%esp),%esi
    uint32_t off;
    struct inode *tmp;
    struct dirent de;

    // Check that name is not present.
    if ((tmp = dir_lookup(dp, name, &off)) != NULL) {
  10a456:	8d 44 24 20          	lea    0x20(%esp),%eax
  10a45a:	50                   	push   %eax
  10a45b:	ff 74 24 5c          	push   0x5c(%esp)
  10a45f:	56                   	push   %esi
  10a460:	e8 db fe ff ff       	call   10a340 <dir_lookup>
  10a465:	83 c4 10             	add    $0x10,%esp
  10a468:	85 c0                	test   %eax,%eax
  10a46a:	0f 85 d1 00 00 00    	jne    10a541 <dir_link+0x101>
        inode_put(tmp);
        return -1;
    }

    // Look for an empty dirent.
    for (off = 0; off < dp->size; off += sizeof(struct dirent)) {
  10a470:	8b 6e 18             	mov    0x18(%esi),%ebp
  10a473:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
  10a47a:	00 
  10a47b:	8d 7c 24 20          	lea    0x20(%esp),%edi
  10a47f:	85 ed                	test   %ebp,%ebp
  10a481:	74 5c                	je     10a4df <dir_link+0x9f>
        KERN_ASSERT(inode_read(dp, (char *) &de, off, sizeof(struct dirent)) == sizeof(struct dirent));
  10a483:	8d 83 64 74 ff ff    	lea    -0x8b9c(%ebx),%eax
    for (off = 0; off < dp->size; off += sizeof(struct dirent)) {
  10a489:	31 ed                	xor    %ebp,%ebp
  10a48b:	8d 7c 24 20          	lea    0x20(%esp),%edi
        KERN_ASSERT(inode_read(dp, (char *) &de, off, sizeof(struct dirent)) == sizeof(struct dirent));
  10a48f:	89 44 24 08          	mov    %eax,0x8(%esp)
  10a493:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  10a499:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10a49d:	eb 0d                	jmp    10a4ac <dir_link+0x6c>
  10a49f:	90                   	nop
    for (off = 0; off < dp->size; off += sizeof(struct dirent)) {
  10a4a0:	83 c5 10             	add    $0x10,%ebp
  10a4a3:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
  10a4a7:	3b 6e 18             	cmp    0x18(%esi),%ebp
  10a4aa:	73 33                	jae    10a4df <dir_link+0x9f>
        KERN_ASSERT(inode_read(dp, (char *) &de, off, sizeof(struct dirent)) == sizeof(struct dirent));
  10a4ac:	6a 10                	push   $0x10
  10a4ae:	55                   	push   %ebp
  10a4af:	57                   	push   %edi
  10a4b0:	56                   	push   %esi
  10a4b1:	e8 ca fb ff ff       	call   10a080 <inode_read>
  10a4b6:	83 c4 10             	add    $0x10,%esp
  10a4b9:	83 f8 10             	cmp    $0x10,%eax
  10a4bc:	74 19                	je     10a4d7 <dir_link+0x97>
  10a4be:	8d 83 43 69 ff ff    	lea    -0x96bd(%ebx),%eax
  10a4c4:	ff 74 24 08          	push   0x8(%esp)
  10a4c8:	ff 74 24 10          	push   0x10(%esp)
  10a4cc:	6a 36                	push   $0x36
  10a4ce:	50                   	push   %eax
  10a4cf:	e8 1c a3 ff ff       	call   1047f0 <debug_panic>
  10a4d4:	83 c4 10             	add    $0x10,%esp
        if (de.inum == 0) {
  10a4d7:	66 83 7c 24 20 00    	cmpw   $0x0,0x20(%esp)
  10a4dd:	75 c1                	jne    10a4a0 <dir_link+0x60>
            break;
        }
    }

    de.inum = inum;
  10a4df:	8b 44 24 58          	mov    0x58(%esp),%eax
    strncpy(de.name, name, DIRSIZ);
  10a4e3:	83 ec 04             	sub    $0x4,%esp
    de.inum = inum;
  10a4e6:	66 89 44 24 24       	mov    %ax,0x24(%esp)
    strncpy(de.name, name, DIRSIZ);
  10a4eb:	6a 0e                	push   $0xe
  10a4ed:	ff 74 24 5c          	push   0x5c(%esp)
  10a4f1:	8d 44 24 2e          	lea    0x2e(%esp),%eax
  10a4f5:	50                   	push   %eax
  10a4f6:	e8 85 a1 ff ff       	call   104680 <strncpy>
    KERN_ASSERT(inode_write(dp, (char *) &de, off, sizeof(struct dirent)) == sizeof(struct dirent));
  10a4fb:	6a 10                	push   $0x10
  10a4fd:	55                   	push   %ebp
  10a4fe:	57                   	push   %edi
  10a4ff:	56                   	push   %esi
  10a500:	e8 ab fc ff ff       	call   10a1b0 <inode_write>
  10a505:	83 c4 20             	add    $0x20,%esp
  10a508:	83 f8 10             	cmp    $0x10,%eax
  10a50b:	75 13                	jne    10a520 <dir_link+0xe0>
    return 0;
  10a50d:	31 c0                	xor    %eax,%eax
}
  10a50f:	83 c4 3c             	add    $0x3c,%esp
  10a512:	5b                   	pop    %ebx
  10a513:	5e                   	pop    %esi
  10a514:	5f                   	pop    %edi
  10a515:	5d                   	pop    %ebp
  10a516:	c3                   	ret
  10a517:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a51e:	00 
  10a51f:	90                   	nop
    KERN_ASSERT(inode_write(dp, (char *) &de, off, sizeof(struct dirent)) == sizeof(struct dirent));
  10a520:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
  10a526:	50                   	push   %eax
  10a527:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  10a52d:	50                   	push   %eax
  10a52e:	8d 83 43 69 ff ff    	lea    -0x96bd(%ebx),%eax
  10a534:	6a 3e                	push   $0x3e
  10a536:	50                   	push   %eax
  10a537:	e8 b4 a2 ff ff       	call   1047f0 <debug_panic>
  10a53c:	83 c4 10             	add    $0x10,%esp
  10a53f:	eb cc                	jmp    10a50d <dir_link+0xcd>
        inode_put(tmp);
  10a541:	83 ec 0c             	sub    $0xc,%esp
  10a544:	50                   	push   %eax
  10a545:	e8 56 f9 ff ff       	call   109ea0 <inode_put>
        return -1;
  10a54a:	83 c4 10             	add    $0x10,%esp
  10a54d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  10a552:	eb bb                	jmp    10a50f <dir_link+0xcf>
  10a554:	66 90                	xchg   %ax,%ax
  10a556:	66 90                	xchg   %ax,%ax
  10a558:	66 90                	xchg   %ax,%ax
  10a55a:	66 90                	xchg   %ax,%ax
  10a55c:	66 90                	xchg   %ax,%ax
  10a55e:	66 90                	xchg   %ax,%ax

0010a560 <namex>:
 * If nameiparent is true, return the inode for the parent and copy the final
 * path element into name, which must have room for DIRSIZ bytes.
 * Returns 0 in the case of error.
 */
static struct inode *namex(char *path, bool nameiparent, char *name)
{
  10a560:	55                   	push   %ebp
  10a561:	57                   	push   %edi
  10a562:	89 cf                	mov    %ecx,%edi
  10a564:	56                   	push   %esi
  10a565:	89 c6                	mov    %eax,%esi
  10a567:	53                   	push   %ebx
  10a568:	e8 35 5e ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a56d:	81 c3 87 ca 00 00    	add    $0xca87,%ebx
  10a573:	83 ec 1c             	sub    $0x1c,%esp
    struct inode *ip, *next;

    // If path is a full path, get the pointer to the root inode. Otherwise get
    // the inode corresponding to the current working directory.
    if (*path == '/') {
  10a576:	80 38 2f             	cmpb   $0x2f,(%eax)
{
  10a579:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10a57d:	88 54 24 0b          	mov    %dl,0xb(%esp)
    if (*path == '/') {
  10a581:	0f 84 f0 00 00 00    	je     10a677 <namex+0x117>
        ip = inode_get(ROOTDEV, ROOTINO);
    } else {
        ip = inode_dup((struct inode *) tcb_get_cwd(get_curid()));
  10a587:	e8 94 d4 ff ff       	call   107a20 <get_curid>
  10a58c:	83 ec 0c             	sub    $0xc,%esp
  10a58f:	50                   	push   %eax
  10a590:	e8 0b d1 ff ff       	call   1076a0 <tcb_get_cwd>
  10a595:	89 04 24             	mov    %eax,(%esp)
  10a598:	e8 33 f7 ff ff       	call   109cd0 <inode_dup>
  10a59d:	89 c5                	mov    %eax,%ebp
  10a59f:	89 f8                	mov    %edi,%eax
  10a5a1:	83 c4 10             	add    $0x10,%esp
  10a5a4:	89 ef                	mov    %ebp,%edi
  10a5a6:	89 c5                	mov    %eax,%ebp
  10a5a8:	eb 09                	jmp    10a5b3 <namex+0x53>
  10a5aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        path++;
  10a5b0:	83 c6 01             	add    $0x1,%esi
    while (*path == '/') {
  10a5b3:	0f b6 06             	movzbl (%esi),%eax
  10a5b6:	3c 2f                	cmp    $0x2f,%al
  10a5b8:	74 f6                	je     10a5b0 <namex+0x50>
    if (*path == '\0') {
  10a5ba:	84 c0                	test   %al,%al
  10a5bc:	0f 84 9e 00 00 00    	je     10a660 <namex+0x100>
    while (*path != '/' && *path != '\0') {
  10a5c2:	0f b6 06             	movzbl (%esi),%eax
  10a5c5:	3c 2f                	cmp    $0x2f,%al
  10a5c7:	0f 84 a6 00 00 00    	je     10a673 <namex+0x113>
    int len = 0;
  10a5cd:	31 c9                	xor    %ecx,%ecx
    while (*path != '/' && *path != '\0') {
  10a5cf:	84 c0                	test   %al,%al
  10a5d1:	0f 84 9c 00 00 00    	je     10a673 <namex+0x113>
  10a5d7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a5de:	00 
  10a5df:	90                   	nop
        if (len < DIRSIZ - 1) {
  10a5e0:	83 f9 0c             	cmp    $0xc,%ecx
  10a5e3:	7f 07                	jg     10a5ec <namex+0x8c>
            name[len] = *path;
  10a5e5:	88 44 0d 00          	mov    %al,0x0(%ebp,%ecx,1)
            len++;
  10a5e9:	83 c1 01             	add    $0x1,%ecx
    while (*path != '/' && *path != '\0') {
  10a5ec:	0f b6 46 01          	movzbl 0x1(%esi),%eax
        path++;
  10a5f0:	83 c6 01             	add    $0x1,%esi
    while (*path != '/' && *path != '\0') {
  10a5f3:	3c 2f                	cmp    $0x2f,%al
  10a5f5:	74 04                	je     10a5fb <namex+0x9b>
  10a5f7:	84 c0                	test   %al,%al
  10a5f9:	75 e5                	jne    10a5e0 <namex+0x80>
    name[len] = '\0';
  10a5fb:	01 e9                	add    %ebp,%ecx
    while (*path == '/') {
  10a5fd:	3c 2f                	cmp    $0x2f,%al
  10a5ff:	75 0f                	jne    10a610 <namex+0xb0>
  10a601:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        path++;
  10a608:	83 c6 01             	add    $0x1,%esi
    while (*path == '/') {
  10a60b:	80 3e 2f             	cmpb   $0x2f,(%esi)
  10a60e:	74 f8                	je     10a608 <namex+0xa8>
    }

    while ((path = skipelem(path, name)) != 0) {
        inode_lock(ip);
  10a610:	83 ec 0c             	sub    $0xc,%esp
    name[len] = '\0';
  10a613:	c6 01 00             	movb   $0x0,(%ecx)
        inode_lock(ip);
  10a616:	57                   	push   %edi
  10a617:	e8 f4 f6 ff ff       	call   109d10 <inode_lock>
        if (ip->type != T_DIR) {
  10a61c:	83 c4 10             	add    $0x10,%esp
  10a61f:	66 83 7f 10 01       	cmpw   $0x1,0x10(%edi)
  10a624:	75 62                	jne    10a688 <namex+0x128>
            inode_unlockput(ip);
            return NULL;
        }

        if (nameiparent && *path == '\0') {
  10a626:	80 7c 24 0b 00       	cmpb   $0x0,0xb(%esp)
  10a62b:	74 05                	je     10a632 <namex+0xd2>
  10a62d:	80 3e 00             	cmpb   $0x0,(%esi)
  10a630:	74 6e                	je     10a6a0 <namex+0x140>
            inode_unlock(ip);
            return ip;
        }

        next = dir_lookup(ip, name, NULL);
  10a632:	83 ec 04             	sub    $0x4,%esp
  10a635:	6a 00                	push   $0x0
  10a637:	55                   	push   %ebp
  10a638:	57                   	push   %edi
  10a639:	e8 02 fd ff ff       	call   10a340 <dir_lookup>
        inode_unlockput(ip);
  10a63e:	89 3c 24             	mov    %edi,(%esp)
        next = dir_lookup(ip, name, NULL);
  10a641:	89 44 24 14          	mov    %eax,0x14(%esp)
        inode_unlockput(ip);
  10a645:	e8 e6 f9 ff ff       	call   10a030 <inode_unlockput>

        // If next is NULL then the directory doesn't exist and we should stop.
        if (next == NULL) {
  10a64a:	8b 44 24 14          	mov    0x14(%esp),%eax
  10a64e:	83 c4 10             	add    $0x10,%esp
  10a651:	85 c0                	test   %eax,%eax
  10a653:	74 3f                	je     10a694 <namex+0x134>
            return NULL;
        }
        ip = next;
  10a655:	89 c7                	mov    %eax,%edi
    while (*path == '/') {
  10a657:	e9 57 ff ff ff       	jmp    10a5b3 <namex+0x53>
  10a65c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    }
    if (nameiparent) {
  10a660:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%esp)
  10a665:	89 fd                	mov    %edi,%ebp
  10a667:	75 4f                	jne    10a6b8 <namex+0x158>
        inode_put(ip);
        return NULL;
    }
    return ip;
}
  10a669:	83 c4 1c             	add    $0x1c,%esp
  10a66c:	89 e8                	mov    %ebp,%eax
  10a66e:	5b                   	pop    %ebx
  10a66f:	5e                   	pop    %esi
  10a670:	5f                   	pop    %edi
  10a671:	5d                   	pop    %ebp
  10a672:	c3                   	ret
    while (*path != '/' && *path != '\0') {
  10a673:	89 e9                	mov    %ebp,%ecx
  10a675:	eb 86                	jmp    10a5fd <namex+0x9d>
        ip = inode_get(ROOTDEV, ROOTINO);
  10a677:	83 ec 08             	sub    $0x8,%esp
  10a67a:	6a 01                	push   $0x1
  10a67c:	6a 01                	push   $0x1
  10a67e:	e8 2d f4 ff ff       	call   109ab0 <inode_get>
  10a683:	e9 15 ff ff ff       	jmp    10a59d <namex+0x3d>
            inode_unlockput(ip);
  10a688:	83 ec 0c             	sub    $0xc,%esp
  10a68b:	57                   	push   %edi
  10a68c:	e8 9f f9 ff ff       	call   10a030 <inode_unlockput>
            return NULL;
  10a691:	83 c4 10             	add    $0x10,%esp
  10a694:	31 ed                	xor    %ebp,%ebp
}
  10a696:	83 c4 1c             	add    $0x1c,%esp
  10a699:	89 e8                	mov    %ebp,%eax
  10a69b:	5b                   	pop    %ebx
  10a69c:	5e                   	pop    %esi
  10a69d:	5f                   	pop    %edi
  10a69e:	5d                   	pop    %ebp
  10a69f:	c3                   	ret
            inode_unlock(ip);
  10a6a0:	83 ec 0c             	sub    $0xc,%esp
  10a6a3:	89 fd                	mov    %edi,%ebp
  10a6a5:	57                   	push   %edi
  10a6a6:	e8 75 f7 ff ff       	call   109e20 <inode_unlock>
            return ip;
  10a6ab:	83 c4 10             	add    $0x10,%esp
}
  10a6ae:	89 e8                	mov    %ebp,%eax
  10a6b0:	83 c4 1c             	add    $0x1c,%esp
  10a6b3:	5b                   	pop    %ebx
  10a6b4:	5e                   	pop    %esi
  10a6b5:	5f                   	pop    %edi
  10a6b6:	5d                   	pop    %ebp
  10a6b7:	c3                   	ret
        inode_put(ip);
  10a6b8:	83 ec 0c             	sub    $0xc,%esp
            return NULL;
  10a6bb:	31 ed                	xor    %ebp,%ebp
        inode_put(ip);
  10a6bd:	57                   	push   %edi
  10a6be:	e8 dd f7 ff ff       	call   109ea0 <inode_put>
        return NULL;
  10a6c3:	83 c4 10             	add    $0x10,%esp
  10a6c6:	eb ce                	jmp    10a696 <namex+0x136>
  10a6c8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a6cf:	00 

0010a6d0 <namei>:

/**
 * Return the inode corresponding to path.
 */
struct inode *namei(char *path)
{
  10a6d0:	83 ec 1c             	sub    $0x1c,%esp
    char name[DIRSIZ];
    return namex(path, FALSE, name);
  10a6d3:	31 d2                	xor    %edx,%edx
  10a6d5:	8b 44 24 20          	mov    0x20(%esp),%eax
  10a6d9:	8d 4c 24 02          	lea    0x2(%esp),%ecx
  10a6dd:	e8 7e fe ff ff       	call   10a560 <namex>
}
  10a6e2:	83 c4 1c             	add    $0x1c,%esp
  10a6e5:	c3                   	ret
  10a6e6:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a6ed:	00 
  10a6ee:	66 90                	xchg   %ax,%ax

0010a6f0 <nameiparent>:
 * Return the inode corresponding to path's parent directory and copy the final
 * element into name.
 */
struct inode *nameiparent(char *path, char *name)
{
    return namex(path, TRUE, name);
  10a6f0:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  10a6f4:	8b 44 24 04          	mov    0x4(%esp),%eax
  10a6f8:	ba 01 00 00 00       	mov    $0x1,%edx
  10a6fd:	e9 5e fe ff ff       	jmp    10a560 <namex>
  10a702:	66 90                	xchg   %ax,%ax
  10a704:	66 90                	xchg   %ax,%ax
  10a706:	66 90                	xchg   %ax,%ax
  10a708:	66 90                	xchg   %ax,%ax
  10a70a:	66 90                	xchg   %ax,%ax
  10a70c:	66 90                	xchg   %ax,%ax
  10a70e:	66 90                	xchg   %ax,%ax

0010a710 <file_init>:
    spinlock_t lock;
    struct file file[NFILE];
} ftable;

void file_init(void)
{
  10a710:	53                   	push   %ebx
  10a711:	e8 8c 5c ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a716:	81 c3 de c8 00 00    	add    $0xc8de,%ebx
  10a71c:	83 ec 14             	sub    $0x14,%esp
    spinlock_init(&ftable.lock);
  10a71f:	8d 83 cc 25 d6 00    	lea    0xd625cc(%ebx),%eax
  10a725:	50                   	push   %eax
  10a726:	e8 95 b7 ff ff       	call   105ec0 <spinlock_init>
}
  10a72b:	83 c4 18             	add    $0x18,%esp
  10a72e:	5b                   	pop    %ebx
  10a72f:	c3                   	ret

0010a730 <file_flock>:

int file_flock(struct file *f, int operation) {
  10a730:	57                   	push   %edi
  10a731:	56                   	push   %esi
  10a732:	53                   	push   %ebx
  10a733:	e8 6a 5c ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a738:	81 c3 bc c8 00 00    	add    $0xc8bc,%ebx
  10a73e:	83 ec 20             	sub    $0x20,%esp
  10a741:	8b 74 24 30          	mov    0x30(%esp),%esi
  10a745:	8b 7c 24 34          	mov    0x34(%esp),%edi
/**
 * Get metadata about file f.
 */
int file_stat(struct file *f, struct file_stat *st)
{
    if (f->type == FD_INODE) {
  10a749:	83 3e 02             	cmpl   $0x2,(%esi)
  10a74c:	0f 85 be 00 00 00    	jne    10a810 <file_flock+0xe0>
        inode_lock(f->ip);
  10a752:	83 ec 0c             	sub    $0xc,%esp
  10a755:	ff 76 0c             	push   0xc(%esi)
  10a758:	e8 b3 f5 ff ff       	call   109d10 <inode_lock>
        inode_stat(f->ip, st);
  10a75d:	58                   	pop    %eax
  10a75e:	5a                   	pop    %edx
  10a75f:	8d 44 24 14          	lea    0x14(%esp),%eax
  10a763:	50                   	push   %eax
  10a764:	ff 76 0c             	push   0xc(%esi)
  10a767:	e8 e4 f8 ff ff       	call   10a050 <inode_stat>
        inode_unlock(f->ip);
  10a76c:	59                   	pop    %ecx
  10a76d:	ff 76 0c             	push   0xc(%esi)
  10a770:	e8 ab f6 ff ff       	call   109e20 <inode_unlock>
    if (stat.type != T_FILE) return -1;
  10a775:	83 c4 10             	add    $0x10,%esp
  10a778:	66 83 7c 24 0c 02    	cmpw   $0x2,0xc(%esp)
  10a77e:	0f 85 8c 00 00 00    	jne    10a810 <file_flock+0xe0>
    if (operation & LOCK_EX) {
  10a784:	f7 c7 02 00 00 00    	test   $0x2,%edi
  10a78a:	74 54                	je     10a7e0 <file_flock+0xb0>
        if (operation & LOCK_SH || operation & LOCK_UN) return -1; 
  10a78c:	f7 c7 05 00 00 00    	test   $0x5,%edi
  10a792:	75 7c                	jne    10a810 <file_flock+0xe0>
        if (f->holding_flock) {
  10a794:	80 7e 14 00          	cmpb   $0x0,0x14(%esi)
            if (flock_release(&f->ip->flock) == -1) return -1;
  10a798:	8b 46 0c             	mov    0xc(%esi),%eax
        if (f->holding_flock) {
  10a79b:	74 1b                	je     10a7b8 <file_flock+0x88>
            if (flock_release(&f->ip->flock) == -1) return -1;
  10a79d:	83 ec 0c             	sub    $0xc,%esp
  10a7a0:	83 c0 50             	add    $0x50,%eax
            f->holding_flock = FALSE;
  10a7a3:	c6 46 14 00          	movb   $0x0,0x14(%esi)
            if (flock_release(&f->ip->flock) == -1) return -1;
  10a7a7:	50                   	push   %eax
  10a7a8:	e8 23 19 00 00       	call   10c0d0 <flock_release>
  10a7ad:	83 c4 10             	add    $0x10,%esp
  10a7b0:	83 f8 ff             	cmp    $0xffffffff,%eax
  10a7b3:	74 5b                	je     10a810 <file_flock+0xe0>
  10a7b5:	8b 46 0c             	mov    0xc(%esi),%eax
        result = flock_acquire(&f->ip->flock, operation);
  10a7b8:	83 ec 08             	sub    $0x8,%esp
  10a7bb:	83 c0 50             	add    $0x50,%eax
  10a7be:	57                   	push   %edi
  10a7bf:	50                   	push   %eax
  10a7c0:	e8 6b 17 00 00       	call   10bf30 <flock_acquire>
        if (result >= 0) f->holding_flock = TRUE;
  10a7c5:	83 c4 10             	add    $0x10,%esp
  10a7c8:	85 c0                	test   %eax,%eax
  10a7ca:	78 04                	js     10a7d0 <file_flock+0xa0>
  10a7cc:	c6 46 14 01          	movb   $0x1,0x14(%esi)
}
  10a7d0:	83 c4 20             	add    $0x20,%esp
  10a7d3:	5b                   	pop    %ebx
  10a7d4:	5e                   	pop    %esi
  10a7d5:	5f                   	pop    %edi
  10a7d6:	c3                   	ret
  10a7d7:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a7de:	00 
  10a7df:	90                   	nop
    } else if (operation & LOCK_SH) {
  10a7e0:	f7 c7 01 00 00 00    	test   $0x1,%edi
  10a7e6:	74 38                	je     10a820 <file_flock+0xf0>
        if (operation & LOCK_EX || operation & LOCK_UN) return -1;
  10a7e8:	f7 c7 06 00 00 00    	test   $0x6,%edi
  10a7ee:	75 20                	jne    10a810 <file_flock+0xe0>
        if (f->holding_flock) {
  10a7f0:	80 7e 14 00          	cmpb   $0x0,0x14(%esi)
            if (flock_release(&f->ip->flock) == -1) return -1;
  10a7f4:	8b 46 0c             	mov    0xc(%esi),%eax
        if (f->holding_flock) {
  10a7f7:	74 bf                	je     10a7b8 <file_flock+0x88>
            if (flock_release(&f->ip->flock) < 0) return -1;
  10a7f9:	83 ec 0c             	sub    $0xc,%esp
  10a7fc:	83 c0 50             	add    $0x50,%eax
            f->holding_flock = FALSE;
  10a7ff:	c6 46 14 00          	movb   $0x0,0x14(%esi)
            if (flock_release(&f->ip->flock) < 0) return -1;
  10a803:	50                   	push   %eax
  10a804:	e8 c7 18 00 00       	call   10c0d0 <flock_release>
  10a809:	83 c4 10             	add    $0x10,%esp
  10a80c:	85 c0                	test   %eax,%eax
  10a80e:	79 a5                	jns    10a7b5 <file_flock+0x85>
}
  10a810:	83 c4 20             	add    $0x20,%esp
    if (file_stat(f, &stat) < 0) return -1; 
  10a813:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  10a818:	5b                   	pop    %ebx
  10a819:	5e                   	pop    %esi
  10a81a:	5f                   	pop    %edi
  10a81b:	c3                   	ret
  10a81c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    } else if (operation & LOCK_UN) {
  10a820:	83 e7 04             	and    $0x4,%edi
  10a823:	74 eb                	je     10a810 <file_flock+0xe0>
        if (f->holding_flock == FALSE) return -1;
  10a825:	80 7e 14 00          	cmpb   $0x0,0x14(%esi)
  10a829:	74 e5                	je     10a810 <file_flock+0xe0>
        result = flock_release(&f->ip->flock);
  10a82b:	8b 46 0c             	mov    0xc(%esi),%eax
  10a82e:	83 ec 0c             	sub    $0xc,%esp
  10a831:	83 c0 50             	add    $0x50,%eax
  10a834:	50                   	push   %eax
  10a835:	e8 96 18 00 00       	call   10c0d0 <flock_release>
        if (result < 0) return -1;
  10a83a:	83 c4 10             	add    $0x10,%esp
  10a83d:	85 c0                	test   %eax,%eax
  10a83f:	78 cf                	js     10a810 <file_flock+0xe0>
        f->holding_flock = FALSE;
  10a841:	c6 46 14 00          	movb   $0x0,0x14(%esi)
}
  10a845:	83 c4 20             	add    $0x20,%esp
  10a848:	5b                   	pop    %ebx
  10a849:	5e                   	pop    %esi
  10a84a:	5f                   	pop    %edi
  10a84b:	c3                   	ret
  10a84c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0010a850 <file_alloc>:
{
  10a850:	57                   	push   %edi
  10a851:	56                   	push   %esi
  10a852:	53                   	push   %ebx
  10a853:	e8 4a 5b ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a858:	81 c3 9c c7 00 00    	add    $0xc79c,%ebx
    spinlock_acquire(&ftable.lock);
  10a85e:	83 ec 0c             	sub    $0xc,%esp
  10a861:	8d bb cc 25 d6 00    	lea    0xd625cc(%ebx),%edi
  10a867:	57                   	push   %edi
    for (f = ftable.file; f < ftable.file + NFILE; f++) {
  10a868:	8d 77 08             	lea    0x8(%edi),%esi
    spinlock_acquire(&ftable.lock);
  10a86b:	e8 e0 b6 ff ff       	call   105f50 <spinlock_acquire>
  10a870:	83 c4 10             	add    $0x10,%esp
    for (f = ftable.file; f < ftable.file + NFILE; f++) {
  10a873:	8d 83 34 2f d6 00    	lea    0xd62f34(%ebx),%eax
  10a879:	eb 0c                	jmp    10a887 <file_alloc+0x37>
  10a87b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a880:	83 c6 18             	add    $0x18,%esi
  10a883:	39 c6                	cmp    %eax,%esi
  10a885:	74 20                	je     10a8a7 <file_alloc+0x57>
        if (f->ref == 0) {
  10a887:	8b 56 04             	mov    0x4(%esi),%edx
  10a88a:	85 d2                	test   %edx,%edx
  10a88c:	75 f2                	jne    10a880 <file_alloc+0x30>
            spinlock_release(&ftable.lock);
  10a88e:	83 ec 0c             	sub    $0xc,%esp
            f->ref = 1;
  10a891:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
            spinlock_release(&ftable.lock);
  10a898:	57                   	push   %edi
  10a899:	e8 32 b7 ff ff       	call   105fd0 <spinlock_release>
            return f;
  10a89e:	83 c4 10             	add    $0x10,%esp
}
  10a8a1:	89 f0                	mov    %esi,%eax
  10a8a3:	5b                   	pop    %ebx
  10a8a4:	5e                   	pop    %esi
  10a8a5:	5f                   	pop    %edi
  10a8a6:	c3                   	ret
    spinlock_release(&ftable.lock);
  10a8a7:	8d 86 98 f6 ff ff    	lea    -0x968(%esi),%eax
  10a8ad:	83 ec 0c             	sub    $0xc,%esp
    return 0;
  10a8b0:	31 f6                	xor    %esi,%esi
    spinlock_release(&ftable.lock);
  10a8b2:	50                   	push   %eax
  10a8b3:	e8 18 b7 ff ff       	call   105fd0 <spinlock_release>
    return 0;
  10a8b8:	83 c4 10             	add    $0x10,%esp
}
  10a8bb:	89 f0                	mov    %esi,%eax
  10a8bd:	5b                   	pop    %ebx
  10a8be:	5e                   	pop    %esi
  10a8bf:	5f                   	pop    %edi
  10a8c0:	c3                   	ret
  10a8c1:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a8c8:	00 
  10a8c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0010a8d0 <file_dup>:
{
  10a8d0:	57                   	push   %edi
  10a8d1:	56                   	push   %esi
  10a8d2:	53                   	push   %ebx
  10a8d3:	8b 74 24 10          	mov    0x10(%esp),%esi
  10a8d7:	e8 c6 5a ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a8dc:	81 c3 18 c7 00 00    	add    $0xc718,%ebx
    spinlock_acquire(&ftable.lock);
  10a8e2:	83 ec 0c             	sub    $0xc,%esp
  10a8e5:	8d bb cc 25 d6 00    	lea    0xd625cc(%ebx),%edi
  10a8eb:	57                   	push   %edi
  10a8ec:	e8 5f b6 ff ff       	call   105f50 <spinlock_acquire>
    if (f->ref < 1)
  10a8f1:	8b 46 04             	mov    0x4(%esi),%eax
  10a8f4:	83 c4 10             	add    $0x10,%esp
  10a8f7:	85 c0                	test   %eax,%eax
  10a8f9:	7e 1d                	jle    10a918 <file_dup+0x48>
    f->ref++;
  10a8fb:	83 c0 01             	add    $0x1,%eax
    spinlock_release(&ftable.lock);
  10a8fe:	83 ec 0c             	sub    $0xc,%esp
    f->ref++;
  10a901:	89 46 04             	mov    %eax,0x4(%esi)
    spinlock_release(&ftable.lock);
  10a904:	57                   	push   %edi
  10a905:	e8 c6 b6 ff ff       	call   105fd0 <spinlock_release>
    return f;
  10a90a:	83 c4 10             	add    $0x10,%esp
}
  10a90d:	89 f0                	mov    %esi,%eax
  10a90f:	5b                   	pop    %ebx
  10a910:	5e                   	pop    %esi
  10a911:	5f                   	pop    %edi
  10a912:	c3                   	ret
  10a913:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        KERN_PANIC("file_dup");
  10a918:	83 ec 04             	sub    $0x4,%esp
  10a91b:	8d 83 51 69 ff ff    	lea    -0x96af(%ebx),%eax
  10a921:	50                   	push   %eax
  10a922:	8d 83 5a 69 ff ff    	lea    -0x96a6(%ebx),%eax
  10a928:	6a 67                	push   $0x67
  10a92a:	50                   	push   %eax
  10a92b:	e8 c0 9e ff ff       	call   1047f0 <debug_panic>
    f->ref++;
  10a930:	8b 46 04             	mov    0x4(%esi),%eax
  10a933:	83 c4 10             	add    $0x10,%esp
  10a936:	eb c3                	jmp    10a8fb <file_dup+0x2b>
  10a938:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a93f:	00 

0010a940 <file_close>:
{
  10a940:	55                   	push   %ebp
  10a941:	57                   	push   %edi
  10a942:	56                   	push   %esi
  10a943:	53                   	push   %ebx
  10a944:	e8 59 5a ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10a949:	81 c3 ab c6 00 00    	add    $0xc6ab,%ebx
  10a94f:	83 ec 28             	sub    $0x28,%esp
  10a952:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
    spinlock_acquire(&ftable.lock);
  10a956:	8d b3 cc 25 d6 00    	lea    0xd625cc(%ebx),%esi
  10a95c:	56                   	push   %esi
  10a95d:	e8 ee b5 ff ff       	call   105f50 <spinlock_acquire>
    if (f->ref < 1)
  10a962:	8b 45 04             	mov    0x4(%ebp),%eax
  10a965:	83 c4 10             	add    $0x10,%esp
  10a968:	85 c0                	test   %eax,%eax
  10a96a:	7e 74                	jle    10a9e0 <file_close+0xa0>
    if (f->holding_flock) file_flock(f, LOCK_UN);
  10a96c:	80 7d 14 00          	cmpb   $0x0,0x14(%ebp)
  10a970:	75 56                	jne    10a9c8 <file_close+0x88>
    if (--f->ref > 0) {
  10a972:	8b 45 04             	mov    0x4(%ebp),%eax
  10a975:	83 e8 01             	sub    $0x1,%eax
  10a978:	89 45 04             	mov    %eax,0x4(%ebp)
  10a97b:	85 c0                	test   %eax,%eax
  10a97d:	7f 31                	jg     10a9b0 <file_close+0x70>
    ff = *f;
  10a97f:	8b 45 0c             	mov    0xc(%ebp),%eax
    spinlock_release(&ftable.lock);
  10a982:	83 ec 0c             	sub    $0xc,%esp
    ff = *f;
  10a985:	8b 7d 00             	mov    0x0(%ebp),%edi
    f->ref = 0;
  10a988:	c7 45 04 00 00 00 00 	movl   $0x0,0x4(%ebp)
    f->type = FD_NONE;
  10a98f:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
    ff = *f;
  10a996:	89 44 24 18          	mov    %eax,0x18(%esp)
    spinlock_release(&ftable.lock);
  10a99a:	56                   	push   %esi
  10a99b:	e8 30 b6 ff ff       	call   105fd0 <spinlock_release>
    if (ff.type == FD_INODE) {
  10a9a0:	83 c4 10             	add    $0x10,%esp
  10a9a3:	83 ff 02             	cmp    $0x2,%edi
  10a9a6:	74 58                	je     10aa00 <file_close+0xc0>
}
  10a9a8:	83 c4 1c             	add    $0x1c,%esp
  10a9ab:	5b                   	pop    %ebx
  10a9ac:	5e                   	pop    %esi
  10a9ad:	5f                   	pop    %edi
  10a9ae:	5d                   	pop    %ebp
  10a9af:	c3                   	ret
        spinlock_release(&ftable.lock);
  10a9b0:	83 ec 0c             	sub    $0xc,%esp
  10a9b3:	56                   	push   %esi
  10a9b4:	e8 17 b6 ff ff       	call   105fd0 <spinlock_release>
  10a9b9:	83 c4 10             	add    $0x10,%esp
}
  10a9bc:	83 c4 1c             	add    $0x1c,%esp
  10a9bf:	5b                   	pop    %ebx
  10a9c0:	5e                   	pop    %esi
  10a9c1:	5f                   	pop    %edi
  10a9c2:	5d                   	pop    %ebp
  10a9c3:	c3                   	ret
  10a9c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (f->holding_flock) file_flock(f, LOCK_UN);
  10a9c8:	83 ec 08             	sub    $0x8,%esp
  10a9cb:	6a 04                	push   $0x4
  10a9cd:	55                   	push   %ebp
  10a9ce:	e8 5d fd ff ff       	call   10a730 <file_flock>
  10a9d3:	83 c4 10             	add    $0x10,%esp
  10a9d6:	eb 9a                	jmp    10a972 <file_close+0x32>
  10a9d8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10a9df:	00 
        KERN_PANIC("file_close");
  10a9e0:	83 ec 04             	sub    $0x4,%esp
  10a9e3:	8d 83 69 69 ff ff    	lea    -0x9697(%ebx),%eax
  10a9e9:	50                   	push   %eax
  10a9ea:	8d 83 5a 69 ff ff    	lea    -0x96a6(%ebx),%eax
  10a9f0:	6a 76                	push   $0x76
  10a9f2:	50                   	push   %eax
  10a9f3:	e8 f8 9d ff ff       	call   1047f0 <debug_panic>
  10a9f8:	83 c4 10             	add    $0x10,%esp
  10a9fb:	e9 6c ff ff ff       	jmp    10a96c <file_close+0x2c>
        begin_trans();
  10aa00:	e8 2b ea ff ff       	call   109430 <begin_trans>
        inode_put(ff.ip);
  10aa05:	83 ec 0c             	sub    $0xc,%esp
  10aa08:	ff 74 24 18          	push   0x18(%esp)
  10aa0c:	e8 8f f4 ff ff       	call   109ea0 <inode_put>
        commit_trans();
  10aa11:	e8 7a ea ff ff       	call   109490 <commit_trans>
  10aa16:	83 c4 10             	add    $0x10,%esp
}
  10aa19:	83 c4 1c             	add    $0x1c,%esp
  10aa1c:	5b                   	pop    %ebx
  10aa1d:	5e                   	pop    %esi
  10aa1e:	5f                   	pop    %edi
  10aa1f:	5d                   	pop    %ebp
  10aa20:	c3                   	ret
  10aa21:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10aa28:	00 
  10aa29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0010aa30 <file_stat>:
{
  10aa30:	56                   	push   %esi
  10aa31:	53                   	push   %ebx
  10aa32:	e8 6b 59 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10aa37:	81 c3 bd c5 00 00    	add    $0xc5bd,%ebx
  10aa3d:	83 ec 04             	sub    $0x4,%esp
  10aa40:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (f->type == FD_INODE) {
  10aa44:	83 3e 02             	cmpl   $0x2,(%esi)
  10aa47:	75 37                	jne    10aa80 <file_stat+0x50>
        inode_lock(f->ip);
  10aa49:	83 ec 0c             	sub    $0xc,%esp
  10aa4c:	ff 76 0c             	push   0xc(%esi)
  10aa4f:	e8 bc f2 ff ff       	call   109d10 <inode_lock>
        inode_stat(f->ip, st);
  10aa54:	58                   	pop    %eax
  10aa55:	5a                   	pop    %edx
  10aa56:	ff 74 24 1c          	push   0x1c(%esp)
  10aa5a:	ff 76 0c             	push   0xc(%esi)
  10aa5d:	e8 ee f5 ff ff       	call   10a050 <inode_stat>
        inode_unlock(f->ip);
  10aa62:	59                   	pop    %ecx
  10aa63:	ff 76 0c             	push   0xc(%esi)
  10aa66:	e8 b5 f3 ff ff       	call   109e20 <inode_unlock>
        return 0;
  10aa6b:	83 c4 10             	add    $0x10,%esp
  10aa6e:	31 c0                	xor    %eax,%eax
    }
    return -1;
}
  10aa70:	83 c4 04             	add    $0x4,%esp
  10aa73:	5b                   	pop    %ebx
  10aa74:	5e                   	pop    %esi
  10aa75:	c3                   	ret
  10aa76:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10aa7d:	00 
  10aa7e:	66 90                	xchg   %ax,%ax
  10aa80:	83 c4 04             	add    $0x4,%esp
    return -1;
  10aa83:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  10aa88:	5b                   	pop    %ebx
  10aa89:	5e                   	pop    %esi
  10aa8a:	c3                   	ret
  10aa8b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

0010aa90 <file_read>:

/**
 * Read from file f.
 */
int file_read(struct file *f, char *addr, int n)
{
  10aa90:	57                   	push   %edi
  10aa91:	56                   	push   %esi
  10aa92:	53                   	push   %ebx
  10aa93:	8b 74 24 10          	mov    0x10(%esp),%esi
  10aa97:	e8 06 59 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10aa9c:	81 c3 58 c5 00 00    	add    $0xc558,%ebx
    int r;

    if (f->readable == 0)
  10aaa2:	80 7e 08 00          	cmpb   $0x0,0x8(%esi)
  10aaa6:	74 66                	je     10ab0e <file_read+0x7e>
        return -1;
    if (f->type == FD_INODE) {
  10aaa8:	83 3e 02             	cmpl   $0x2,(%esi)
  10aaab:	75 43                	jne    10aaf0 <file_read+0x60>
        inode_lock(f->ip);
  10aaad:	83 ec 0c             	sub    $0xc,%esp
  10aab0:	ff 76 0c             	push   0xc(%esi)
  10aab3:	e8 58 f2 ff ff       	call   109d10 <inode_lock>
        if ((r = inode_read(f->ip, addr, f->off, n)) > 0)
  10aab8:	ff 74 24 28          	push   0x28(%esp)
  10aabc:	ff 76 10             	push   0x10(%esi)
  10aabf:	ff 74 24 2c          	push   0x2c(%esp)
  10aac3:	ff 76 0c             	push   0xc(%esi)
  10aac6:	e8 b5 f5 ff ff       	call   10a080 <inode_read>
  10aacb:	83 c4 20             	add    $0x20,%esp
  10aace:	89 c7                	mov    %eax,%edi
  10aad0:	85 c0                	test   %eax,%eax
  10aad2:	7e 03                	jle    10aad7 <file_read+0x47>
            f->off += r;
  10aad4:	01 46 10             	add    %eax,0x10(%esi)
        inode_unlock(f->ip);
  10aad7:	83 ec 0c             	sub    $0xc,%esp
  10aada:	ff 76 0c             	push   0xc(%esi)
  10aadd:	e8 3e f3 ff ff       	call   109e20 <inode_unlock>
        return r;
  10aae2:	83 c4 10             	add    $0x10,%esp
    }
    KERN_PANIC("file_read");
    return -1;
}
  10aae5:	89 f8                	mov    %edi,%eax
  10aae7:	5b                   	pop    %ebx
  10aae8:	5e                   	pop    %esi
  10aae9:	5f                   	pop    %edi
  10aaea:	c3                   	ret
  10aaeb:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    KERN_PANIC("file_read");
  10aaf0:	83 ec 04             	sub    $0x4,%esp
  10aaf3:	8d 83 74 69 ff ff    	lea    -0x968c(%ebx),%eax
  10aaf9:	50                   	push   %eax
  10aafa:	8d 83 5a 69 ff ff    	lea    -0x96a6(%ebx),%eax
  10ab00:	68 a6 00 00 00       	push   $0xa6
  10ab05:	50                   	push   %eax
  10ab06:	e8 e5 9c ff ff       	call   1047f0 <debug_panic>
    return -1;
  10ab0b:	83 c4 10             	add    $0x10,%esp
        return -1;
  10ab0e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  10ab13:	eb d0                	jmp    10aae5 <file_read+0x55>
  10ab15:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10ab1c:	00 
  10ab1d:	8d 76 00             	lea    0x0(%esi),%esi

0010ab20 <file_write>:

/**
 * Write to file f.
 */
int file_write(struct file *f, char *addr, int n)
{
  10ab20:	55                   	push   %ebp
  10ab21:	57                   	push   %edi
  10ab22:	56                   	push   %esi
  10ab23:	53                   	push   %ebx
  10ab24:	e8 79 58 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10ab29:	81 c3 cb c4 00 00    	add    $0xc4cb,%ebx
  10ab2f:	83 ec 1c             	sub    $0x1c,%esp
  10ab32:	8b 7c 24 30          	mov    0x30(%esp),%edi
    int r;

    if (f->writable == 0)
  10ab36:	80 7f 09 00          	cmpb   $0x0,0x9(%edi)
  10ab3a:	0f 84 ee 00 00 00    	je     10ac2e <file_write+0x10e>
        return -1;
    if (f->type == FD_INODE) {
  10ab40:	83 3f 02             	cmpl   $0x2,(%edi)
  10ab43:	0f 85 f4 00 00 00    	jne    10ac3d <file_write+0x11d>
        // and 2 blocks of slop for non-aligned writes.
        // this really belongs lower down, since inode_write()
        // might be writing a device like the console.
        int max = ((LOGSIZE - 1 - 1 - 2) / 2) * 512;
        int i = 0;
        while (i < n) {
  10ab49:	8b 44 24 38          	mov    0x38(%esp),%eax
        int i = 0;
  10ab4d:	31 ed                	xor    %ebp,%ebp
        while (i < n) {
  10ab4f:	85 c0                	test   %eax,%eax
  10ab51:	0f 8e d1 00 00 00    	jle    10ac28 <file_write+0x108>
            commit_trans();

            if (r < 0)
                break;
            if (r != n1)
                KERN_PANIC("short file_write");
  10ab57:	8d 83 7e 69 ff ff    	lea    -0x9682(%ebx),%eax
  10ab5d:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ab61:	8d 83 5a 69 ff ff    	lea    -0x96a6(%ebx),%eax
  10ab67:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10ab6b:	eb 31                	jmp    10ab9e <file_write+0x7e>
  10ab6d:	8d 76 00             	lea    0x0(%esi),%esi
                f->off += r;
  10ab70:	01 47 10             	add    %eax,0x10(%edi)
            inode_unlock(f->ip);
  10ab73:	83 ec 0c             	sub    $0xc,%esp
                f->off += r;
  10ab76:	89 44 24 10          	mov    %eax,0x10(%esp)
            inode_unlock(f->ip);
  10ab7a:	ff 77 0c             	push   0xc(%edi)
  10ab7d:	e8 9e f2 ff ff       	call   109e20 <inode_unlock>
            commit_trans();
  10ab82:	e8 09 e9 ff ff       	call   109490 <commit_trans>
            if (r != n1)
  10ab87:	8b 44 24 14          	mov    0x14(%esp),%eax
  10ab8b:	83 c4 10             	add    $0x10,%esp
  10ab8e:	39 c6                	cmp    %eax,%esi
  10ab90:	75 65                	jne    10abf7 <file_write+0xd7>
            i += r;
  10ab92:	01 c5                	add    %eax,%ebp
        while (i < n) {
  10ab94:	39 6c 24 38          	cmp    %ebp,0x38(%esp)
  10ab98:	0f 8e 8a 00 00 00    	jle    10ac28 <file_write+0x108>
            int n1 = n - i;
  10ab9e:	8b 74 24 38          	mov    0x38(%esp),%esi
            if (n1 > max)
  10aba2:	b8 00 06 00 00       	mov    $0x600,%eax
            int n1 = n - i;
  10aba7:	29 ee                	sub    %ebp,%esi
            if (n1 > max)
  10aba9:	39 c6                	cmp    %eax,%esi
  10abab:	0f 4f f0             	cmovg  %eax,%esi
            begin_trans();
  10abae:	e8 7d e8 ff ff       	call   109430 <begin_trans>
            inode_lock(f->ip);
  10abb3:	83 ec 0c             	sub    $0xc,%esp
  10abb6:	ff 77 0c             	push   0xc(%edi)
  10abb9:	e8 52 f1 ff ff       	call   109d10 <inode_lock>
            if ((r = inode_write(f->ip, addr + i, f->off, n1)) > 0)
  10abbe:	56                   	push   %esi
  10abbf:	ff 77 10             	push   0x10(%edi)
  10abc2:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  10abc6:	01 e8                	add    %ebp,%eax
  10abc8:	50                   	push   %eax
  10abc9:	ff 77 0c             	push   0xc(%edi)
  10abcc:	e8 df f5 ff ff       	call   10a1b0 <inode_write>
  10abd1:	83 c4 20             	add    $0x20,%esp
  10abd4:	85 c0                	test   %eax,%eax
  10abd6:	7f 98                	jg     10ab70 <file_write+0x50>
  10abd8:	89 44 24 04          	mov    %eax,0x4(%esp)
            inode_unlock(f->ip);
  10abdc:	83 ec 0c             	sub    $0xc,%esp
  10abdf:	ff 77 0c             	push   0xc(%edi)
  10abe2:	e8 39 f2 ff ff       	call   109e20 <inode_unlock>
            commit_trans();
  10abe7:	e8 a4 e8 ff ff       	call   109490 <commit_trans>
            if (r < 0)
  10abec:	8b 44 24 14          	mov    0x14(%esp),%eax
  10abf0:	83 c4 10             	add    $0x10,%esp
  10abf3:	85 c0                	test   %eax,%eax
  10abf5:	75 31                	jne    10ac28 <file_write+0x108>
  10abf7:	89 44 24 04          	mov    %eax,0x4(%esp)
                KERN_PANIC("short file_write");
  10abfb:	83 ec 04             	sub    $0x4,%esp
  10abfe:	ff 74 24 0c          	push   0xc(%esp)
  10ac02:	68 cb 00 00 00       	push   $0xcb
  10ac07:	ff 74 24 18          	push   0x18(%esp)
  10ac0b:	e8 e0 9b ff ff       	call   1047f0 <debug_panic>
  10ac10:	8b 44 24 14          	mov    0x14(%esp),%eax
  10ac14:	83 c4 10             	add    $0x10,%esp
            i += r;
  10ac17:	01 c5                	add    %eax,%ebp
        while (i < n) {
  10ac19:	39 6c 24 38          	cmp    %ebp,0x38(%esp)
  10ac1d:	0f 8f 7b ff ff ff    	jg     10ab9e <file_write+0x7e>
  10ac23:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        }
        return i == n ? n : -1;
  10ac28:	39 6c 24 38          	cmp    %ebp,0x38(%esp)
  10ac2c:	74 05                	je     10ac33 <file_write+0x113>
        return -1;
  10ac2e:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
    }
    KERN_PANIC("file_write");
    return -1;
}
  10ac33:	83 c4 1c             	add    $0x1c,%esp
  10ac36:	89 e8                	mov    %ebp,%eax
  10ac38:	5b                   	pop    %ebx
  10ac39:	5e                   	pop    %esi
  10ac3a:	5f                   	pop    %edi
  10ac3b:	5d                   	pop    %ebp
  10ac3c:	c3                   	ret
    KERN_PANIC("file_write");
  10ac3d:	83 ec 04             	sub    $0x4,%esp
  10ac40:	8d 83 84 69 ff ff    	lea    -0x967c(%ebx),%eax
  10ac46:	50                   	push   %eax
  10ac47:	8d 83 5a 69 ff ff    	lea    -0x96a6(%ebx),%eax
  10ac4d:	68 d0 00 00 00       	push   $0xd0
  10ac52:	50                   	push   %eax
  10ac53:	e8 98 9b ff ff       	call   1047f0 <debug_panic>
    return -1;
  10ac58:	83 c4 10             	add    $0x10,%esp
  10ac5b:	eb d1                	jmp    10ac2e <file_write+0x10e>
  10ac5d:	66 90                	xchg   %ax,%ax
  10ac5f:	90                   	nop

0010ac60 <create.constprop.0>:
    commit_trans();
    syscall_set_errno(tf, E_DISK_OP);
    return;
}

static struct inode *create(char *path, short type, short major, short minor)
  10ac60:	55                   	push   %ebp
  10ac61:	57                   	push   %edi
  10ac62:	56                   	push   %esi
  10ac63:	53                   	push   %ebx
  10ac64:	e8 39 57 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10ac69:	81 c3 8b c3 00 00    	add    $0xc38b,%ebx
  10ac6f:	83 ec 44             	sub    $0x44,%esp
{
    uint32_t off;
    struct inode *ip, *dp;
    char name[DIRSIZ];

    if ((dp = nameiparent(path, name)) == 0)
  10ac72:	8d 6c 24 2a          	lea    0x2a(%esp),%ebp
static struct inode *create(char *path, short type, short major, short minor)
  10ac76:	89 54 24 14          	mov    %edx,0x14(%esp)
    if ((dp = nameiparent(path, name)) == 0)
  10ac7a:	55                   	push   %ebp
  10ac7b:	50                   	push   %eax
  10ac7c:	e8 6f fa ff ff       	call   10a6f0 <nameiparent>
  10ac81:	83 c4 10             	add    $0x10,%esp
  10ac84:	85 c0                	test   %eax,%eax
  10ac86:	74 64                	je     10acec <create.constprop.0+0x8c>
        return 0;
    inode_lock(dp);
  10ac88:	83 ec 0c             	sub    $0xc,%esp
  10ac8b:	89 c6                	mov    %eax,%esi
  10ac8d:	50                   	push   %eax
  10ac8e:	e8 7d f0 ff ff       	call   109d10 <inode_lock>

    if ((ip = dir_lookup(dp, name, &off)) != 0) {
  10ac93:	83 c4 0c             	add    $0xc,%esp
  10ac96:	8d 44 24 20          	lea    0x20(%esp),%eax
  10ac9a:	50                   	push   %eax
  10ac9b:	55                   	push   %ebp
  10ac9c:	56                   	push   %esi
  10ac9d:	e8 9e f6 ff ff       	call   10a340 <dir_lookup>
  10aca2:	83 c4 10             	add    $0x10,%esp
  10aca5:	89 c7                	mov    %eax,%edi
  10aca7:	85 c0                	test   %eax,%eax
  10aca9:	74 55                	je     10ad00 <create.constprop.0+0xa0>
        inode_unlockput(dp);
  10acab:	83 ec 0c             	sub    $0xc,%esp
  10acae:	56                   	push   %esi
  10acaf:	e8 7c f3 ff ff       	call   10a030 <inode_unlockput>
        inode_lock(ip);
  10acb4:	89 3c 24             	mov    %edi,(%esp)
  10acb7:	e8 54 f0 ff ff       	call   109d10 <inode_lock>
        if (type == T_FILE && ip->type == T_FILE)
  10acbc:	83 c4 10             	add    $0x10,%esp
  10acbf:	66 83 7c 24 0c 02    	cmpw   $0x2,0xc(%esp)
  10acc5:	75 19                	jne    10ace0 <create.constprop.0+0x80>
  10acc7:	66 83 7f 10 02       	cmpw   $0x2,0x10(%edi)
  10accc:	75 12                	jne    10ace0 <create.constprop.0+0x80>
    if (dir_link(dp, name, ip->inum) < 0)
        KERN_PANIC("create: dir_link");

    inode_unlockput(dp);
    return ip;
}
  10acce:	83 c4 3c             	add    $0x3c,%esp
  10acd1:	89 f8                	mov    %edi,%eax
  10acd3:	5b                   	pop    %ebx
  10acd4:	5e                   	pop    %esi
  10acd5:	5f                   	pop    %edi
  10acd6:	5d                   	pop    %ebp
  10acd7:	c3                   	ret
  10acd8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10acdf:	00 
        inode_unlockput(ip);
  10ace0:	83 ec 0c             	sub    $0xc,%esp
  10ace3:	57                   	push   %edi
  10ace4:	e8 47 f3 ff ff       	call   10a030 <inode_unlockput>
        return 0;
  10ace9:	83 c4 10             	add    $0x10,%esp
}
  10acec:	83 c4 3c             	add    $0x3c,%esp
        return 0;
  10acef:	31 ff                	xor    %edi,%edi
}
  10acf1:	5b                   	pop    %ebx
  10acf2:	89 f8                	mov    %edi,%eax
  10acf4:	5e                   	pop    %esi
  10acf5:	5f                   	pop    %edi
  10acf6:	5d                   	pop    %ebp
  10acf7:	c3                   	ret
  10acf8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10acff:	00 
    if ((ip = inode_alloc(dp->dev, type)) == 0)
  10ad00:	83 ec 08             	sub    $0x8,%esp
  10ad03:	0f bf 44 24 14       	movswl 0x14(%esp),%eax
  10ad08:	50                   	push   %eax
  10ad09:	ff 36                	push   (%esi)
  10ad0b:	e8 d0 ee ff ff       	call   109be0 <inode_alloc>
  10ad10:	83 c4 10             	add    $0x10,%esp
  10ad13:	89 c7                	mov    %eax,%edi
  10ad15:	85 c0                	test   %eax,%eax
  10ad17:	0f 84 e3 00 00 00    	je     10ae00 <create.constprop.0+0x1a0>
    inode_lock(ip);
  10ad1d:	83 ec 0c             	sub    $0xc,%esp
  10ad20:	57                   	push   %edi
  10ad21:	e8 ea ef ff ff       	call   109d10 <inode_lock>
    ip->major = major;
  10ad26:	31 c0                	xor    %eax,%eax
    ip->minor = minor;
  10ad28:	c7 47 14 00 00 01 00 	movl   $0x10000,0x14(%edi)
    ip->major = major;
  10ad2f:	66 89 47 12          	mov    %ax,0x12(%edi)
    inode_update(ip);
  10ad33:	89 3c 24             	mov    %edi,(%esp)
  10ad36:	e8 f5 ec ff ff       	call   109a30 <inode_update>
    if (type == T_DIR) {  // Create . and .. entries.
  10ad3b:	83 c4 10             	add    $0x10,%esp
  10ad3e:	66 83 7c 24 0c 01    	cmpw   $0x1,0xc(%esp)
  10ad44:	74 4a                	je     10ad90 <create.constprop.0+0x130>
    if (dir_link(dp, name, ip->inum) < 0)
  10ad46:	83 ec 04             	sub    $0x4,%esp
  10ad49:	ff 77 04             	push   0x4(%edi)
  10ad4c:	55                   	push   %ebp
  10ad4d:	56                   	push   %esi
  10ad4e:	e8 ed f6 ff ff       	call   10a440 <dir_link>
  10ad53:	83 c4 10             	add    $0x10,%esp
  10ad56:	85 c0                	test   %eax,%eax
  10ad58:	78 16                	js     10ad70 <create.constprop.0+0x110>
    inode_unlockput(dp);
  10ad5a:	83 ec 0c             	sub    $0xc,%esp
  10ad5d:	56                   	push   %esi
  10ad5e:	e8 cd f2 ff ff       	call   10a030 <inode_unlockput>
    return ip;
  10ad63:	83 c4 10             	add    $0x10,%esp
}
  10ad66:	89 f8                	mov    %edi,%eax
  10ad68:	83 c4 3c             	add    $0x3c,%esp
  10ad6b:	5b                   	pop    %ebx
  10ad6c:	5e                   	pop    %esi
  10ad6d:	5f                   	pop    %edi
  10ad6e:	5d                   	pop    %ebp
  10ad6f:	c3                   	ret
        KERN_PANIC("create: dir_link");
  10ad70:	83 ec 04             	sub    $0x4,%esp
  10ad73:	8d 83 bf 69 ff ff    	lea    -0x9641(%ebx),%eax
  10ad79:	50                   	push   %eax
  10ad7a:	8d 83 9e 69 ff ff    	lea    -0x9662(%ebx),%eax
  10ad80:	68 a5 01 00 00       	push   $0x1a5
  10ad85:	50                   	push   %eax
  10ad86:	e8 65 9a ff ff       	call   1047f0 <debug_panic>
  10ad8b:	83 c4 10             	add    $0x10,%esp
  10ad8e:	eb ca                	jmp    10ad5a <create.constprop.0+0xfa>
        inode_update(dp);
  10ad90:	83 ec 0c             	sub    $0xc,%esp
        dp->nlink++;      // for ".."
  10ad93:	66 83 46 16 01       	addw   $0x1,0x16(%esi)
        inode_update(dp);
  10ad98:	56                   	push   %esi
  10ad99:	e8 92 ec ff ff       	call   109a30 <inode_update>
        if (dir_link(ip, ".", ip->inum) < 0
  10ad9e:	83 c4 0c             	add    $0xc,%esp
  10ada1:	8d 83 bd 69 ff ff    	lea    -0x9643(%ebx),%eax
  10ada7:	ff 77 04             	push   0x4(%edi)
  10adaa:	50                   	push   %eax
  10adab:	57                   	push   %edi
  10adac:	e8 8f f6 ff ff       	call   10a440 <dir_link>
  10adb1:	83 c4 10             	add    $0x10,%esp
  10adb4:	85 c0                	test   %eax,%eax
  10adb6:	78 1e                	js     10add6 <create.constprop.0+0x176>
            || dir_link(ip, "..", dp->inum) < 0)
  10adb8:	83 ec 04             	sub    $0x4,%esp
  10adbb:	8d 83 bc 69 ff ff    	lea    -0x9644(%ebx),%eax
  10adc1:	ff 76 04             	push   0x4(%esi)
  10adc4:	50                   	push   %eax
  10adc5:	57                   	push   %edi
  10adc6:	e8 75 f6 ff ff       	call   10a440 <dir_link>
  10adcb:	83 c4 10             	add    $0x10,%esp
  10adce:	85 c0                	test   %eax,%eax
  10add0:	0f 89 70 ff ff ff    	jns    10ad46 <create.constprop.0+0xe6>
            KERN_PANIC("create dots");
  10add6:	83 ec 04             	sub    $0x4,%esp
  10add9:	8d 83 b0 69 ff ff    	lea    -0x9650(%ebx),%eax
  10addf:	50                   	push   %eax
  10ade0:	8d 83 9e 69 ff ff    	lea    -0x9662(%ebx),%eax
  10ade6:	68 a1 01 00 00       	push   $0x1a1
  10adeb:	50                   	push   %eax
  10adec:	e8 ff 99 ff ff       	call   1047f0 <debug_panic>
  10adf1:	83 c4 10             	add    $0x10,%esp
  10adf4:	e9 4d ff ff ff       	jmp    10ad46 <create.constprop.0+0xe6>
  10adf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        KERN_PANIC("create: ialloc");
  10ae00:	83 ec 04             	sub    $0x4,%esp
  10ae03:	8d 83 8f 69 ff ff    	lea    -0x9671(%ebx),%eax
  10ae09:	50                   	push   %eax
  10ae0a:	8d 83 9e 69 ff ff    	lea    -0x9662(%ebx),%eax
  10ae10:	68 93 01 00 00       	push   $0x193
  10ae15:	50                   	push   %eax
  10ae16:	e8 d5 99 ff ff       	call   1047f0 <debug_panic>
  10ae1b:	83 c4 10             	add    $0x10,%esp
  10ae1e:	e9 fa fe ff ff       	jmp    10ad1d <create.constprop.0+0xbd>
  10ae23:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10ae2a:	00 
  10ae2b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

0010ae30 <fs_init>:
void fs_init(void) {
  10ae30:	53                   	push   %ebx
  10ae31:	e8 6c 55 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10ae36:	81 c3 be c1 00 00    	add    $0xc1be,%ebx
  10ae3c:	83 ec 14             	sub    $0x14,%esp
    spinlock_init(&fsbuf_lk);
  10ae3f:	8d 83 4c 2f d6 00    	lea    0xd62f4c(%ebx),%eax
  10ae45:	50                   	push   %eax
  10ae46:	e8 75 b0 ff ff       	call   105ec0 <spinlock_init>
}
  10ae4b:	83 c4 18             	add    $0x18,%esp
  10ae4e:	5b                   	pop    %ebx
  10ae4f:	c3                   	ret

0010ae50 <sys_read>:
{
  10ae50:	55                   	push   %ebp
  10ae51:	57                   	push   %edi
  10ae52:	56                   	push   %esi
  10ae53:	53                   	push   %ebx
  10ae54:	e8 49 55 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10ae59:	81 c3 9b c1 00 00    	add    $0xc19b,%ebx
  10ae5f:	83 ec 2c             	sub    $0x2c,%esp
  10ae62:	8b 74 24 40          	mov    0x40(%esp),%esi
    int pid = get_curid();
  10ae66:	e8 b5 cb ff ff       	call   107a20 <get_curid>
    int fd = syscall_get_arg2(tf);
  10ae6b:	83 ec 0c             	sub    $0xc,%esp
    int pid = get_curid();
  10ae6e:	89 44 24 18          	mov    %eax,0x18(%esp)
    int fd = syscall_get_arg2(tf);
  10ae72:	56                   	push   %esi
  10ae73:	e8 f8 d1 ff ff       	call   108070 <syscall_get_arg2>
    uintptr_t buf = syscall_get_arg3(tf);
  10ae78:	89 34 24             	mov    %esi,(%esp)
    int fd = syscall_get_arg2(tf);
  10ae7b:	89 c5                	mov    %eax,%ebp
    uintptr_t buf = syscall_get_arg3(tf);
  10ae7d:	e8 fe d1 ff ff       	call   108080 <syscall_get_arg3>
    size_t buflen = syscall_get_arg4(tf);
  10ae82:	89 34 24             	mov    %esi,(%esp)
    uintptr_t buf = syscall_get_arg3(tf);
  10ae85:	89 c7                	mov    %eax,%edi
    size_t buflen = syscall_get_arg4(tf);
  10ae87:	e8 04 d2 ff ff       	call   108090 <syscall_get_arg4>
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10ae8c:	83 c4 10             	add    $0x10,%esp
  10ae8f:	81 ff ff ff ff 3f    	cmp    $0x3fffffff,%edi
  10ae95:	76 49                	jbe    10aee0 <sys_read+0x90>
  10ae97:	89 c2                	mov    %eax,%edx
  10ae99:	8d 04 07             	lea    (%edi,%eax,1),%eax
        || (0 < maxlen && maxlen <= len)) {
  10ae9c:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  10aea1:	77 3d                	ja     10aee0 <sys_read+0x90>
  10aea3:	81 fa 0f 27 00 00    	cmp    $0x270f,%edx
  10aea9:	77 35                	ja     10aee0 <sys_read+0x90>
    if (!(0 <= fd && fd < NOFILE)) {
  10aeab:	83 fd 0f             	cmp    $0xf,%ebp
  10aeae:	77 1f                	ja     10aecf <sys_read+0x7f>
  10aeb0:	89 54 24 10          	mov    %edx,0x10(%esp)
    file = tcb_get_openfiles(pid)[fd];
  10aeb4:	83 ec 0c             	sub    $0xc,%esp
  10aeb7:	ff 74 24 18          	push   0x18(%esp)
  10aebb:	e8 a0 c7 ff ff       	call   107660 <tcb_get_openfiles>
    if (file == NULL || file->type != FD_INODE) {
  10aec0:	83 c4 10             	add    $0x10,%esp
    file = tcb_get_openfiles(pid)[fd];
  10aec3:	8b 04 a8             	mov    (%eax,%ebp,4),%eax
    if (file == NULL || file->type != FD_INODE) {
  10aec6:	85 c0                	test   %eax,%eax
  10aec8:	74 05                	je     10aecf <sys_read+0x7f>
  10aeca:	83 38 02             	cmpl   $0x2,(%eax)
  10aecd:	74 31                	je     10af00 <sys_read+0xb0>
        syscall_set_errno(tf, E_BADF);
  10aecf:	83 ec 08             	sub    $0x8,%esp
  10aed2:	6a 1d                	push   $0x1d
  10aed4:	eb 0f                	jmp    10aee5 <sys_read+0x95>
  10aed6:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10aedd:	00 
  10aede:	66 90                	xchg   %ax,%ax
        syscall_set_errno(tf, E_INVAL_ADDR);
  10aee0:	83 ec 08             	sub    $0x8,%esp
  10aee3:	6a 04                	push   $0x4
        syscall_set_errno(tf, E_BADF);
  10aee5:	56                   	push   %esi
  10aee6:	e8 d5 d1 ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, -1);
  10aeeb:	59                   	pop    %ecx
  10aeec:	5f                   	pop    %edi
  10aeed:	6a ff                	push   $0xffffffff
  10aeef:	56                   	push   %esi
  10aef0:	e8 db d1 ff ff       	call   1080d0 <syscall_set_retval1>
        return;
  10aef5:	83 c4 10             	add    $0x10,%esp
}
  10aef8:	83 c4 2c             	add    $0x2c,%esp
  10aefb:	5b                   	pop    %ebx
  10aefc:	5e                   	pop    %esi
  10aefd:	5f                   	pop    %edi
  10aefe:	5d                   	pop    %ebp
  10aeff:	c3                   	ret
  10af00:	89 44 24 14          	mov    %eax,0x14(%esp)
    spinlock_acquire(&fsbuf_lk);
  10af04:	8d ab 4c 2f d6 00    	lea    0xd62f4c(%ebx),%ebp
  10af0a:	83 ec 0c             	sub    $0xc,%esp
  10af0d:	55                   	push   %ebp
  10af0e:	e8 3d b0 ff ff       	call   105f50 <spinlock_acquire>
    read = file_read(file, fsbuf, buflen);
  10af13:	8b 54 24 20          	mov    0x20(%esp),%edx
  10af17:	83 c4 0c             	add    $0xc,%esp
  10af1a:	8d 8b 6c 2f d6 00    	lea    0xd62f6c(%ebx),%ecx
  10af20:	52                   	push   %edx
  10af21:	89 54 24 24          	mov    %edx,0x24(%esp)
  10af25:	51                   	push   %ecx
  10af26:	8b 44 24 20          	mov    0x20(%esp),%eax
  10af2a:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  10af2e:	50                   	push   %eax
  10af2f:	e8 5c fb ff ff       	call   10aa90 <file_read>
    syscall_set_retval1(tf, read);
  10af34:	59                   	pop    %ecx
  10af35:	5a                   	pop    %edx
  10af36:	50                   	push   %eax
  10af37:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10af3b:	56                   	push   %esi
  10af3c:	e8 8f d1 ff ff       	call   1080d0 <syscall_set_retval1>
    if (0 <= read) {
  10af41:	8b 44 24 20          	mov    0x20(%esp),%eax
  10af45:	83 c4 10             	add    $0x10,%esp
  10af48:	85 c0                	test   %eax,%eax
  10af4a:	78 3c                	js     10af88 <sys_read+0x138>
        pt_copyout(fsbuf, pid, buf, buflen);
  10af4c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  10af50:	52                   	push   %edx
  10af51:	57                   	push   %edi
  10af52:	ff 74 24 14          	push   0x14(%esp)
  10af56:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  10af5a:	51                   	push   %ecx
  10af5b:	e8 c0 aa ff ff       	call   105a20 <pt_copyout>
        syscall_set_errno(tf, E_SUCC);
  10af60:	58                   	pop    %eax
  10af61:	5a                   	pop    %edx
  10af62:	6a 00                	push   $0x0
  10af64:	56                   	push   %esi
  10af65:	e8 56 d1 ff ff       	call   1080c0 <syscall_set_errno>
  10af6a:	83 c4 10             	add    $0x10,%esp
    spinlock_release(&fsbuf_lk);
  10af6d:	83 ec 0c             	sub    $0xc,%esp
  10af70:	55                   	push   %ebp
  10af71:	e8 5a b0 ff ff       	call   105fd0 <spinlock_release>
  10af76:	83 c4 10             	add    $0x10,%esp
}
  10af79:	83 c4 2c             	add    $0x2c,%esp
  10af7c:	5b                   	pop    %ebx
  10af7d:	5e                   	pop    %esi
  10af7e:	5f                   	pop    %edi
  10af7f:	5d                   	pop    %ebp
  10af80:	c3                   	ret
  10af81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        syscall_set_errno(tf, E_BADF);
  10af88:	83 ec 08             	sub    $0x8,%esp
  10af8b:	6a 1d                	push   $0x1d
  10af8d:	56                   	push   %esi
  10af8e:	e8 2d d1 ff ff       	call   1080c0 <syscall_set_errno>
  10af93:	83 c4 10             	add    $0x10,%esp
  10af96:	eb d5                	jmp    10af6d <sys_read+0x11d>
  10af98:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10af9f:	00 

0010afa0 <sys_write>:
{
  10afa0:	55                   	push   %ebp
  10afa1:	57                   	push   %edi
  10afa2:	56                   	push   %esi
  10afa3:	53                   	push   %ebx
  10afa4:	e8 f9 53 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10afa9:	81 c3 4b c0 00 00    	add    $0xc04b,%ebx
  10afaf:	83 ec 1c             	sub    $0x1c,%esp
  10afb2:	8b 74 24 30          	mov    0x30(%esp),%esi
    int pid = get_curid();
  10afb6:	e8 65 ca ff ff       	call   107a20 <get_curid>
    int fd = syscall_get_arg2(tf);
  10afbb:	83 ec 0c             	sub    $0xc,%esp
    int pid = get_curid();
  10afbe:	89 44 24 0c          	mov    %eax,0xc(%esp)
    int fd = syscall_get_arg2(tf);
  10afc2:	56                   	push   %esi
  10afc3:	e8 a8 d0 ff ff       	call   108070 <syscall_get_arg2>
    uintptr_t buf = syscall_get_arg3(tf);
  10afc8:	89 34 24             	mov    %esi,(%esp)
    int fd = syscall_get_arg2(tf);
  10afcb:	89 c5                	mov    %eax,%ebp
    uintptr_t buf = syscall_get_arg3(tf);
  10afcd:	e8 ae d0 ff ff       	call   108080 <syscall_get_arg3>
    size_t buflen = syscall_get_arg4(tf);
  10afd2:	89 34 24             	mov    %esi,(%esp)
    uintptr_t buf = syscall_get_arg3(tf);
  10afd5:	89 c7                	mov    %eax,%edi
    size_t buflen = syscall_get_arg4(tf);
  10afd7:	e8 b4 d0 ff ff       	call   108090 <syscall_get_arg4>
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10afdc:	83 c4 10             	add    $0x10,%esp
  10afdf:	81 ff ff ff ff 3f    	cmp    $0x3fffffff,%edi
  10afe5:	76 49                	jbe    10b030 <sys_write+0x90>
  10afe7:	89 c2                	mov    %eax,%edx
  10afe9:	8d 04 07             	lea    (%edi,%eax,1),%eax
        || (0 < maxlen && maxlen <= len)) {
  10afec:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  10aff1:	77 3d                	ja     10b030 <sys_write+0x90>
  10aff3:	81 fa 0f 27 00 00    	cmp    $0x270f,%edx
  10aff9:	77 35                	ja     10b030 <sys_write+0x90>
    if (!(0 <= fd && fd < NOFILE)) {
  10affb:	83 fd 0f             	cmp    $0xf,%ebp
  10affe:	77 23                	ja     10b023 <sys_write+0x83>
  10b000:	89 54 24 04          	mov    %edx,0x4(%esp)
    file = tcb_get_openfiles(pid)[fd];
  10b004:	83 ec 0c             	sub    $0xc,%esp
  10b007:	ff 74 24 0c          	push   0xc(%esp)
  10b00b:	e8 50 c6 ff ff       	call   107660 <tcb_get_openfiles>
    if (file == NULL || file->type != FD_INODE) {
  10b010:	83 c4 10             	add    $0x10,%esp
    file = tcb_get_openfiles(pid)[fd];
  10b013:	8b 0c a8             	mov    (%eax,%ebp,4),%ecx
    if (file == NULL || file->type != FD_INODE) {
  10b016:	85 c9                	test   %ecx,%ecx
  10b018:	74 09                	je     10b023 <sys_write+0x83>
  10b01a:	83 39 02             	cmpl   $0x2,(%ecx)
  10b01d:	8b 54 24 04          	mov    0x4(%esp),%edx
  10b021:	74 2d                	je     10b050 <sys_write+0xb0>
        syscall_set_errno(tf, E_BADF);
  10b023:	83 ec 08             	sub    $0x8,%esp
  10b026:	6a 1d                	push   $0x1d
  10b028:	eb 0b                	jmp    10b035 <sys_write+0x95>
  10b02a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        syscall_set_errno(tf, E_INVAL_ADDR);
  10b030:	83 ec 08             	sub    $0x8,%esp
  10b033:	6a 04                	push   $0x4
        syscall_set_errno(tf, E_BADF);
  10b035:	56                   	push   %esi
  10b036:	e8 85 d0 ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, -1);
  10b03b:	5f                   	pop    %edi
  10b03c:	5d                   	pop    %ebp
  10b03d:	6a ff                	push   $0xffffffff
  10b03f:	56                   	push   %esi
  10b040:	e8 8b d0 ff ff       	call   1080d0 <syscall_set_retval1>
        return;
  10b045:	83 c4 10             	add    $0x10,%esp
}
  10b048:	83 c4 1c             	add    $0x1c,%esp
  10b04b:	5b                   	pop    %ebx
  10b04c:	5e                   	pop    %esi
  10b04d:	5f                   	pop    %edi
  10b04e:	5d                   	pop    %ebp
  10b04f:	c3                   	ret
  10b050:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    spinlock_acquire(&fsbuf_lk);
  10b054:	8d 83 4c 2f d6 00    	lea    0xd62f4c(%ebx),%eax
  10b05a:	83 ec 0c             	sub    $0xc,%esp
    pt_copyin(pid, buf, fsbuf, buflen);
  10b05d:	8d ab 6c 2f d6 00    	lea    0xd62f6c(%ebx),%ebp
  10b063:	89 54 24 14          	mov    %edx,0x14(%esp)
    spinlock_acquire(&fsbuf_lk);
  10b067:	89 44 24 10          	mov    %eax,0x10(%esp)
  10b06b:	50                   	push   %eax
  10b06c:	e8 df ae ff ff       	call   105f50 <spinlock_acquire>
    pt_copyin(pid, buf, fsbuf, buflen);
  10b071:	8b 54 24 18          	mov    0x18(%esp),%edx
  10b075:	52                   	push   %edx
  10b076:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  10b07a:	55                   	push   %ebp
  10b07b:	57                   	push   %edi
  10b07c:	ff 74 24 1c          	push   0x1c(%esp)
  10b080:	e8 ab a8 ff ff       	call   105930 <pt_copyin>
    written = file_write(file, fsbuf, buflen);
  10b085:	8b 54 24 28          	mov    0x28(%esp),%edx
  10b089:	83 c4 1c             	add    $0x1c,%esp
  10b08c:	52                   	push   %edx
  10b08d:	55                   	push   %ebp
  10b08e:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  10b092:	51                   	push   %ecx
  10b093:	e8 88 fa ff ff       	call   10ab20 <file_write>
  10b098:	89 c7                	mov    %eax,%edi
    spinlock_release(&fsbuf_lk);
  10b09a:	58                   	pop    %eax
  10b09b:	ff 74 24 10          	push   0x10(%esp)
  10b09f:	e8 2c af ff ff       	call   105fd0 <spinlock_release>
    syscall_set_retval1(tf, written);
  10b0a4:	5a                   	pop    %edx
  10b0a5:	59                   	pop    %ecx
  10b0a6:	57                   	push   %edi
  10b0a7:	56                   	push   %esi
  10b0a8:	e8 23 d0 ff ff       	call   1080d0 <syscall_set_retval1>
    if (0 <= written) {
  10b0ad:	83 c4 10             	add    $0x10,%esp
  10b0b0:	85 ff                	test   %edi,%edi
  10b0b2:	78 14                	js     10b0c8 <sys_write+0x128>
        syscall_set_errno(tf, E_SUCC);
  10b0b4:	83 ec 08             	sub    $0x8,%esp
  10b0b7:	6a 00                	push   $0x0
  10b0b9:	56                   	push   %esi
  10b0ba:	e8 01 d0 ff ff       	call   1080c0 <syscall_set_errno>
  10b0bf:	83 c4 10             	add    $0x10,%esp
  10b0c2:	eb 84                	jmp    10b048 <sys_write+0xa8>
  10b0c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        syscall_set_errno(tf, E_BADF);
  10b0c8:	83 ec 08             	sub    $0x8,%esp
  10b0cb:	6a 1d                	push   $0x1d
  10b0cd:	56                   	push   %esi
  10b0ce:	e8 ed cf ff ff       	call   1080c0 <syscall_set_errno>
  10b0d3:	83 c4 10             	add    $0x10,%esp
  10b0d6:	e9 6d ff ff ff       	jmp    10b048 <sys_write+0xa8>
  10b0db:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi

0010b0e0 <sys_close>:
{
  10b0e0:	55                   	push   %ebp
  10b0e1:	57                   	push   %edi
  10b0e2:	56                   	push   %esi
  10b0e3:	53                   	push   %ebx
  10b0e4:	e8 b9 52 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10b0e9:	81 c3 0b bf 00 00    	add    $0xbf0b,%ebx
  10b0ef:	83 ec 0c             	sub    $0xc,%esp
  10b0f2:	8b 7c 24 20          	mov    0x20(%esp),%edi
    int pid = get_curid();
  10b0f6:	e8 25 c9 ff ff       	call   107a20 <get_curid>
    int fd = syscall_get_arg2(tf);
  10b0fb:	83 ec 0c             	sub    $0xc,%esp
  10b0fe:	57                   	push   %edi
    int pid = get_curid();
  10b0ff:	89 c6                	mov    %eax,%esi
    int fd = syscall_get_arg2(tf);
  10b101:	e8 6a cf ff ff       	call   108070 <syscall_get_arg2>
    if (!(0 <= fd && fd < NOFILE)) {
  10b106:	83 c4 10             	add    $0x10,%esp
  10b109:	83 f8 0f             	cmp    $0xf,%eax
  10b10c:	77 52                	ja     10b160 <sys_close+0x80>
    file = tcb_get_openfiles(pid)[fd];
  10b10e:	83 ec 0c             	sub    $0xc,%esp
  10b111:	89 c5                	mov    %eax,%ebp
  10b113:	56                   	push   %esi
  10b114:	e8 47 c5 ff ff       	call   107660 <tcb_get_openfiles>
    if (file == NULL || file->ref < 1) {
  10b119:	83 c4 10             	add    $0x10,%esp
    file = tcb_get_openfiles(pid)[fd];
  10b11c:	8b 04 a8             	mov    (%eax,%ebp,4),%eax
    if (file == NULL || file->ref < 1) {
  10b11f:	85 c0                	test   %eax,%eax
  10b121:	74 3d                	je     10b160 <sys_close+0x80>
  10b123:	8b 50 04             	mov    0x4(%eax),%edx
  10b126:	85 d2                	test   %edx,%edx
  10b128:	7e 36                	jle    10b160 <sys_close+0x80>
    file_close(file);
  10b12a:	83 ec 0c             	sub    $0xc,%esp
  10b12d:	50                   	push   %eax
  10b12e:	e8 0d f8 ff ff       	call   10a940 <file_close>
    tcb_set_openfiles(pid, fd, NULL);
  10b133:	83 c4 0c             	add    $0xc,%esp
  10b136:	6a 00                	push   $0x0
  10b138:	55                   	push   %ebp
  10b139:	56                   	push   %esi
  10b13a:	e8 41 c5 ff ff       	call   107680 <tcb_set_openfiles>
    syscall_set_errno(tf, E_SUCC);
  10b13f:	58                   	pop    %eax
  10b140:	5a                   	pop    %edx
  10b141:	6a 00                	push   $0x0
  10b143:	57                   	push   %edi
  10b144:	e8 77 cf ff ff       	call   1080c0 <syscall_set_errno>
    syscall_set_retval1(tf, 0);
  10b149:	59                   	pop    %ecx
  10b14a:	5e                   	pop    %esi
  10b14b:	6a 00                	push   $0x0
  10b14d:	57                   	push   %edi
  10b14e:	e8 7d cf ff ff       	call   1080d0 <syscall_set_retval1>
  10b153:	83 c4 10             	add    $0x10,%esp
}
  10b156:	83 c4 0c             	add    $0xc,%esp
  10b159:	5b                   	pop    %ebx
  10b15a:	5e                   	pop    %esi
  10b15b:	5f                   	pop    %edi
  10b15c:	5d                   	pop    %ebp
  10b15d:	c3                   	ret
  10b15e:	66 90                	xchg   %ax,%ax
        syscall_set_errno(tf, E_BADF);
  10b160:	83 ec 08             	sub    $0x8,%esp
  10b163:	6a 1d                	push   $0x1d
  10b165:	57                   	push   %edi
  10b166:	e8 55 cf ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, -1);
  10b16b:	59                   	pop    %ecx
  10b16c:	5e                   	pop    %esi
  10b16d:	6a ff                	push   $0xffffffff
  10b16f:	57                   	push   %edi
  10b170:	e8 5b cf ff ff       	call   1080d0 <syscall_set_retval1>
        return;
  10b175:	83 c4 10             	add    $0x10,%esp
}
  10b178:	83 c4 0c             	add    $0xc,%esp
  10b17b:	5b                   	pop    %ebx
  10b17c:	5e                   	pop    %esi
  10b17d:	5f                   	pop    %edi
  10b17e:	5d                   	pop    %ebp
  10b17f:	c3                   	ret

0010b180 <sys_fstat>:
{
  10b180:	55                   	push   %ebp
  10b181:	57                   	push   %edi
  10b182:	56                   	push   %esi
  10b183:	53                   	push   %ebx
  10b184:	e8 19 52 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10b189:	81 c3 6b be 00 00    	add    $0xbe6b,%ebx
  10b18f:	83 ec 3c             	sub    $0x3c,%esp
  10b192:	8b 74 24 50          	mov    0x50(%esp),%esi
    int pid = get_curid();
  10b196:	e8 85 c8 ff ff       	call   107a20 <get_curid>
    int fd = syscall_get_arg2(tf);
  10b19b:	83 ec 0c             	sub    $0xc,%esp
  10b19e:	56                   	push   %esi
    int pid = get_curid();
  10b19f:	89 c5                	mov    %eax,%ebp
    int fd = syscall_get_arg2(tf);
  10b1a1:	e8 ca ce ff ff       	call   108070 <syscall_get_arg2>
    uintptr_t stat = syscall_get_arg3(tf);
  10b1a6:	89 34 24             	mov    %esi,(%esp)
    int fd = syscall_get_arg2(tf);
  10b1a9:	89 c7                	mov    %eax,%edi
    uintptr_t stat = syscall_get_arg3(tf);
  10b1ab:	e8 d0 ce ff ff       	call   108080 <syscall_get_arg3>
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10b1b0:	83 c4 10             	add    $0x10,%esp
  10b1b3:	3d ff ff ff 3f       	cmp    $0x3fffffff,%eax
  10b1b8:	76 56                	jbe    10b210 <sys_fstat+0x90>
  10b1ba:	89 c2                	mov    %eax,%edx
  10b1bc:	8d 40 14             	lea    0x14(%eax),%eax
  10b1bf:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  10b1c4:	77 4a                	ja     10b210 <sys_fstat+0x90>
    if (!(0 <= fd && fd < NOFILE)) {
  10b1c6:	83 ff 0f             	cmp    $0xf,%edi
  10b1c9:	77 1c                	ja     10b1e7 <sys_fstat+0x67>
  10b1cb:	89 54 24 0c          	mov    %edx,0xc(%esp)
    file = tcb_get_openfiles(pid)[fd];
  10b1cf:	83 ec 0c             	sub    $0xc,%esp
  10b1d2:	55                   	push   %ebp
  10b1d3:	e8 88 c4 ff ff       	call   107660 <tcb_get_openfiles>
    if (file == NULL || file->type != FD_INODE) {
  10b1d8:	83 c4 10             	add    $0x10,%esp
    file = tcb_get_openfiles(pid)[fd];
  10b1db:	8b 04 b8             	mov    (%eax,%edi,4),%eax
    if (file == NULL || file->type != FD_INODE) {
  10b1de:	85 c0                	test   %eax,%eax
  10b1e0:	74 05                	je     10b1e7 <sys_fstat+0x67>
  10b1e2:	83 38 02             	cmpl   $0x2,(%eax)
  10b1e5:	74 39                	je     10b220 <sys_fstat+0xa0>
        syscall_set_errno(tf, E_BADF);
  10b1e7:	83 ec 08             	sub    $0x8,%esp
  10b1ea:	6a 1d                	push   $0x1d
  10b1ec:	56                   	push   %esi
  10b1ed:	e8 ce ce ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, -1);
  10b1f2:	5d                   	pop    %ebp
  10b1f3:	58                   	pop    %eax
  10b1f4:	6a ff                	push   $0xffffffff
  10b1f6:	56                   	push   %esi
  10b1f7:	e8 d4 ce ff ff       	call   1080d0 <syscall_set_retval1>
        return;
  10b1fc:	83 c4 10             	add    $0x10,%esp
}
  10b1ff:	83 c4 3c             	add    $0x3c,%esp
  10b202:	5b                   	pop    %ebx
  10b203:	5e                   	pop    %esi
  10b204:	5f                   	pop    %edi
  10b205:	5d                   	pop    %ebp
  10b206:	c3                   	ret
  10b207:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10b20e:	00 
  10b20f:	90                   	nop
        syscall_set_errno(tf, E_INVAL_ADDR);
  10b210:	83 ec 08             	sub    $0x8,%esp
  10b213:	6a 04                	push   $0x4
  10b215:	eb d5                	jmp    10b1ec <sys_fstat+0x6c>
  10b217:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10b21e:	00 
  10b21f:	90                   	nop
    if (file_stat(file, &fs_stat) == 0) {
  10b220:	83 ec 08             	sub    $0x8,%esp
  10b223:	8d 7c 24 24          	lea    0x24(%esp),%edi
  10b227:	57                   	push   %edi
  10b228:	50                   	push   %eax
  10b229:	e8 02 f8 ff ff       	call   10aa30 <file_stat>
  10b22e:	83 c4 10             	add    $0x10,%esp
  10b231:	85 c0                	test   %eax,%eax
  10b233:	75 b2                	jne    10b1e7 <sys_fstat+0x67>
        pt_copyout(&fs_stat, pid, stat, sizeof(struct file_stat));
  10b235:	6a 14                	push   $0x14
  10b237:	8b 54 24 10          	mov    0x10(%esp),%edx
  10b23b:	52                   	push   %edx
  10b23c:	55                   	push   %ebp
  10b23d:	57                   	push   %edi
  10b23e:	e8 dd a7 ff ff       	call   105a20 <pt_copyout>
        syscall_set_errno(tf, E_SUCC);
  10b243:	58                   	pop    %eax
  10b244:	5a                   	pop    %edx
  10b245:	6a 00                	push   $0x0
  10b247:	56                   	push   %esi
  10b248:	e8 73 ce ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, 0);
  10b24d:	59                   	pop    %ecx
  10b24e:	5f                   	pop    %edi
  10b24f:	6a 00                	push   $0x0
  10b251:	56                   	push   %esi
  10b252:	e8 79 ce ff ff       	call   1080d0 <syscall_set_retval1>
  10b257:	83 c4 10             	add    $0x10,%esp
  10b25a:	eb a3                	jmp    10b1ff <sys_fstat+0x7f>
  10b25c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0010b260 <sys_link>:
{
  10b260:	55                   	push   %ebp
  10b261:	57                   	push   %edi
  10b262:	56                   	push   %esi
  10b263:	53                   	push   %ebx
  10b264:	e8 39 51 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10b269:	81 c3 8b bd 00 00    	add    $0xbd8b,%ebx
  10b26f:	81 ec 38 01 00 00    	sub    $0x138,%esp
  10b275:	8b b4 24 4c 01 00 00 	mov    0x14c(%esp),%esi
    uintptr_t uold = syscall_get_arg2(tf);
  10b27c:	56                   	push   %esi
  10b27d:	e8 ee cd ff ff       	call   108070 <syscall_get_arg2>
    uintptr_t unew = syscall_get_arg3(tf);
  10b282:	89 34 24             	mov    %esi,(%esp)
    uintptr_t uold = syscall_get_arg2(tf);
  10b285:	89 c5                	mov    %eax,%ebp
    uintptr_t unew = syscall_get_arg3(tf);
  10b287:	e8 f4 cd ff ff       	call   108080 <syscall_get_arg3>
    uintptr_t oldlen = syscall_get_arg4(tf);
  10b28c:	89 34 24             	mov    %esi,(%esp)
    uintptr_t unew = syscall_get_arg3(tf);
  10b28f:	89 44 24 18          	mov    %eax,0x18(%esp)
    uintptr_t oldlen = syscall_get_arg4(tf);
  10b293:	e8 f8 cd ff ff       	call   108090 <syscall_get_arg4>
    uintptr_t newlen = syscall_get_arg5(tf);
  10b298:	89 34 24             	mov    %esi,(%esp)
    uintptr_t oldlen = syscall_get_arg4(tf);
  10b29b:	89 c7                	mov    %eax,%edi
    uintptr_t newlen = syscall_get_arg5(tf);
  10b29d:	e8 fe cd ff ff       	call   1080a0 <syscall_get_arg5>
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10b2a2:	83 c4 10             	add    $0x10,%esp
  10b2a5:	81 fd ff ff ff 3f    	cmp    $0x3fffffff,%ebp
  10b2ab:	76 0d                	jbe    10b2ba <sys_link+0x5a>
  10b2ad:	89 c1                	mov    %eax,%ecx
  10b2af:	8d 44 3d 00          	lea    0x0(%ebp,%edi,1),%eax
        || (0 < maxlen && maxlen <= len)) {
  10b2b3:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  10b2b8:	76 26                	jbe    10b2e0 <sys_link+0x80>
        syscall_set_errno(tf, E_INVAL_ADDR);
  10b2ba:	83 ec 08             	sub    $0x8,%esp
  10b2bd:	6a 04                	push   $0x4
  10b2bf:	56                   	push   %esi
  10b2c0:	e8 fb cd ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, -1);
  10b2c5:	58                   	pop    %eax
  10b2c6:	5a                   	pop    %edx
  10b2c7:	6a ff                	push   $0xffffffff
  10b2c9:	56                   	push   %esi
  10b2ca:	e8 01 ce ff ff       	call   1080d0 <syscall_set_retval1>
  10b2cf:	83 c4 10             	add    $0x10,%esp
}
  10b2d2:	81 c4 2c 01 00 00    	add    $0x12c,%esp
  10b2d8:	5b                   	pop    %ebx
  10b2d9:	5e                   	pop    %esi
  10b2da:	5f                   	pop    %edi
  10b2db:	5d                   	pop    %ebp
  10b2dc:	c3                   	ret
  10b2dd:	8d 76 00             	lea    0x0(%esi),%esi
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10b2e0:	81 7c 24 08 ff ff ff 	cmpl   $0x3fffffff,0x8(%esp)
  10b2e7:	3f 
  10b2e8:	76 d0                	jbe    10b2ba <sys_link+0x5a>
        || (0 < maxlen && maxlen <= len)) {
  10b2ea:	89 f8                	mov    %edi,%eax
  10b2ec:	09 c8                	or     %ecx,%eax
  10b2ee:	83 f8 7f             	cmp    $0x7f,%eax
  10b2f1:	77 c7                	ja     10b2ba <sys_link+0x5a>
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10b2f3:	8b 44 24 08          	mov    0x8(%esp),%eax
  10b2f7:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  10b2fb:	01 c8                	add    %ecx,%eax
        || (0 < maxlen && maxlen <= len)) {
  10b2fd:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  10b302:	77 b6                	ja     10b2ba <sys_link+0x5a>
    pt_copyin(get_curid(), uold, old, oldlen);
  10b304:	e8 17 c7 ff ff       	call   107a20 <get_curid>
  10b309:	57                   	push   %edi
  10b30a:	8d bc 24 a4 00 00 00 	lea    0xa4(%esp),%edi
  10b311:	57                   	push   %edi
  10b312:	55                   	push   %ebp
  10b313:	50                   	push   %eax
  10b314:	e8 17 a6 ff ff       	call   105930 <pt_copyin>
    pt_copyin(get_curid(), unew, new, newlen);
  10b319:	e8 02 c7 ff ff       	call   107a20 <get_curid>
  10b31e:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  10b322:	51                   	push   %ecx
  10b323:	8d 54 24 34          	lea    0x34(%esp),%edx
  10b327:	89 54 24 20          	mov    %edx,0x20(%esp)
  10b32b:	52                   	push   %edx
  10b32c:	ff 74 24 20          	push   0x20(%esp)
  10b330:	50                   	push   %eax
  10b331:	e8 fa a5 ff ff       	call   105930 <pt_copyin>
    if ((ip = namei(old)) == 0) {
  10b336:	83 c4 14             	add    $0x14,%esp
  10b339:	57                   	push   %edi
  10b33a:	e8 91 f3 ff ff       	call   10a6d0 <namei>
  10b33f:	83 c4 10             	add    $0x10,%esp
  10b342:	89 c7                	mov    %eax,%edi
  10b344:	85 c0                	test   %eax,%eax
  10b346:	0f 84 f4 00 00 00    	je     10b440 <sys_link+0x1e0>
    begin_trans();
  10b34c:	e8 df e0 ff ff       	call   109430 <begin_trans>
    inode_lock(ip);
  10b351:	83 ec 0c             	sub    $0xc,%esp
  10b354:	57                   	push   %edi
  10b355:	e8 b6 e9 ff ff       	call   109d10 <inode_lock>
    if (ip->type == T_DIR) {
  10b35a:	83 c4 10             	add    $0x10,%esp
  10b35d:	66 83 7f 10 01       	cmpw   $0x1,0x10(%edi)
  10b362:	0f 84 f0 00 00 00    	je     10b458 <sys_link+0x1f8>
    inode_update(ip);
  10b368:	83 ec 0c             	sub    $0xc,%esp
    ip->nlink++;
  10b36b:	66 83 47 16 01       	addw   $0x1,0x16(%edi)
    inode_update(ip);
  10b370:	57                   	push   %edi
  10b371:	e8 ba e6 ff ff       	call   109a30 <inode_update>
    inode_unlock(ip);
  10b376:	89 3c 24             	mov    %edi,(%esp)
  10b379:	e8 a2 ea ff ff       	call   109e20 <inode_unlock>
    if ((dp = nameiparent(new, name)) == 0)
  10b37e:	5d                   	pop    %ebp
  10b37f:	58                   	pop    %eax
  10b380:	8d 6c 24 1a          	lea    0x1a(%esp),%ebp
  10b384:	55                   	push   %ebp
  10b385:	ff 74 24 18          	push   0x18(%esp)
  10b389:	e8 62 f3 ff ff       	call   10a6f0 <nameiparent>
  10b38e:	83 c4 10             	add    $0x10,%esp
  10b391:	85 c0                	test   %eax,%eax
  10b393:	74 6f                	je     10b404 <sys_link+0x1a4>
    inode_lock(dp);
  10b395:	83 ec 0c             	sub    $0xc,%esp
  10b398:	50                   	push   %eax
  10b399:	89 44 24 18          	mov    %eax,0x18(%esp)
  10b39d:	e8 6e e9 ff ff       	call   109d10 <inode_lock>
    if (dp->dev != ip->dev || dir_link(dp, name, ip->inum) < 0) {
  10b3a2:	8b 54 24 18          	mov    0x18(%esp),%edx
  10b3a6:	83 c4 10             	add    $0x10,%esp
  10b3a9:	8b 07                	mov    (%edi),%eax
  10b3ab:	39 02                	cmp    %eax,(%edx)
  10b3ad:	75 49                	jne    10b3f8 <sys_link+0x198>
  10b3af:	83 ec 04             	sub    $0x4,%esp
  10b3b2:	ff 77 04             	push   0x4(%edi)
  10b3b5:	55                   	push   %ebp
  10b3b6:	52                   	push   %edx
  10b3b7:	89 54 24 18          	mov    %edx,0x18(%esp)
  10b3bb:	e8 80 f0 ff ff       	call   10a440 <dir_link>
  10b3c0:	83 c4 10             	add    $0x10,%esp
  10b3c3:	8b 54 24 08          	mov    0x8(%esp),%edx
  10b3c7:	85 c0                	test   %eax,%eax
  10b3c9:	78 2d                	js     10b3f8 <sys_link+0x198>
    inode_unlockput(dp);
  10b3cb:	83 ec 0c             	sub    $0xc,%esp
  10b3ce:	52                   	push   %edx
  10b3cf:	e8 5c ec ff ff       	call   10a030 <inode_unlockput>
    inode_put(ip);
  10b3d4:	89 3c 24             	mov    %edi,(%esp)
  10b3d7:	e8 c4 ea ff ff       	call   109ea0 <inode_put>
    commit_trans();
  10b3dc:	e8 af e0 ff ff       	call   109490 <commit_trans>
    syscall_set_errno(tf, E_SUCC);
  10b3e1:	59                   	pop    %ecx
  10b3e2:	5f                   	pop    %edi
  10b3e3:	6a 00                	push   $0x0
  10b3e5:	56                   	push   %esi
  10b3e6:	e8 d5 cc ff ff       	call   1080c0 <syscall_set_errno>
    return;
  10b3eb:	83 c4 10             	add    $0x10,%esp
  10b3ee:	e9 df fe ff ff       	jmp    10b2d2 <sys_link+0x72>
  10b3f3:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        inode_unlockput(dp);
  10b3f8:	83 ec 0c             	sub    $0xc,%esp
  10b3fb:	52                   	push   %edx
  10b3fc:	e8 2f ec ff ff       	call   10a030 <inode_unlockput>
        goto bad;
  10b401:	83 c4 10             	add    $0x10,%esp
    inode_lock(ip);
  10b404:	83 ec 0c             	sub    $0xc,%esp
  10b407:	57                   	push   %edi
  10b408:	e8 03 e9 ff ff       	call   109d10 <inode_lock>
    ip->nlink--;
  10b40d:	66 83 6f 16 01       	subw   $0x1,0x16(%edi)
    inode_update(ip);
  10b412:	89 3c 24             	mov    %edi,(%esp)
  10b415:	e8 16 e6 ff ff       	call   109a30 <inode_update>
    inode_unlockput(ip);
  10b41a:	89 3c 24             	mov    %edi,(%esp)
  10b41d:	e8 0e ec ff ff       	call   10a030 <inode_unlockput>
    commit_trans();
  10b422:	e8 69 e0 ff ff       	call   109490 <commit_trans>
    syscall_set_errno(tf, E_DISK_OP);
  10b427:	58                   	pop    %eax
  10b428:	5a                   	pop    %edx
  10b429:	6a 0d                	push   $0xd
  10b42b:	56                   	push   %esi
  10b42c:	e8 8f cc ff ff       	call   1080c0 <syscall_set_errno>
    return;
  10b431:	83 c4 10             	add    $0x10,%esp
}
  10b434:	81 c4 2c 01 00 00    	add    $0x12c,%esp
  10b43a:	5b                   	pop    %ebx
  10b43b:	5e                   	pop    %esi
  10b43c:	5f                   	pop    %edi
  10b43d:	5d                   	pop    %ebp
  10b43e:	c3                   	ret
  10b43f:	90                   	nop
        syscall_set_errno(tf, E_NEXIST);
  10b440:	83 ec 08             	sub    $0x8,%esp
  10b443:	6a 1a                	push   $0x1a
  10b445:	56                   	push   %esi
  10b446:	e8 75 cc ff ff       	call   1080c0 <syscall_set_errno>
        return;
  10b44b:	83 c4 10             	add    $0x10,%esp
  10b44e:	e9 7f fe ff ff       	jmp    10b2d2 <sys_link+0x72>
  10b453:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        inode_unlockput(ip);
  10b458:	83 ec 0c             	sub    $0xc,%esp
  10b45b:	57                   	push   %edi
  10b45c:	eb bf                	jmp    10b41d <sys_link+0x1bd>
  10b45e:	66 90                	xchg   %ax,%ax

0010b460 <sys_unlink>:
{
  10b460:	55                   	push   %ebp
  10b461:	57                   	push   %edi
  10b462:	56                   	push   %esi
  10b463:	53                   	push   %ebx
  10b464:	e8 39 4f ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10b469:	81 c3 8b bb 00 00    	add    $0xbb8b,%ebx
  10b46f:	81 ec d8 00 00 00    	sub    $0xd8,%esp
  10b475:	8b b4 24 ec 00 00 00 	mov    0xec(%esp),%esi
    uintptr_t buf = syscall_get_arg2(tf);
  10b47c:	56                   	push   %esi
  10b47d:	e8 ee cb ff ff       	call   108070 <syscall_get_arg2>
    size_t buflen = syscall_get_arg3(tf);
  10b482:	89 34 24             	mov    %esi,(%esp)
    uintptr_t buf = syscall_get_arg2(tf);
  10b485:	89 c7                	mov    %eax,%edi
    size_t buflen = syscall_get_arg3(tf);
  10b487:	e8 f4 cb ff ff       	call   108080 <syscall_get_arg3>
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10b48c:	83 c4 10             	add    $0x10,%esp
  10b48f:	81 ff ff ff ff 3f    	cmp    $0x3fffffff,%edi
  10b495:	0f 86 95 00 00 00    	jbe    10b530 <sys_unlink+0xd0>
  10b49b:	89 c5                	mov    %eax,%ebp
  10b49d:	8d 04 07             	lea    (%edi,%eax,1),%eax
        || (0 < maxlen && maxlen <= len)) {
  10b4a0:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  10b4a5:	0f 87 85 00 00 00    	ja     10b530 <sys_unlink+0xd0>
  10b4ab:	83 fd 7f             	cmp    $0x7f,%ebp
  10b4ae:	0f 87 7c 00 00 00    	ja     10b530 <sys_unlink+0xd0>
    pt_copyin(get_curid(), buf, path, buflen);
  10b4b4:	e8 67 c5 ff ff       	call   107a20 <get_curid>
  10b4b9:	55                   	push   %ebp
  10b4ba:	8d 6c 24 44          	lea    0x44(%esp),%ebp
  10b4be:	55                   	push   %ebp
  10b4bf:	57                   	push   %edi
  10b4c0:	50                   	push   %eax
  10b4c1:	e8 6a a4 ff ff       	call   105930 <pt_copyin>
    if ((dp = nameiparent(path, name)) == 0) {
  10b4c6:	58                   	pop    %eax
  10b4c7:	5a                   	pop    %edx
  10b4c8:	8d 7c 24 2a          	lea    0x2a(%esp),%edi
  10b4cc:	57                   	push   %edi
  10b4cd:	55                   	push   %ebp
  10b4ce:	e8 1d f2 ff ff       	call   10a6f0 <nameiparent>
  10b4d3:	83 c4 10             	add    $0x10,%esp
  10b4d6:	89 c5                	mov    %eax,%ebp
  10b4d8:	85 c0                	test   %eax,%eax
  10b4da:	0f 84 40 01 00 00    	je     10b620 <sys_unlink+0x1c0>
    begin_trans();
  10b4e0:	e8 4b df ff ff       	call   109430 <begin_trans>
    inode_lock(dp);
  10b4e5:	83 ec 0c             	sub    $0xc,%esp
  10b4e8:	55                   	push   %ebp
  10b4e9:	e8 22 e8 ff ff       	call   109d10 <inode_lock>
    if (dir_namecmp(name, ".") == 0 || dir_namecmp(name, "..") == 0)
  10b4ee:	58                   	pop    %eax
  10b4ef:	8d 83 bd 69 ff ff    	lea    -0x9643(%ebx),%eax
  10b4f5:	5a                   	pop    %edx
  10b4f6:	50                   	push   %eax
  10b4f7:	57                   	push   %edi
  10b4f8:	e8 13 ee ff ff       	call   10a310 <dir_namecmp>
  10b4fd:	83 c4 10             	add    $0x10,%esp
  10b500:	85 c0                	test   %eax,%eax
  10b502:	75 54                	jne    10b558 <sys_unlink+0xf8>
    inode_unlockput(dp);
  10b504:	83 ec 0c             	sub    $0xc,%esp
  10b507:	55                   	push   %ebp
  10b508:	e8 23 eb ff ff       	call   10a030 <inode_unlockput>
    commit_trans();
  10b50d:	e8 7e df ff ff       	call   109490 <commit_trans>
    syscall_set_errno(tf, E_DISK_OP);
  10b512:	58                   	pop    %eax
  10b513:	5a                   	pop    %edx
  10b514:	6a 0d                	push   $0xd
  10b516:	56                   	push   %esi
  10b517:	e8 a4 cb ff ff       	call   1080c0 <syscall_set_errno>
    return;
  10b51c:	83 c4 10             	add    $0x10,%esp
}
  10b51f:	81 c4 cc 00 00 00    	add    $0xcc,%esp
  10b525:	5b                   	pop    %ebx
  10b526:	5e                   	pop    %esi
  10b527:	5f                   	pop    %edi
  10b528:	5d                   	pop    %ebp
  10b529:	c3                   	ret
  10b52a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        syscall_set_errno(tf, E_INVAL_ADDR);
  10b530:	83 ec 08             	sub    $0x8,%esp
  10b533:	6a 04                	push   $0x4
  10b535:	56                   	push   %esi
  10b536:	e8 85 cb ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, -1);
  10b53b:	59                   	pop    %ecx
  10b53c:	5f                   	pop    %edi
  10b53d:	6a ff                	push   $0xffffffff
  10b53f:	56                   	push   %esi
  10b540:	e8 8b cb ff ff       	call   1080d0 <syscall_set_retval1>
  10b545:	83 c4 10             	add    $0x10,%esp
}
  10b548:	81 c4 cc 00 00 00    	add    $0xcc,%esp
  10b54e:	5b                   	pop    %ebx
  10b54f:	5e                   	pop    %esi
  10b550:	5f                   	pop    %edi
  10b551:	5d                   	pop    %ebp
  10b552:	c3                   	ret
  10b553:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    if (dir_namecmp(name, ".") == 0 || dir_namecmp(name, "..") == 0)
  10b558:	83 ec 08             	sub    $0x8,%esp
  10b55b:	8d 83 bc 69 ff ff    	lea    -0x9644(%ebx),%eax
  10b561:	50                   	push   %eax
  10b562:	57                   	push   %edi
  10b563:	e8 a8 ed ff ff       	call   10a310 <dir_namecmp>
  10b568:	83 c4 10             	add    $0x10,%esp
  10b56b:	85 c0                	test   %eax,%eax
  10b56d:	74 95                	je     10b504 <sys_unlink+0xa4>
    if ((ip = dir_lookup(dp, name, &off)) == 0)
  10b56f:	83 ec 04             	sub    $0x4,%esp
  10b572:	8d 44 24 20          	lea    0x20(%esp),%eax
  10b576:	50                   	push   %eax
  10b577:	57                   	push   %edi
  10b578:	55                   	push   %ebp
  10b579:	e8 c2 ed ff ff       	call   10a340 <dir_lookup>
  10b57e:	83 c4 10             	add    $0x10,%esp
  10b581:	89 c7                	mov    %eax,%edi
  10b583:	85 c0                	test   %eax,%eax
  10b585:	0f 84 79 ff ff ff    	je     10b504 <sys_unlink+0xa4>
    inode_lock(ip);
  10b58b:	83 ec 0c             	sub    $0xc,%esp
  10b58e:	50                   	push   %eax
  10b58f:	e8 7c e7 ff ff       	call   109d10 <inode_lock>
    if (ip->nlink < 1)
  10b594:	83 c4 10             	add    $0x10,%esp
  10b597:	66 83 7f 16 00       	cmpw   $0x0,0x16(%edi)
  10b59c:	0f 8e 56 01 00 00    	jle    10b6f8 <sys_unlink+0x298>
    if (ip->type == T_DIR && !isdirempty(ip)) {
  10b5a2:	66 83 7f 10 01       	cmpw   $0x1,0x10(%edi)
  10b5a7:	8d 54 24 30          	lea    0x30(%esp),%edx
  10b5ab:	0f 84 af 00 00 00    	je     10b660 <sys_unlink+0x200>
    memset(&de, 0, sizeof(de));
  10b5b1:	83 ec 04             	sub    $0x4,%esp
  10b5b4:	6a 10                	push   $0x10
  10b5b6:	6a 00                	push   $0x0
  10b5b8:	52                   	push   %edx
  10b5b9:	89 54 24 14          	mov    %edx,0x14(%esp)
  10b5bd:	e8 6e 8e ff ff       	call   104430 <memset>
    if (inode_write(dp, (char *) &de, off, sizeof(de)) != sizeof(de))
  10b5c2:	6a 10                	push   $0x10
  10b5c4:	ff 74 24 30          	push   0x30(%esp)
  10b5c8:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  10b5cc:	52                   	push   %edx
  10b5cd:	55                   	push   %ebp
  10b5ce:	e8 dd eb ff ff       	call   10a1b0 <inode_write>
  10b5d3:	83 c4 20             	add    $0x20,%esp
  10b5d6:	83 f8 10             	cmp    $0x10,%eax
  10b5d9:	75 5d                	jne    10b638 <sys_unlink+0x1d8>
    if (ip->type == T_DIR) {
  10b5db:	66 83 7f 10 01       	cmpw   $0x1,0x10(%edi)
  10b5e0:	0f 84 3a 01 00 00    	je     10b720 <sys_unlink+0x2c0>
    inode_unlockput(dp);
  10b5e6:	83 ec 0c             	sub    $0xc,%esp
  10b5e9:	55                   	push   %ebp
  10b5ea:	e8 41 ea ff ff       	call   10a030 <inode_unlockput>
    ip->nlink--;
  10b5ef:	66 83 6f 16 01       	subw   $0x1,0x16(%edi)
    inode_update(ip);
  10b5f4:	89 3c 24             	mov    %edi,(%esp)
  10b5f7:	e8 34 e4 ff ff       	call   109a30 <inode_update>
    inode_unlockput(ip);
  10b5fc:	89 3c 24             	mov    %edi,(%esp)
  10b5ff:	e8 2c ea ff ff       	call   10a030 <inode_unlockput>
    commit_trans();
  10b604:	e8 87 de ff ff       	call   109490 <commit_trans>
    syscall_set_errno(tf, E_SUCC);
  10b609:	59                   	pop    %ecx
  10b60a:	5f                   	pop    %edi
  10b60b:	6a 00                	push   $0x0
  10b60d:	56                   	push   %esi
  10b60e:	e8 ad ca ff ff       	call   1080c0 <syscall_set_errno>
    return;
  10b613:	83 c4 10             	add    $0x10,%esp
  10b616:	e9 2d ff ff ff       	jmp    10b548 <sys_unlink+0xe8>
  10b61b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        syscall_set_errno(tf, E_DISK_OP);
  10b620:	83 ec 08             	sub    $0x8,%esp
  10b623:	6a 0d                	push   $0xd
  10b625:	56                   	push   %esi
  10b626:	e8 95 ca ff ff       	call   1080c0 <syscall_set_errno>
        return;
  10b62b:	83 c4 10             	add    $0x10,%esp
  10b62e:	e9 15 ff ff ff       	jmp    10b548 <sys_unlink+0xe8>
  10b633:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        KERN_PANIC("unlink: writei");
  10b638:	83 ec 04             	sub    $0x4,%esp
  10b63b:	8d 83 f4 69 ff ff    	lea    -0x960c(%ebx),%eax
  10b641:	50                   	push   %eax
  10b642:	8d 83 9e 69 ff ff    	lea    -0x9662(%ebx),%eax
  10b648:	68 68 01 00 00       	push   $0x168
  10b64d:	50                   	push   %eax
  10b64e:	e8 9d 91 ff ff       	call   1047f0 <debug_panic>
  10b653:	83 c4 10             	add    $0x10,%esp
  10b656:	e9 80 ff ff ff       	jmp    10b5db <sys_unlink+0x17b>
  10b65b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    for (off = 2 * sizeof(de); off < dp->size; off += sizeof(de)) {
  10b660:	83 7f 18 20          	cmpl   $0x20,0x18(%edi)
  10b664:	0f 86 47 ff ff ff    	jbe    10b5b1 <sys_unlink+0x151>
            KERN_PANIC("isdirempty: readi");
  10b66a:	8d 83 e2 69 ff ff    	lea    -0x961e(%ebx),%eax
    for (off = 2 * sizeof(de); off < dp->size; off += sizeof(de)) {
  10b670:	b9 20 00 00 00       	mov    $0x20,%ecx
            KERN_PANIC("isdirempty: readi");
  10b675:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
  10b679:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b67d:	8d 83 9e 69 ff ff    	lea    -0x9662(%ebx),%eax
  10b683:	89 cd                	mov    %ecx,%ebp
  10b685:	89 b4 24 e0 00 00 00 	mov    %esi,0xe0(%esp)
  10b68c:	89 d6                	mov    %edx,%esi
  10b68e:	89 44 24 08          	mov    %eax,0x8(%esp)
  10b692:	eb 10                	jmp    10b6a4 <sys_unlink+0x244>
  10b694:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    for (off = 2 * sizeof(de); off < dp->size; off += sizeof(de)) {
  10b698:	83 c5 10             	add    $0x10,%ebp
  10b69b:	3b 6f 18             	cmp    0x18(%edi),%ebp
  10b69e:	0f 83 9c 00 00 00    	jae    10b740 <sys_unlink+0x2e0>
        if (inode_read(dp, (char *) &de, off, sizeof(de)) != sizeof(de))
  10b6a4:	6a 10                	push   $0x10
  10b6a6:	55                   	push   %ebp
  10b6a7:	56                   	push   %esi
  10b6a8:	57                   	push   %edi
  10b6a9:	e8 d2 e9 ff ff       	call   10a080 <inode_read>
  10b6ae:	83 c4 10             	add    $0x10,%esp
  10b6b1:	83 f8 10             	cmp    $0x10,%eax
  10b6b4:	74 18                	je     10b6ce <sys_unlink+0x26e>
            KERN_PANIC("isdirempty: readi");
  10b6b6:	83 ec 04             	sub    $0x4,%esp
  10b6b9:	ff 74 24 08          	push   0x8(%esp)
  10b6bd:	68 37 01 00 00       	push   $0x137
  10b6c2:	ff 74 24 14          	push   0x14(%esp)
  10b6c6:	e8 25 91 ff ff       	call   1047f0 <debug_panic>
  10b6cb:	83 c4 10             	add    $0x10,%esp
        if (de.inum != 0)
  10b6ce:	66 83 7c 24 30 00    	cmpw   $0x0,0x30(%esp)
  10b6d4:	74 c2                	je     10b698 <sys_unlink+0x238>
        inode_unlockput(ip);
  10b6d6:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  10b6da:	8b b4 24 e0 00 00 00 	mov    0xe0(%esp),%esi
  10b6e1:	83 ec 0c             	sub    $0xc,%esp
  10b6e4:	57                   	push   %edi
  10b6e5:	e8 46 e9 ff ff       	call   10a030 <inode_unlockput>
        goto bad;
  10b6ea:	83 c4 10             	add    $0x10,%esp
  10b6ed:	e9 12 fe ff ff       	jmp    10b504 <sys_unlink+0xa4>
  10b6f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        KERN_PANIC("unlink: nlink < 1");
  10b6f8:	83 ec 04             	sub    $0x4,%esp
  10b6fb:	8d 83 d0 69 ff ff    	lea    -0x9630(%ebx),%eax
  10b701:	50                   	push   %eax
  10b702:	8d 83 9e 69 ff ff    	lea    -0x9662(%ebx),%eax
  10b708:	68 60 01 00 00       	push   $0x160
  10b70d:	50                   	push   %eax
  10b70e:	e8 dd 90 ff ff       	call   1047f0 <debug_panic>
  10b713:	83 c4 10             	add    $0x10,%esp
  10b716:	e9 87 fe ff ff       	jmp    10b5a2 <sys_unlink+0x142>
  10b71b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        inode_update(dp);
  10b720:	83 ec 0c             	sub    $0xc,%esp
        dp->nlink--;
  10b723:	66 83 6d 16 01       	subw   $0x1,0x16(%ebp)
        inode_update(dp);
  10b728:	55                   	push   %ebp
  10b729:	e8 02 e3 ff ff       	call   109a30 <inode_update>
  10b72e:	83 c4 10             	add    $0x10,%esp
  10b731:	e9 b0 fe ff ff       	jmp    10b5e6 <sys_unlink+0x186>
  10b736:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10b73d:	00 
  10b73e:	66 90                	xchg   %ax,%ax
  10b740:	89 f2                	mov    %esi,%edx
  10b742:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  10b746:	8b b4 24 e0 00 00 00 	mov    0xe0(%esp),%esi
  10b74d:	e9 5f fe ff ff       	jmp    10b5b1 <sys_unlink+0x151>
  10b752:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10b759:	00 
  10b75a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b760 <sys_open>:

void sys_open(tf_t *tf)
{
  10b760:	55                   	push   %ebp
  10b761:	57                   	push   %edi
  10b762:	56                   	push   %esi
  10b763:	53                   	push   %ebx
  10b764:	e8 39 4c ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10b769:	81 c3 8b b8 00 00    	add    $0xb88b,%ebx
  10b76f:	81 ec a8 00 00 00    	sub    $0xa8,%esp
  10b775:	8b b4 24 bc 00 00 00 	mov    0xbc(%esp),%esi
    char path[128];
    int fd, omode;
    struct file *f;
    struct inode *ip;

    uintptr_t buf = syscall_get_arg2(tf);
  10b77c:	56                   	push   %esi
  10b77d:	e8 ee c8 ff ff       	call   108070 <syscall_get_arg2>
    size_t buflen = syscall_get_arg4(tf);
  10b782:	89 34 24             	mov    %esi,(%esp)
    uintptr_t buf = syscall_get_arg2(tf);
  10b785:	89 c5                	mov    %eax,%ebp
    size_t buflen = syscall_get_arg4(tf);
  10b787:	e8 04 c9 ff ff       	call   108090 <syscall_get_arg4>
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10b78c:	83 c4 10             	add    $0x10,%esp
  10b78f:	81 fd ff ff ff 3f    	cmp    $0x3fffffff,%ebp
  10b795:	0f 86 dd 00 00 00    	jbe    10b878 <sys_open+0x118>
  10b79b:	89 c7                	mov    %eax,%edi
  10b79d:	8d 44 05 00          	lea    0x0(%ebp,%eax,1),%eax
        || (0 < maxlen && maxlen <= len)) {
  10b7a1:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  10b7a6:	0f 87 cc 00 00 00    	ja     10b878 <sys_open+0x118>
  10b7ac:	83 ff 7f             	cmp    $0x7f,%edi
  10b7af:	0f 87 c3 00 00 00    	ja     10b878 <sys_open+0x118>
    if (!check_buf(tf, buf, buflen, 128)) {
        // KERN_DEBUG("Process: %d, ending sys_open()\n", get_curid());
        return;
    }

    pt_copyin(get_curid(), buf, path, buflen);
  10b7b5:	e8 66 c2 ff ff       	call   107a20 <get_curid>
  10b7ba:	57                   	push   %edi
  10b7bb:	8d 7c 24 14          	lea    0x14(%esp),%edi
  10b7bf:	57                   	push   %edi
  10b7c0:	55                   	push   %ebp
  10b7c1:	50                   	push   %eax
  10b7c2:	e8 69 a1 ff ff       	call   105930 <pt_copyin>
    omode = syscall_get_arg3(tf);
  10b7c7:	89 34 24             	mov    %esi,(%esp)
  10b7ca:	e8 b1 c8 ff ff       	call   108080 <syscall_get_arg3>

    if (omode & O_CREATE) {
  10b7cf:	83 c4 10             	add    $0x10,%esp
    omode = syscall_get_arg3(tf);
  10b7d2:	89 c5                	mov    %eax,%ebp
    if (omode & O_CREATE) {
  10b7d4:	f6 c4 02             	test   $0x2,%ah
  10b7d7:	0f 84 33 01 00 00    	je     10b910 <sys_open+0x1b0>
        // KERN_DEBUG("Process: %d, creating flockfile\n", get_curid());
        begin_trans();
  10b7dd:	e8 4e dc ff ff       	call   109430 <begin_trans>
        ip = create(path, T_FILE, 0, 0);
  10b7e2:	89 f8                	mov    %edi,%eax
  10b7e4:	ba 02 00 00 00       	mov    $0x2,%edx
  10b7e9:	e8 72 f4 ff ff       	call   10ac60 <create.constprop.0>
  10b7ee:	89 c7                	mov    %eax,%edi
        commit_trans();
  10b7f0:	e8 9b dc ff ff       	call   109490 <commit_trans>
        if (ip == 0) {
  10b7f5:	85 ff                	test   %edi,%edi
  10b7f7:	0f 84 70 01 00 00    	je     10b96d <sys_open+0x20d>
        }
        // KERN_DEBUG("Process: %d, END check inode\n");
    }

    // KERN_DEBUG("Process: %d, START allocating file structure\n");
    if ((f = file_alloc()) == 0 || (fd = fdalloc(f)) < 0) {
  10b7fd:	e8 4e f0 ff ff       	call   10a850 <file_alloc>
  10b802:	85 c0                	test   %eax,%eax
  10b804:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b808:	74 40                	je     10b84a <sys_open+0xea>
    int pid = get_curid();
  10b80a:	e8 11 c2 ff ff       	call   107a20 <get_curid>
    struct file **openfiles = tcb_get_openfiles(pid);
  10b80f:	83 ec 0c             	sub    $0xc,%esp
    int pid = get_curid();
  10b812:	89 44 24 14          	mov    %eax,0x14(%esp)
    struct file **openfiles = tcb_get_openfiles(pid);
  10b816:	50                   	push   %eax
  10b817:	e8 44 be ff ff       	call   107660 <tcb_get_openfiles>
    for (fd = 0; fd < NOFILE; fd++) {
  10b81c:	8b 54 24 14          	mov    0x14(%esp),%edx
    struct file **openfiles = tcb_get_openfiles(pid);
  10b820:	83 c4 10             	add    $0x10,%esp
  10b823:	89 c1                	mov    %eax,%ecx
    for (fd = 0; fd < NOFILE; fd++) {
  10b825:	31 c0                	xor    %eax,%eax
  10b827:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10b82e:	00 
  10b82f:	90                   	nop
        if (openfiles[fd] == NULL) {
  10b830:	83 3c 81 00          	cmpl   $0x0,(%ecx,%eax,4)
  10b834:	74 6a                	je     10b8a0 <sys_open+0x140>
    for (fd = 0; fd < NOFILE; fd++) {
  10b836:	83 c0 01             	add    $0x1,%eax
  10b839:	83 f8 10             	cmp    $0x10,%eax
  10b83c:	75 f2                	jne    10b830 <sys_open+0xd0>
        if (f)
            file_close(f);
  10b83e:	83 ec 0c             	sub    $0xc,%esp
  10b841:	52                   	push   %edx
  10b842:	e8 f9 f0 ff ff       	call   10a940 <file_close>
  10b847:	83 c4 10             	add    $0x10,%esp
        inode_unlockput(ip);
  10b84a:	83 ec 0c             	sub    $0xc,%esp
  10b84d:	57                   	push   %edi
  10b84e:	e8 dd e7 ff ff       	call   10a030 <inode_unlockput>
        syscall_set_retval1(tf, -1);
  10b853:	58                   	pop    %eax
  10b854:	5a                   	pop    %edx
  10b855:	6a ff                	push   $0xffffffff
  10b857:	56                   	push   %esi
  10b858:	e8 73 c8 ff ff       	call   1080d0 <syscall_set_retval1>
        syscall_set_errno(tf, E_DISK_OP);
  10b85d:	59                   	pop    %ecx
  10b85e:	5f                   	pop    %edi
  10b85f:	6a 0d                	push   $0xd
  10b861:	56                   	push   %esi
  10b862:	e8 59 c8 ff ff       	call   1080c0 <syscall_set_errno>
        // KERN_DEBUG("Process: %d, ending sys_open()\n", get_curid());
        return;
  10b867:	83 c4 10             	add    $0x10,%esp
    f->readable = !(omode & O_WRONLY);
    f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
    syscall_set_retval1(tf, fd);
    syscall_set_errno(tf, E_SUCC);
    // KERN_DEBUG("Process: %d, ending sys_open()\n", get_curid());
}
  10b86a:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  10b870:	5b                   	pop    %ebx
  10b871:	5e                   	pop    %esi
  10b872:	5f                   	pop    %edi
  10b873:	5d                   	pop    %ebp
  10b874:	c3                   	ret
  10b875:	8d 76 00             	lea    0x0(%esi),%esi
        syscall_set_errno(tf, E_INVAL_ADDR);
  10b878:	83 ec 08             	sub    $0x8,%esp
  10b87b:	6a 04                	push   $0x4
  10b87d:	56                   	push   %esi
  10b87e:	e8 3d c8 ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, -1);
  10b883:	5d                   	pop    %ebp
  10b884:	58                   	pop    %eax
  10b885:	6a ff                	push   $0xffffffff
  10b887:	56                   	push   %esi
  10b888:	e8 43 c8 ff ff       	call   1080d0 <syscall_set_retval1>
  10b88d:	83 c4 10             	add    $0x10,%esp
}
  10b890:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  10b896:	5b                   	pop    %ebx
  10b897:	5e                   	pop    %esi
  10b898:	5f                   	pop    %edi
  10b899:	5d                   	pop    %ebp
  10b89a:	c3                   	ret
  10b89b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
            tcb_set_openfiles(pid, fd, f);
  10b8a0:	83 ec 04             	sub    $0x4,%esp
  10b8a3:	52                   	push   %edx
  10b8a4:	89 54 24 14          	mov    %edx,0x14(%esp)
  10b8a8:	50                   	push   %eax
  10b8a9:	89 44 24 10          	mov    %eax,0x10(%esp)
  10b8ad:	ff 74 24 14          	push   0x14(%esp)
  10b8b1:	e8 ca bd ff ff       	call   107680 <tcb_set_openfiles>
    inode_unlock(ip);
  10b8b6:	89 3c 24             	mov    %edi,(%esp)
  10b8b9:	e8 62 e5 ff ff       	call   109e20 <inode_unlock>
    f->readable = !(omode & O_WRONLY);
  10b8be:	89 e9                	mov    %ebp,%ecx
    f->type = FD_INODE;
  10b8c0:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    f->readable = !(omode & O_WRONLY);
  10b8c4:	f7 d1                	not    %ecx
  10b8c6:	83 e1 01             	and    $0x1,%ecx
    f->ip = ip;
  10b8c9:	89 7a 0c             	mov    %edi,0xc(%edx)
    f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
  10b8cc:	83 e5 03             	and    $0x3,%ebp
    f->type = FD_INODE;
  10b8cf:	c7 02 02 00 00 00    	movl   $0x2,(%edx)
    f->off = 0;
  10b8d5:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
    f->readable = !(omode & O_WRONLY);
  10b8dc:	88 4a 08             	mov    %cl,0x8(%edx)
    f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
  10b8df:	58                   	pop    %eax
  10b8e0:	59                   	pop    %ecx
    syscall_set_retval1(tf, fd);
  10b8e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
  10b8e5:	0f 95 42 09          	setne  0x9(%edx)
    syscall_set_retval1(tf, fd);
  10b8e9:	50                   	push   %eax
  10b8ea:	56                   	push   %esi
  10b8eb:	e8 e0 c7 ff ff       	call   1080d0 <syscall_set_retval1>
    syscall_set_errno(tf, E_SUCC);
  10b8f0:	5f                   	pop    %edi
  10b8f1:	5d                   	pop    %ebp
  10b8f2:	6a 00                	push   $0x0
  10b8f4:	56                   	push   %esi
  10b8f5:	e8 c6 c7 ff ff       	call   1080c0 <syscall_set_errno>
  10b8fa:	83 c4 10             	add    $0x10,%esp
}
  10b8fd:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  10b903:	5b                   	pop    %ebx
  10b904:	5e                   	pop    %esi
  10b905:	5f                   	pop    %edi
  10b906:	5d                   	pop    %ebp
  10b907:	c3                   	ret
  10b908:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10b90f:	00 
        if ((ip = namei(path)) == 0) {
  10b910:	83 ec 0c             	sub    $0xc,%esp
  10b913:	57                   	push   %edi
  10b914:	e8 b7 ed ff ff       	call   10a6d0 <namei>
  10b919:	83 c4 10             	add    $0x10,%esp
  10b91c:	89 c7                	mov    %eax,%edi
  10b91e:	85 c0                	test   %eax,%eax
  10b920:	74 2e                	je     10b950 <sys_open+0x1f0>
        inode_lock(ip);
  10b922:	83 ec 0c             	sub    $0xc,%esp
  10b925:	50                   	push   %eax
  10b926:	e8 e5 e3 ff ff       	call   109d10 <inode_lock>
        if (ip->type == T_DIR && omode != O_RDONLY) {
  10b92b:	83 c4 10             	add    $0x10,%esp
  10b92e:	66 83 7f 10 01       	cmpw   $0x1,0x10(%edi)
  10b933:	0f 85 c4 fe ff ff    	jne    10b7fd <sys_open+0x9d>
  10b939:	85 ed                	test   %ebp,%ebp
  10b93b:	0f 84 bc fe ff ff    	je     10b7fd <sys_open+0x9d>
  10b941:	e9 04 ff ff ff       	jmp    10b84a <sys_open+0xea>
  10b946:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10b94d:	00 
  10b94e:	66 90                	xchg   %ax,%ax
            syscall_set_retval1(tf, -1);
  10b950:	83 ec 08             	sub    $0x8,%esp
  10b953:	6a ff                	push   $0xffffffff
  10b955:	56                   	push   %esi
  10b956:	e8 75 c7 ff ff       	call   1080d0 <syscall_set_retval1>
            syscall_set_errno(tf, E_NEXIST);
  10b95b:	58                   	pop    %eax
  10b95c:	5a                   	pop    %edx
  10b95d:	6a 1a                	push   $0x1a
  10b95f:	56                   	push   %esi
  10b960:	e8 5b c7 ff ff       	call   1080c0 <syscall_set_errno>
            return;
  10b965:	83 c4 10             	add    $0x10,%esp
  10b968:	e9 23 ff ff ff       	jmp    10b890 <sys_open+0x130>
            syscall_set_retval1(tf, -1);
  10b96d:	83 ec 08             	sub    $0x8,%esp
  10b970:	6a ff                	push   $0xffffffff
  10b972:	56                   	push   %esi
  10b973:	e8 58 c7 ff ff       	call   1080d0 <syscall_set_retval1>
            syscall_set_errno(tf, E_CREATE);
  10b978:	59                   	pop    %ecx
  10b979:	5f                   	pop    %edi
  10b97a:	6a 1b                	push   $0x1b
  10b97c:	56                   	push   %esi
  10b97d:	e8 3e c7 ff ff       	call   1080c0 <syscall_set_errno>
            return;
  10b982:	83 c4 10             	add    $0x10,%esp
  10b985:	e9 06 ff ff ff       	jmp    10b890 <sys_open+0x130>
  10b98a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b990 <sys_mkdir>:

void sys_mkdir(tf_t *tf)
{
  10b990:	55                   	push   %ebp
  10b991:	57                   	push   %edi
  10b992:	56                   	push   %esi
  10b993:	53                   	push   %ebx
  10b994:	e8 09 4a ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10b999:	81 c3 5b b6 00 00    	add    $0xb65b,%ebx
  10b99f:	81 ec 98 00 00 00    	sub    $0x98,%esp
  10b9a5:	8b bc 24 ac 00 00 00 	mov    0xac(%esp),%edi
    char path[128];
    struct inode *ip;

    uintptr_t buf = syscall_get_arg2(tf);
  10b9ac:	57                   	push   %edi
  10b9ad:	e8 be c6 ff ff       	call   108070 <syscall_get_arg2>
    size_t buflen = syscall_get_arg3(tf);
  10b9b2:	89 3c 24             	mov    %edi,(%esp)
    uintptr_t buf = syscall_get_arg2(tf);
  10b9b5:	89 c6                	mov    %eax,%esi
    size_t buflen = syscall_get_arg3(tf);
  10b9b7:	e8 c4 c6 ff ff       	call   108080 <syscall_get_arg3>
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10b9bc:	83 c4 10             	add    $0x10,%esp
  10b9bf:	81 fe ff ff ff 3f    	cmp    $0x3fffffff,%esi
  10b9c5:	76 69                	jbe    10ba30 <sys_mkdir+0xa0>
  10b9c7:	89 c5                	mov    %eax,%ebp
  10b9c9:	8d 04 06             	lea    (%esi,%eax,1),%eax
        || (0 < maxlen && maxlen <= len)) {
  10b9cc:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  10b9d1:	77 5d                	ja     10ba30 <sys_mkdir+0xa0>
  10b9d3:	83 fd 7f             	cmp    $0x7f,%ebp
  10b9d6:	77 58                	ja     10ba30 <sys_mkdir+0xa0>

    if (!check_buf(tf, buf, buflen, 128)) {
        return;
    }

    pt_copyin(get_curid(), buf, path, buflen);
  10b9d8:	e8 43 c0 ff ff       	call   107a20 <get_curid>
  10b9dd:	55                   	push   %ebp
  10b9de:	8d 6c 24 04          	lea    0x4(%esp),%ebp
  10b9e2:	55                   	push   %ebp
  10b9e3:	56                   	push   %esi
  10b9e4:	50                   	push   %eax
  10b9e5:	e8 46 9f ff ff       	call   105930 <pt_copyin>

    begin_trans();
  10b9ea:	e8 41 da ff ff       	call   109430 <begin_trans>
    if ((ip = (struct inode *) create(path, T_DIR, 0, 0)) == 0) {
  10b9ef:	ba 01 00 00 00       	mov    $0x1,%edx
  10b9f4:	89 e8                	mov    %ebp,%eax
  10b9f6:	e8 65 f2 ff ff       	call   10ac60 <create.constprop.0>
  10b9fb:	89 ec                	mov    %ebp,%esp
  10b9fd:	85 c0                	test   %eax,%eax
  10b9ff:	74 57                	je     10ba58 <sys_mkdir+0xc8>
        commit_trans();
        syscall_set_errno(tf, E_DISK_OP);
        return;
    }
    inode_unlockput(ip);
  10ba01:	83 ec 0c             	sub    $0xc,%esp
  10ba04:	50                   	push   %eax
  10ba05:	e8 26 e6 ff ff       	call   10a030 <inode_unlockput>
    commit_trans();
  10ba0a:	e8 81 da ff ff       	call   109490 <commit_trans>
    syscall_set_errno(tf, E_SUCC);
  10ba0f:	58                   	pop    %eax
  10ba10:	5a                   	pop    %edx
  10ba11:	6a 00                	push   $0x0
  10ba13:	57                   	push   %edi
  10ba14:	e8 a7 c6 ff ff       	call   1080c0 <syscall_set_errno>
  10ba19:	83 c4 10             	add    $0x10,%esp
}
  10ba1c:	81 c4 8c 00 00 00    	add    $0x8c,%esp
  10ba22:	5b                   	pop    %ebx
  10ba23:	5e                   	pop    %esi
  10ba24:	5f                   	pop    %edi
  10ba25:	5d                   	pop    %ebp
  10ba26:	c3                   	ret
  10ba27:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10ba2e:	00 
  10ba2f:	90                   	nop
        syscall_set_errno(tf, E_INVAL_ADDR);
  10ba30:	83 ec 08             	sub    $0x8,%esp
  10ba33:	6a 04                	push   $0x4
  10ba35:	57                   	push   %edi
  10ba36:	e8 85 c6 ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, -1);
  10ba3b:	59                   	pop    %ecx
  10ba3c:	5e                   	pop    %esi
  10ba3d:	6a ff                	push   $0xffffffff
  10ba3f:	57                   	push   %edi
  10ba40:	e8 8b c6 ff ff       	call   1080d0 <syscall_set_retval1>
  10ba45:	83 c4 10             	add    $0x10,%esp
}
  10ba48:	81 c4 8c 00 00 00    	add    $0x8c,%esp
  10ba4e:	5b                   	pop    %ebx
  10ba4f:	5e                   	pop    %esi
  10ba50:	5f                   	pop    %edi
  10ba51:	5d                   	pop    %ebp
  10ba52:	c3                   	ret
  10ba53:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
        commit_trans();
  10ba58:	e8 33 da ff ff       	call   109490 <commit_trans>
        syscall_set_errno(tf, E_DISK_OP);
  10ba5d:	83 ec 08             	sub    $0x8,%esp
  10ba60:	6a 0d                	push   $0xd
  10ba62:	57                   	push   %edi
  10ba63:	e8 58 c6 ff ff       	call   1080c0 <syscall_set_errno>
        return;
  10ba68:	83 c4 10             	add    $0x10,%esp
  10ba6b:	eb db                	jmp    10ba48 <sys_mkdir+0xb8>
  10ba6d:	8d 76 00             	lea    0x0(%esi),%esi

0010ba70 <sys_chdir>:

void sys_chdir(tf_t *tf)
{
  10ba70:	55                   	push   %ebp
  10ba71:	57                   	push   %edi
  10ba72:	56                   	push   %esi
  10ba73:	53                   	push   %ebx
  10ba74:	e8 29 49 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10ba79:	81 c3 7b b5 00 00    	add    $0xb57b,%ebx
  10ba7f:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
  10ba85:	8b b4 24 b0 00 00 00 	mov    0xb0(%esp),%esi
    char path[128];
    struct inode *ip;
    int pid = get_curid();
  10ba8c:	e8 8f bf ff ff       	call   107a20 <get_curid>

    uintptr_t buf = syscall_get_arg2(tf);
  10ba91:	83 ec 0c             	sub    $0xc,%esp
  10ba94:	56                   	push   %esi
    int pid = get_curid();
  10ba95:	89 c7                	mov    %eax,%edi
    uintptr_t buf = syscall_get_arg2(tf);
  10ba97:	e8 d4 c5 ff ff       	call   108070 <syscall_get_arg2>
    size_t buflen = syscall_get_arg3(tf);
  10ba9c:	89 34 24             	mov    %esi,(%esp)
    uintptr_t buf = syscall_get_arg2(tf);
  10ba9f:	89 c5                	mov    %eax,%ebp
    size_t buflen = syscall_get_arg3(tf);
  10baa1:	e8 da c5 ff ff       	call   108080 <syscall_get_arg3>
    if (!(VM_USERLO <= buf && buf + len <= VM_USERHI)
  10baa6:	83 c4 10             	add    $0x10,%esp
  10baa9:	81 fd ff ff ff 3f    	cmp    $0x3fffffff,%ebp
  10baaf:	76 7f                	jbe    10bb30 <sys_chdir+0xc0>
  10bab1:	89 c2                	mov    %eax,%edx
  10bab3:	8d 44 05 00          	lea    0x0(%ebp,%eax,1),%eax
        || (0 < maxlen && maxlen <= len)) {
  10bab7:	3d 00 00 00 f0       	cmp    $0xf0000000,%eax
  10babc:	77 72                	ja     10bb30 <sys_chdir+0xc0>
  10babe:	83 fa 7f             	cmp    $0x7f,%edx
  10bac1:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10bac5:	77 69                	ja     10bb30 <sys_chdir+0xc0>

    if (!check_buf(tf, buf, buflen, 128)) {
        return;
    }

    pt_copyin(get_curid(), buf, path, buflen);
  10bac7:	e8 54 bf ff ff       	call   107a20 <get_curid>
  10bacc:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10bad0:	52                   	push   %edx
  10bad1:	8d 54 24 14          	lea    0x14(%esp),%edx
  10bad5:	52                   	push   %edx
  10bad6:	89 54 24 14          	mov    %edx,0x14(%esp)
  10bada:	55                   	push   %ebp
  10badb:	50                   	push   %eax
  10badc:	e8 4f 9e ff ff       	call   105930 <pt_copyin>

    if ((ip = namei(path)) == 0) {
  10bae1:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  10bae5:	89 14 24             	mov    %edx,(%esp)
  10bae8:	e8 e3 eb ff ff       	call   10a6d0 <namei>
  10baed:	83 c4 10             	add    $0x10,%esp
  10baf0:	89 c5                	mov    %eax,%ebp
  10baf2:	85 c0                	test   %eax,%eax
  10baf4:	0f 84 9e 00 00 00    	je     10bb98 <sys_chdir+0x128>
        syscall_set_errno(tf, E_DISK_OP);
        return;
    }
    inode_lock(ip);
  10bafa:	83 ec 0c             	sub    $0xc,%esp
  10bafd:	50                   	push   %eax
  10bafe:	e8 0d e2 ff ff       	call   109d10 <inode_lock>
    if (ip->type != T_DIR) {
  10bb03:	83 c4 10             	add    $0x10,%esp
  10bb06:	66 83 7d 10 01       	cmpw   $0x1,0x10(%ebp)
  10bb0b:	74 4b                	je     10bb58 <sys_chdir+0xe8>
        inode_unlockput(ip);
  10bb0d:	83 ec 0c             	sub    $0xc,%esp
  10bb10:	55                   	push   %ebp
  10bb11:	e8 1a e5 ff ff       	call   10a030 <inode_unlockput>
        syscall_set_errno(tf, E_DISK_OP);
  10bb16:	5d                   	pop    %ebp
  10bb17:	58                   	pop    %eax
  10bb18:	6a 0d                	push   $0xd
  10bb1a:	56                   	push   %esi
  10bb1b:	e8 a0 c5 ff ff       	call   1080c0 <syscall_set_errno>
        return;
  10bb20:	83 c4 10             	add    $0x10,%esp
    }
    inode_unlock(ip);
    inode_put(tcb_get_cwd(pid));
    tcb_set_cwd(pid, ip);
    syscall_set_errno(tf, E_SUCC);
}
  10bb23:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  10bb29:	5b                   	pop    %ebx
  10bb2a:	5e                   	pop    %esi
  10bb2b:	5f                   	pop    %edi
  10bb2c:	5d                   	pop    %ebp
  10bb2d:	c3                   	ret
  10bb2e:	66 90                	xchg   %ax,%ax
        syscall_set_errno(tf, E_INVAL_ADDR);
  10bb30:	83 ec 08             	sub    $0x8,%esp
  10bb33:	6a 04                	push   $0x4
  10bb35:	56                   	push   %esi
  10bb36:	e8 85 c5 ff ff       	call   1080c0 <syscall_set_errno>
        syscall_set_retval1(tf, -1);
  10bb3b:	58                   	pop    %eax
  10bb3c:	5a                   	pop    %edx
  10bb3d:	6a ff                	push   $0xffffffff
  10bb3f:	56                   	push   %esi
  10bb40:	e8 8b c5 ff ff       	call   1080d0 <syscall_set_retval1>
  10bb45:	83 c4 10             	add    $0x10,%esp
}
  10bb48:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  10bb4e:	5b                   	pop    %ebx
  10bb4f:	5e                   	pop    %esi
  10bb50:	5f                   	pop    %edi
  10bb51:	5d                   	pop    %ebp
  10bb52:	c3                   	ret
  10bb53:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
    inode_unlock(ip);
  10bb58:	83 ec 0c             	sub    $0xc,%esp
  10bb5b:	55                   	push   %ebp
  10bb5c:	e8 bf e2 ff ff       	call   109e20 <inode_unlock>
    inode_put(tcb_get_cwd(pid));
  10bb61:	89 3c 24             	mov    %edi,(%esp)
  10bb64:	e8 37 bb ff ff       	call   1076a0 <tcb_get_cwd>
  10bb69:	89 04 24             	mov    %eax,(%esp)
  10bb6c:	e8 2f e3 ff ff       	call   109ea0 <inode_put>
    tcb_set_cwd(pid, ip);
  10bb71:	58                   	pop    %eax
  10bb72:	5a                   	pop    %edx
  10bb73:	55                   	push   %ebp
  10bb74:	57                   	push   %edi
  10bb75:	e8 46 bb ff ff       	call   1076c0 <tcb_set_cwd>
    syscall_set_errno(tf, E_SUCC);
  10bb7a:	59                   	pop    %ecx
  10bb7b:	5f                   	pop    %edi
  10bb7c:	6a 00                	push   $0x0
  10bb7e:	56                   	push   %esi
  10bb7f:	e8 3c c5 ff ff       	call   1080c0 <syscall_set_errno>
  10bb84:	83 c4 10             	add    $0x10,%esp
}
  10bb87:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  10bb8d:	5b                   	pop    %ebx
  10bb8e:	5e                   	pop    %esi
  10bb8f:	5f                   	pop    %edi
  10bb90:	5d                   	pop    %ebp
  10bb91:	c3                   	ret
  10bb92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        syscall_set_errno(tf, E_DISK_OP);
  10bb98:	83 ec 08             	sub    $0x8,%esp
  10bb9b:	6a 0d                	push   $0xd
  10bb9d:	56                   	push   %esi
  10bb9e:	e8 1d c5 ff ff       	call   1080c0 <syscall_set_errno>
        return;
  10bba3:	83 c4 10             	add    $0x10,%esp
  10bba6:	eb a0                	jmp    10bb48 <sys_chdir+0xd8>
  10bba8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10bbaf:	00 

0010bbb0 <sys_flock>:

void sys_flock(tf_t *tf) {
  10bbb0:	55                   	push   %ebp
  10bbb1:	57                   	push   %edi
  10bbb2:	56                   	push   %esi
  10bbb3:	53                   	push   %ebx
  10bbb4:	e8 e9 47 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10bbb9:	81 c3 3b b4 00 00    	add    $0xb43b,%ebx
  10bbbf:	83 ec 18             	sub    $0x18,%esp
  10bbc2:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
    int fd = syscall_get_arg2(tf), op = syscall_get_arg3(tf);
  10bbc6:	55                   	push   %ebp
  10bbc7:	e8 a4 c4 ff ff       	call   108070 <syscall_get_arg2>
  10bbcc:	89 2c 24             	mov    %ebp,(%esp)
  10bbcf:	89 c6                	mov    %eax,%esi
  10bbd1:	e8 aa c4 ff ff       	call   108080 <syscall_get_arg3>
    KERN_DEBUG("sys_flock fd %d. operation %s\n", fd, flock_operations[op / 2]);
  10bbd6:	5a                   	pop    %edx
    int fd = syscall_get_arg2(tf), op = syscall_get_arg3(tf);
  10bbd7:	89 c7                	mov    %eax,%edi
    KERN_DEBUG("sys_flock fd %d. operation %s\n", fd, flock_operations[op / 2]);
  10bbd9:	c1 e8 1f             	shr    $0x1f,%eax
  10bbdc:	01 f8                	add    %edi,%eax
  10bbde:	d1 f8                	sar    $1,%eax
  10bbe0:	ff b4 83 d8 ff ff ff 	push   -0x28(%ebx,%eax,4)
  10bbe7:	8d 83 0c 75 ff ff    	lea    -0x8af4(%ebx),%eax
  10bbed:	56                   	push   %esi
  10bbee:	50                   	push   %eax
  10bbef:	8d 83 9e 69 ff ff    	lea    -0x9662(%ebx),%eax
  10bbf5:	68 2e 02 00 00       	push   $0x22e
  10bbfa:	50                   	push   %eax
  10bbfb:	e8 90 8b ff ff       	call   104790 <debug_normal>
    if (fd < 0 || fd >= NOFILE) {
  10bc00:	83 c4 20             	add    $0x20,%esp
  10bc03:	83 fe 0f             	cmp    $0xf,%esi
  10bc06:	77 1d                	ja     10bc25 <sys_flock+0x75>
        syscall_set_retval1(tf, -1);
        syscall_set_errno(tf, E_BADF);
        return;
    }
    struct file *f = tcb_get_openfiles(get_curid())[fd];
  10bc08:	e8 13 be ff ff       	call   107a20 <get_curid>
  10bc0d:	83 ec 0c             	sub    $0xc,%esp
  10bc10:	50                   	push   %eax
  10bc11:	e8 4a ba ff ff       	call   107660 <tcb_get_openfiles>
    if (f != NULL && f->type == FD_INODE) {
  10bc16:	83 c4 10             	add    $0x10,%esp
    struct file *f = tcb_get_openfiles(get_curid())[fd];
  10bc19:	8b 04 b0             	mov    (%eax,%esi,4),%eax
    if (f != NULL && f->type == FD_INODE) {
  10bc1c:	85 c0                	test   %eax,%eax
  10bc1e:	74 05                	je     10bc25 <sys_flock+0x75>
  10bc20:	83 38 02             	cmpl   $0x2,(%eax)
  10bc23:	74 23                	je     10bc48 <sys_flock+0x98>
        syscall_set_retval1(tf, -1);
  10bc25:	83 ec 08             	sub    $0x8,%esp
  10bc28:	6a ff                	push   $0xffffffff
  10bc2a:	55                   	push   %ebp
  10bc2b:	e8 a0 c4 ff ff       	call   1080d0 <syscall_set_retval1>
        syscall_set_errno(tf, E_BADF);
  10bc30:	59                   	pop    %ecx
  10bc31:	5e                   	pop    %esi
  10bc32:	6a 1d                	push   $0x1d
  10bc34:	55                   	push   %ebp
  10bc35:	e8 86 c4 ff ff       	call   1080c0 <syscall_set_errno>
        return;
  10bc3a:	83 c4 10             	add    $0x10,%esp
    } else {
        syscall_set_retval1(tf, -1);
        syscall_set_errno(tf, E_BADF);
        return;
    }
  10bc3d:	83 c4 0c             	add    $0xc,%esp
  10bc40:	5b                   	pop    %ebx
  10bc41:	5e                   	pop    %esi
  10bc42:	5f                   	pop    %edi
  10bc43:	5d                   	pop    %ebp
  10bc44:	c3                   	ret
  10bc45:	8d 76 00             	lea    0x0(%esi),%esi
        if (file_flock(f, op) >= 0) {
  10bc48:	83 ec 08             	sub    $0x8,%esp
  10bc4b:	57                   	push   %edi
  10bc4c:	50                   	push   %eax
  10bc4d:	e8 de ea ff ff       	call   10a730 <file_flock>
  10bc52:	83 c4 10             	add    $0x10,%esp
  10bc55:	85 c0                	test   %eax,%eax
  10bc57:	78 cc                	js     10bc25 <sys_flock+0x75>
            syscall_set_retval1(tf, 0);
  10bc59:	83 ec 08             	sub    $0x8,%esp
  10bc5c:	6a 00                	push   $0x0
  10bc5e:	55                   	push   %ebp
  10bc5f:	e8 6c c4 ff ff       	call   1080d0 <syscall_set_retval1>
            syscall_set_errno(tf, E_SUCC);
  10bc64:	58                   	pop    %eax
  10bc65:	5a                   	pop    %edx
  10bc66:	6a 00                	push   $0x0
  10bc68:	55                   	push   %ebp
  10bc69:	e8 52 c4 ff ff       	call   1080c0 <syscall_set_errno>
  10bc6e:	83 c4 10             	add    $0x10,%esp
  10bc71:	83 c4 0c             	add    $0xc,%esp
  10bc74:	5b                   	pop    %ebx
  10bc75:	5e                   	pop    %esi
  10bc76:	5f                   	pop    %edi
  10bc77:	5d                   	pop    %ebp
  10bc78:	c3                   	ret
  10bc79:	66 90                	xchg   %ax,%ax
  10bc7b:	66 90                	xchg   %ax,%ax
  10bc7d:	66 90                	xchg   %ax,%ax
  10bc7f:	90                   	nop

0010bc80 <cv_init>:

/**
 * Initialize a condition variable
*/
void cv_init(cv_t *cv)
{
  10bc80:	8b 44 24 04          	mov    0x4(%esp),%eax
	cv->read_idx = 0; 
  10bc84:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	cv->write_idx = 0;
  10bc8a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	cv->size = 0; 
  10bc91:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
  10bc98:	c3                   	ret
  10bc99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0010bca0 <cv_wait>:
 * Atomically release the lock and go to sleep. 
 * When thread wakes up again (on receveving a signal)
 * reacquire the lock before returning
*/
void cv_wait(cv_t *cv, spinlock_t *lock)
{
  10bca0:	55                   	push   %ebp
  10bca1:	57                   	push   %edi
  10bca2:	56                   	push   %esi
  10bca3:	53                   	push   %ebx
  10bca4:	e8 f9 46 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10bca9:	81 c3 4b b3 00 00    	add    $0xb34b,%ebx
  10bcaf:	83 ec 0c             	sub    $0xc,%esp
  10bcb2:	8b 7c 24 24          	mov    0x24(%esp),%edi
  10bcb6:	8b 74 24 20          	mov    0x20(%esp),%esi
    // ensure that the lock is being held
	intr_local_disable(); 
  10bcba:	e8 21 5d ff ff       	call   1019e0 <intr_local_disable>
	KERN_ASSERT(spinlock_holding(lock));
  10bcbf:	83 ec 0c             	sub    $0xc,%esp
  10bcc2:	8d ab 3a 6a ff ff    	lea    -0x95c6(%ebx),%ebp
  10bcc8:	57                   	push   %edi
  10bcc9:	e8 12 a2 ff ff       	call   105ee0 <spinlock_holding>
  10bcce:	83 c4 10             	add    $0x10,%esp
  10bcd1:	84 c0                	test   %al,%al
  10bcd3:	0f 84 7f 00 00 00    	je     10bd58 <cv_wait+0xb8>
	intr_local_enable(); 
  10bcd9:	e8 e2 5c ff ff       	call   1019c0 <intr_local_enable>

    // add this thread to the waiting queue of the condition variable 
    unsigned int cur_pid = get_curid();
  10bcde:	e8 3d bd ff ff       	call   107a20 <get_curid>
	return cv->size; 
  10bce3:	8b 56 08             	mov    0x8(%esi),%edx

	if (cv_get_queue_size(cv) == NUM_IDS) {
  10bce6:	83 fa 40             	cmp    $0x40,%edx
  10bce9:	0f 84 91 00 00 00    	je     10bd80 <cv_wait+0xe0>
	cv->waiting_threads[cv->write_idx] = id;
  10bcef:	8b 4e 04             	mov    0x4(%esi),%ecx
	cv->size++;
  10bcf2:	83 c2 01             	add    $0x1,%edx
	cv->waiting_threads[cv->write_idx] = id;
  10bcf5:	89 44 8e 0c          	mov    %eax,0xc(%esi,%ecx,4)
	cv->write_idx++;
  10bcf9:	8d 41 01             	lea    0x1(%ecx),%eax
	cv->write_idx %= NUM_IDS; 
  10bcfc:	89 c1                	mov    %eax,%ecx
	cv->size++;
  10bcfe:	89 56 08             	mov    %edx,0x8(%esi)
	cv->write_idx %= NUM_IDS; 
  10bd01:	c1 f9 1f             	sar    $0x1f,%ecx
  10bd04:	c1 e9 1a             	shr    $0x1a,%ecx
  10bd07:	01 c8                	add    %ecx,%eax
  10bd09:	83 e0 3f             	and    $0x3f,%eax
  10bd0c:	29 c8                	sub    %ecx,%eax
  10bd0e:	89 46 04             	mov    %eax,0x4(%esi)
		return; 
	} else {
		cv_insert_into_queue(cv, cur_pid); 
	}
	
	intr_local_disable();
  10bd11:	e8 ca 5c ff ff       	call   1019e0 <intr_local_disable>
	KERN_DEBUG("Process: %d, WAIT - CALLING thread_suspend\n", get_curid());
  10bd16:	e8 05 bd ff ff       	call   107a20 <get_curid>
  10bd1b:	50                   	push   %eax
  10bd1c:	8d 83 54 75 ff ff    	lea    -0x8aac(%ebx),%eax
  10bd22:	50                   	push   %eax
  10bd23:	6a 43                	push   $0x43
  10bd25:	55                   	push   %ebp
  10bd26:	e8 65 8a ff ff       	call   104790 <debug_normal>
	intr_local_enable();
  10bd2b:	e8 90 5c ff ff       	call   1019c0 <intr_local_enable>

	// switch to the new thread and release lock
	intr_local_disable();
  10bd30:	e8 ab 5c ff ff       	call   1019e0 <intr_local_disable>
	thread_suspend(lock);
  10bd35:	89 3c 24             	mov    %edi,(%esp)
  10bd38:	e8 e3 c0 ff ff       	call   107e20 <thread_suspend>
	intr_local_enable(); 
  10bd3d:	e8 7e 5c ff ff       	call   1019c0 <intr_local_enable>

	// now back in this thread, reacquire lock
	spinlock_acquire(lock);
  10bd42:	89 3c 24             	mov    %edi,(%esp)
  10bd45:	e8 06 a2 ff ff       	call   105f50 <spinlock_acquire>
  10bd4a:	83 c4 10             	add    $0x10,%esp
}
  10bd4d:	83 c4 0c             	add    $0xc,%esp
  10bd50:	5b                   	pop    %ebx
  10bd51:	5e                   	pop    %esi
  10bd52:	5f                   	pop    %edi
  10bd53:	5d                   	pop    %ebp
  10bd54:	c3                   	ret
  10bd55:	8d 76 00             	lea    0x0(%esi),%esi
	KERN_ASSERT(spinlock_holding(lock));
  10bd58:	8d 83 23 6a ff ff    	lea    -0x95dd(%ebx),%eax
  10bd5e:	50                   	push   %eax
  10bd5f:	8d 83 b8 60 ff ff    	lea    -0x9f48(%ebx),%eax
  10bd65:	50                   	push   %eax
  10bd66:	6a 33                	push   $0x33
  10bd68:	55                   	push   %ebp
  10bd69:	e8 82 8a ff ff       	call   1047f0 <debug_panic>
  10bd6e:	83 c4 10             	add    $0x10,%esp
  10bd71:	e9 63 ff ff ff       	jmp    10bcd9 <cv_wait+0x39>
  10bd76:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10bd7d:	00 
  10bd7e:	66 90                	xchg   %ax,%ax
		KERN_PANIC("Waiting queue of cv variable is full!\n");
  10bd80:	83 ec 04             	sub    $0x4,%esp
  10bd83:	8d 83 2c 75 ff ff    	lea    -0x8ad4(%ebx),%eax
  10bd89:	50                   	push   %eax
  10bd8a:	6a 3b                	push   $0x3b
  10bd8c:	55                   	push   %ebp
  10bd8d:	e8 5e 8a ff ff       	call   1047f0 <debug_panic>
		spinlock_release(lock); 
  10bd92:	89 3c 24             	mov    %edi,(%esp)
  10bd95:	e8 36 a2 ff ff       	call   105fd0 <spinlock_release>
		return; 
  10bd9a:	83 c4 10             	add    $0x10,%esp
}
  10bd9d:	83 c4 0c             	add    $0xc,%esp
  10bda0:	5b                   	pop    %ebx
  10bda1:	5e                   	pop    %esi
  10bda2:	5f                   	pop    %edi
  10bda3:	5d                   	pop    %ebp
  10bda4:	c3                   	ret
  10bda5:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10bdac:	00 
  10bdad:	8d 76 00             	lea    0x0(%esi),%esi

0010bdb0 <cv_signal>:

/**
 * Wake up a waiter
*/
void cv_signal(cv_t *cv)
{
  10bdb0:	57                   	push   %edi
  10bdb1:	56                   	push   %esi
  10bdb2:	53                   	push   %ebx
  10bdb3:	8b 54 24 10          	mov    0x10(%esp),%edx
	return cv->size; 
  10bdb7:	e8 e6 45 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10bdbc:	81 c3 38 b2 00 00    	add    $0xb238,%ebx
  10bdc2:	8b 4a 08             	mov    0x8(%edx),%ecx
	if (cv_get_queue_size(cv) == 0) return; 
  10bdc5:	85 c9                	test   %ecx,%ecx
  10bdc7:	74 62                	je     10be2b <cv_signal+0x7b>
	int removed_id = cv->waiting_threads[cv->read_idx];
  10bdc9:	8b 02                	mov    (%edx),%eax
	cv->size--;
  10bdcb:	83 e9 01             	sub    $0x1,%ecx
	int removed_id = cv->waiting_threads[cv->read_idx];
  10bdce:	8b 74 82 0c          	mov    0xc(%edx,%eax,4),%esi
	cv->read_idx++;
  10bdd2:	83 c0 01             	add    $0x1,%eax
	cv->size--;
  10bdd5:	89 4a 08             	mov    %ecx,0x8(%edx)
	cv->read_idx %= NUM_IDS;
  10bdd8:	89 c7                	mov    %eax,%edi
  10bdda:	c1 ff 1f             	sar    $0x1f,%edi
  10bddd:	c1 ef 1a             	shr    $0x1a,%edi
  10bde0:	01 f8                	add    %edi,%eax
  10bde2:	83 e0 3f             	and    $0x3f,%eax
  10bde5:	29 f8                	sub    %edi,%eax
  10bde7:	89 02                	mov    %eax,(%edx)

	int removed_id = cv_remove_from_queue(cv); 

	intr_local_disable();
  10bde9:	e8 f2 5b ff ff       	call   1019e0 <intr_local_disable>
	KERN_DEBUG("Process: %d, SIGNAL - CALLING thread_wake on process %d\n", get_curid(), removed_id);
  10bdee:	e8 2d bc ff ff       	call   107a20 <get_curid>
  10bdf3:	83 ec 0c             	sub    $0xc,%esp
  10bdf6:	56                   	push   %esi
  10bdf7:	50                   	push   %eax
  10bdf8:	8d 83 80 75 ff ff    	lea    -0x8a80(%ebx),%eax
  10bdfe:	50                   	push   %eax
  10bdff:	8d 83 3a 6a ff ff    	lea    -0x95c6(%ebx),%eax
  10be05:	6a 59                	push   $0x59
  10be07:	50                   	push   %eax
  10be08:	e8 83 89 ff ff       	call   104790 <debug_normal>
	intr_local_enable();
  10be0d:	83 c4 20             	add    $0x20,%esp
  10be10:	e8 ab 5b ff ff       	call   1019c0 <intr_local_enable>

	intr_local_disable();
  10be15:	e8 c6 5b ff ff       	call   1019e0 <intr_local_disable>
	thread_wake(removed_id);
  10be1a:	83 ec 0c             	sub    $0xc,%esp
  10be1d:	56                   	push   %esi
  10be1e:	e8 cd c0 ff ff       	call   107ef0 <thread_wake>
	intr_local_enable();
  10be23:	e8 98 5b ff ff       	call   1019c0 <intr_local_enable>
  10be28:	83 c4 10             	add    $0x10,%esp
}
  10be2b:	5b                   	pop    %ebx
  10be2c:	5e                   	pop    %esi
  10be2d:	5f                   	pop    %edi
  10be2e:	c3                   	ret
  10be2f:	90                   	nop

0010be30 <cv_broadcast>:

/**
 * Wake up all waiters
*/
void cv_broadcast(cv_t *cv)
{
  10be30:	55                   	push   %ebp
  10be31:	57                   	push   %edi
  10be32:	56                   	push   %esi
  10be33:	53                   	push   %ebx
  10be34:	e8 69 45 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10be39:	81 c3 bb b1 00 00    	add    $0xb1bb,%ebx
  10be3f:	83 ec 1c             	sub    $0x1c,%esp
  10be42:	8b 6c 24 30          	mov    0x30(%esp),%ebp
	return cv->size; 
  10be46:	8b 55 08             	mov    0x8(%ebp),%edx
	int removed_id; 
	while (cv_get_queue_size(cv) != 0) {
  10be49:	85 d2                	test   %edx,%edx
  10be4b:	74 75                	je     10bec2 <cv_broadcast+0x92>
  10be4d:	8d 83 3a 6a ff ff    	lea    -0x95c6(%ebx),%eax
  10be53:	8d bb bc 75 ff ff    	lea    -0x8a44(%ebx),%edi
  10be59:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10be5d:	8d 76 00             	lea    0x0(%esi),%esi
	int removed_id = cv->waiting_threads[cv->read_idx];
  10be60:	8b 45 00             	mov    0x0(%ebp),%eax
	cv->size--;
  10be63:	83 ea 01             	sub    $0x1,%edx
	int removed_id = cv->waiting_threads[cv->read_idx];
  10be66:	8b 74 85 0c          	mov    0xc(%ebp,%eax,4),%esi
	cv->read_idx++;
  10be6a:	83 c0 01             	add    $0x1,%eax
	cv->size--;
  10be6d:	89 55 08             	mov    %edx,0x8(%ebp)
	cv->read_idx %= NUM_IDS;
  10be70:	89 c1                	mov    %eax,%ecx
  10be72:	c1 f9 1f             	sar    $0x1f,%ecx
  10be75:	c1 e9 1a             	shr    $0x1a,%ecx
  10be78:	01 c8                	add    %ecx,%eax
  10be7a:	83 e0 3f             	and    $0x3f,%eax
  10be7d:	29 c8                	sub    %ecx,%eax
  10be7f:	89 45 00             	mov    %eax,0x0(%ebp)

		removed_id = cv_remove_from_queue(cv); 
		
		intr_local_disable();
  10be82:	e8 59 5b ff ff       	call   1019e0 <intr_local_disable>
		KERN_DEBUG("Process: %d, BROADCAST - CALLING thread_wake on process %d\n", get_curid(), removed_id);
  10be87:	e8 94 bb ff ff       	call   107a20 <get_curid>
  10be8c:	83 ec 0c             	sub    $0xc,%esp
  10be8f:	56                   	push   %esi
  10be90:	50                   	push   %eax
  10be91:	57                   	push   %edi
  10be92:	6a 6c                	push   $0x6c
  10be94:	ff 74 24 28          	push   0x28(%esp)
  10be98:	e8 f3 88 ff ff       	call   104790 <debug_normal>
		intr_local_enable();
  10be9d:	83 c4 20             	add    $0x20,%esp
  10bea0:	e8 1b 5b ff ff       	call   1019c0 <intr_local_enable>

        intr_local_disable();
  10bea5:	e8 36 5b ff ff       	call   1019e0 <intr_local_disable>
		thread_wake(removed_id);	
  10beaa:	83 ec 0c             	sub    $0xc,%esp
  10bead:	56                   	push   %esi
  10beae:	e8 3d c0 ff ff       	call   107ef0 <thread_wake>
        intr_local_enable();
  10beb3:	e8 08 5b ff ff       	call   1019c0 <intr_local_enable>
	return cv->size; 
  10beb8:	8b 55 08             	mov    0x8(%ebp),%edx
	while (cv_get_queue_size(cv) != 0) {
  10bebb:	83 c4 10             	add    $0x10,%esp
  10bebe:	85 d2                	test   %edx,%edx
  10bec0:	75 9e                	jne    10be60 <cv_broadcast+0x30>
	}
  10bec2:	83 c4 1c             	add    $0x1c,%esp
  10bec5:	5b                   	pop    %ebx
  10bec6:	5e                   	pop    %esi
  10bec7:	5f                   	pop    %edi
  10bec8:	5d                   	pop    %ebp
  10bec9:	c3                   	ret
  10beca:	66 90                	xchg   %ax,%ax
  10becc:	66 90                	xchg   %ax,%ax
  10bece:	66 90                	xchg   %ax,%ax

0010bed0 <flock_init>:
#include "import.h"

/**
 * Initialize a flock.
*/
void flock_init(struct flock_t *flock) {
  10bed0:	56                   	push   %esi
    flock->num_sh_waiting = 0;
    flock->num_ex_waiting = 0;
    flock->num_sh_active = 0;

    flock->ex_active = FALSE;
  10bed1:	31 c0                	xor    %eax,%eax
void flock_init(struct flock_t *flock) {
  10bed3:	53                   	push   %ebx
  10bed4:	e8 c9 44 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10bed9:	81 c3 1b b1 00 00    	add    $0xb11b,%ebx
  10bedf:	83 ec 10             	sub    $0x10,%esp
  10bee2:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    flock->ex_active = FALSE;
  10bee6:	66 89 46 0c          	mov    %ax,0xc(%esi)
    flock->sh_active = FALSE;

    flock->state = INACTIVE;

    spinlock_init(&flock->lock);
  10beea:	8d 46 14             	lea    0x14(%esi),%eax
    flock->num_sh_waiting = 0;
  10beed:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    flock->num_ex_waiting = 0;
  10bef3:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    flock->num_sh_active = 0;
  10befa:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    flock->state = INACTIVE;
  10bf01:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
    spinlock_init(&flock->lock);
  10bf08:	50                   	push   %eax
  10bf09:	e8 b2 9f ff ff       	call   105ec0 <spinlock_init>
    cv_init(&flock->ex_flock);
  10bf0e:	8d 46 1c             	lea    0x1c(%esi),%eax
    cv_init(&flock->sh_flock);
  10bf11:	81 c6 28 01 00 00    	add    $0x128,%esi
    cv_init(&flock->ex_flock);
  10bf17:	89 04 24             	mov    %eax,(%esp)
  10bf1a:	e8 61 fd ff ff       	call   10bc80 <cv_init>
    cv_init(&flock->sh_flock);
  10bf1f:	89 34 24             	mov    %esi,(%esp)
  10bf22:	e8 59 fd ff ff       	call   10bc80 <cv_init>
}
  10bf27:	83 c4 14             	add    $0x14,%esp
  10bf2a:	5b                   	pop    %ebx
  10bf2b:	5e                   	pop    %esi
  10bf2c:	c3                   	ret
  10bf2d:	8d 76 00             	lea    0x0(%esi),%esi

0010bf30 <flock_acquire>:

int flock_acquire(struct flock_t *flock, int operation) {
  10bf30:	55                   	push   %ebp
  10bf31:	57                   	push   %edi
  10bf32:	56                   	push   %esi
  10bf33:	53                   	push   %ebx
  10bf34:	e8 69 44 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10bf39:	81 c3 bb b0 00 00    	add    $0xb0bb,%ebx
  10bf3f:	83 ec 18             	sub    $0x18,%esp
  10bf42:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  10bf46:	8b 6c 24 30          	mov    0x30(%esp),%ebp

    spinlock_acquire(&flock->lock);
  10bf4a:	8d 7e 14             	lea    0x14(%esi),%edi
  10bf4d:	57                   	push   %edi
  10bf4e:	e8 fd 9f ff ff       	call   105f50 <spinlock_acquire>

    if (operation & LOCK_EX) {
  10bf53:	83 c4 10             	add    $0x10,%esp
  10bf56:	f7 c5 02 00 00 00    	test   $0x2,%ebp
  10bf5c:	74 62                	je     10bfc0 <flock_acquire+0x90>

        if (flock->state == INACTIVE) {
  10bf5e:	8b 46 10             	mov    0x10(%esi),%eax
  10bf61:	85 c0                	test   %eax,%eax
  10bf63:	0f 84 17 01 00 00    	je     10c080 <flock_acquire+0x150>
            flock->state = EXCLUSIVE;
            flock->ex_active = TRUE;
            spinlock_release(&flock->lock); 
            return 0;
        } else if (operation & LOCK_NB) {
  10bf69:	83 e5 08             	and    $0x8,%ebp
  10bf6c:	0f 85 40 01 00 00    	jne    10c0b2 <flock_acquire+0x182>
            spinlock_release(&flock->lock);
            return EWOULDBLOCK;
        } else {
            flock->num_ex_waiting++;
  10bf72:	83 46 04 01          	addl   $0x1,0x4(%esi)
            while (flock->num_sh_active > 0 || flock->ex_active) {
                cv_wait(&flock->ex_flock, &flock->lock);
  10bf76:	8d 6e 1c             	lea    0x1c(%esi),%ebp
            while (flock->num_sh_active > 0 || flock->ex_active) {
  10bf79:	eb 12                	jmp    10bf8d <flock_acquire+0x5d>
  10bf7b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
                cv_wait(&flock->ex_flock, &flock->lock);
  10bf80:	83 ec 08             	sub    $0x8,%esp
  10bf83:	57                   	push   %edi
  10bf84:	55                   	push   %ebp
  10bf85:	e8 16 fd ff ff       	call   10bca0 <cv_wait>
  10bf8a:	83 c4 10             	add    $0x10,%esp
            while (flock->num_sh_active > 0 || flock->ex_active) {
  10bf8d:	8b 46 08             	mov    0x8(%esi),%eax
  10bf90:	85 c0                	test   %eax,%eax
  10bf92:	7f ec                	jg     10bf80 <flock_acquire+0x50>
  10bf94:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
  10bf98:	75 e6                	jne    10bf80 <flock_acquire+0x50>
            }
            flock->num_ex_waiting--;
            flock->ex_active = TRUE;
            flock->state = EXCLUSIVE;
            spinlock_release(&flock->lock);
  10bf9a:	83 ec 0c             	sub    $0xc,%esp
            flock->num_ex_waiting--;
  10bf9d:	83 6e 04 01          	subl   $0x1,0x4(%esi)
            flock->ex_active = TRUE;
  10bfa1:	c6 46 0c 01          	movb   $0x1,0xc(%esi)
            flock->state = EXCLUSIVE;
  10bfa5:	c7 46 10 02 00 00 00 	movl   $0x2,0x10(%esi)
            spinlock_release(&flock->lock);
  10bfac:	57                   	push   %edi
  10bfad:	e8 1e a0 ff ff       	call   105fd0 <spinlock_release>
            return 0; 
  10bfb2:	83 c4 10             	add    $0x10,%esp
            return 0;
  10bfb5:	31 c0                	xor    %eax,%eax
    }

    // none of the (required, i.e. shared or exlusive) operation bits were set
    spinlock_release(&flock->lock);
    return -1;
}
  10bfb7:	83 c4 0c             	add    $0xc,%esp
  10bfba:	5b                   	pop    %ebx
  10bfbb:	5e                   	pop    %esi
  10bfbc:	5f                   	pop    %edi
  10bfbd:	5d                   	pop    %ebp
  10bfbe:	c3                   	ret
  10bfbf:	90                   	nop
    } else if (operation & LOCK_SH) {
  10bfc0:	f7 c5 01 00 00 00    	test   $0x1,%ebp
  10bfc6:	0f 84 d0 00 00 00    	je     10c09c <flock_acquire+0x16c>
        if (flock->state == INACTIVE || flock->state == SHARED) {
  10bfcc:	83 7e 10 01          	cmpl   $0x1,0x10(%esi)
  10bfd0:	76 5e                	jbe    10c030 <flock_acquire+0x100>
            if (operation & LOCK_NB) {
  10bfd2:	83 e5 08             	and    $0x8,%ebp
  10bfd5:	0f 85 d7 00 00 00    	jne    10c0b2 <flock_acquire+0x182>
                flock->num_sh_waiting++;
  10bfdb:	83 06 01             	addl   $0x1,(%esi)
                    cv_wait(&flock->sh_flock, &flock->lock);
  10bfde:	8d ae 28 01 00 00    	lea    0x128(%esi),%ebp
                while (flock->num_ex_waiting > 0 || flock->ex_active) {
  10bfe4:	eb 17                	jmp    10bffd <flock_acquire+0xcd>
  10bfe6:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10bfed:	00 
  10bfee:	66 90                	xchg   %ax,%ax
                    cv_wait(&flock->sh_flock, &flock->lock);
  10bff0:	83 ec 08             	sub    $0x8,%esp
  10bff3:	57                   	push   %edi
  10bff4:	55                   	push   %ebp
  10bff5:	e8 a6 fc ff ff       	call   10bca0 <cv_wait>
  10bffa:	83 c4 10             	add    $0x10,%esp
                while (flock->num_ex_waiting > 0 || flock->ex_active) {
  10bffd:	8b 46 04             	mov    0x4(%esi),%eax
  10c000:	85 c0                	test   %eax,%eax
  10c002:	7f ec                	jg     10bff0 <flock_acquire+0xc0>
  10c004:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
  10c008:	75 e6                	jne    10bff0 <flock_acquire+0xc0>
                spinlock_release(&flock->lock);
  10c00a:	83 ec 0c             	sub    $0xc,%esp
                flock->num_sh_active++;
  10c00d:	83 46 08 01          	addl   $0x1,0x8(%esi)
                flock->num_sh_waiting--;
  10c011:	83 2e 01             	subl   $0x1,(%esi)
                flock->state = SHARED;
  10c014:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
                flock->sh_active = TRUE;
  10c01b:	c6 46 0d 01          	movb   $0x1,0xd(%esi)
                spinlock_release(&flock->lock);
  10c01f:	57                   	push   %edi
  10c020:	e8 ab 9f ff ff       	call   105fd0 <spinlock_release>
                return 0;
  10c025:	83 c4 10             	add    $0x10,%esp
  10c028:	eb 8b                	jmp    10bfb5 <flock_acquire+0x85>
  10c02a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            if (flock->num_ex_waiting > 0) {
  10c030:	8b 4e 04             	mov    0x4(%esi),%ecx
  10c033:	85 c9                	test   %ecx,%ecx
  10c035:	7e 28                	jle    10c05f <flock_acquire+0x12f>
                if (operation & LOCK_NB) {
  10c037:	83 e5 08             	and    $0x8,%ebp
  10c03a:	75 76                	jne    10c0b2 <flock_acquire+0x182>
                    flock->num_sh_waiting++;
  10c03c:	83 06 01             	addl   $0x1,(%esi)
                    while (flock->num_ex_waiting > 0) {
  10c03f:	8d ae 28 01 00 00    	lea    0x128(%esi),%ebp
  10c045:	8d 76 00             	lea    0x0(%esi),%esi
                        cv_wait(&flock->sh_flock, &flock->lock);
  10c048:	83 ec 08             	sub    $0x8,%esp
  10c04b:	57                   	push   %edi
  10c04c:	55                   	push   %ebp
  10c04d:	e8 4e fc ff ff       	call   10bca0 <cv_wait>
                    while (flock->num_ex_waiting > 0) {
  10c052:	8b 56 04             	mov    0x4(%esi),%edx
  10c055:	83 c4 10             	add    $0x10,%esp
  10c058:	85 d2                	test   %edx,%edx
  10c05a:	7f ec                	jg     10c048 <flock_acquire+0x118>
                    flock->num_sh_waiting--;
  10c05c:	83 2e 01             	subl   $0x1,(%esi)
            spinlock_release(&flock->lock);
  10c05f:	83 ec 0c             	sub    $0xc,%esp
            flock->num_sh_active++;
  10c062:	83 46 08 01          	addl   $0x1,0x8(%esi)
            flock->state = SHARED;
  10c066:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
            flock->sh_active = TRUE;
  10c06d:	c6 46 0d 01          	movb   $0x1,0xd(%esi)
            spinlock_release(&flock->lock);
  10c071:	57                   	push   %edi
  10c072:	e8 59 9f ff ff       	call   105fd0 <spinlock_release>
            return 0;
  10c077:	83 c4 10             	add    $0x10,%esp
  10c07a:	e9 36 ff ff ff       	jmp    10bfb5 <flock_acquire+0x85>
  10c07f:	90                   	nop
            spinlock_release(&flock->lock); 
  10c080:	83 ec 0c             	sub    $0xc,%esp
            flock->state = EXCLUSIVE;
  10c083:	c7 46 10 02 00 00 00 	movl   $0x2,0x10(%esi)
            flock->ex_active = TRUE;
  10c08a:	c6 46 0c 01          	movb   $0x1,0xc(%esi)
            spinlock_release(&flock->lock); 
  10c08e:	57                   	push   %edi
  10c08f:	e8 3c 9f ff ff       	call   105fd0 <spinlock_release>
            return 0;
  10c094:	83 c4 10             	add    $0x10,%esp
  10c097:	e9 19 ff ff ff       	jmp    10bfb5 <flock_acquire+0x85>
    spinlock_release(&flock->lock);
  10c09c:	83 ec 0c             	sub    $0xc,%esp
  10c09f:	57                   	push   %edi
  10c0a0:	e8 2b 9f ff ff       	call   105fd0 <spinlock_release>
    return -1;
  10c0a5:	83 c4 10             	add    $0x10,%esp
  10c0a8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  10c0ad:	e9 05 ff ff ff       	jmp    10bfb7 <flock_acquire+0x87>
                    spinlock_release(&flock->lock);
  10c0b2:	83 ec 0c             	sub    $0xc,%esp
  10c0b5:	57                   	push   %edi
  10c0b6:	e8 15 9f ff ff       	call   105fd0 <spinlock_release>
                    return EWOULDBLOCK; 
  10c0bb:	83 c4 10             	add    $0x10,%esp
            return EWOULDBLOCK;
  10c0be:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  10c0c3:	e9 ef fe ff ff       	jmp    10bfb7 <flock_acquire+0x87>
  10c0c8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10c0cf:	00 

0010c0d0 <flock_release>:

int flock_release(struct flock_t *flock) {
  10c0d0:	57                   	push   %edi
  10c0d1:	56                   	push   %esi
  10c0d2:	53                   	push   %ebx
  10c0d3:	8b 74 24 10          	mov    0x10(%esp),%esi
  10c0d7:	e8 c6 42 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10c0dc:	81 c3 18 af 00 00    	add    $0xaf18,%ebx

    spinlock_acquire(&flock->lock);
  10c0e2:	8d 7e 14             	lea    0x14(%esi),%edi
  10c0e5:	83 ec 0c             	sub    $0xc,%esp
  10c0e8:	57                   	push   %edi
  10c0e9:	e8 62 9e ff ff       	call   105f50 <spinlock_acquire>

    if (flock->state == INACTIVE) {
  10c0ee:	8b 46 10             	mov    0x10(%esi),%eax
  10c0f1:	83 c4 10             	add    $0x10,%esp
  10c0f4:	85 c0                	test   %eax,%eax
  10c0f6:	0f 84 91 00 00 00    	je     10c18d <flock_release+0xbd>
        spinlock_release(&flock->lock);
        return -1;
    }

    if (flock->state == EXCLUSIVE) {
  10c0fc:	83 f8 02             	cmp    $0x2,%eax
  10c0ff:	74 57                	je     10c158 <flock_release+0x88>
            cv_signal(&flock->ex_flock);
        } else {
            cv_broadcast(&flock->sh_flock);
        }

    } else if (flock->state == SHARED) {
  10c101:	83 f8 01             	cmp    $0x1,%eax
  10c104:	74 1a                	je     10c120 <flock_release+0x50>
            cv_broadcast(&flock->sh_flock);
        }

    }

    spinlock_release(&flock->lock);
  10c106:	83 ec 0c             	sub    $0xc,%esp
  10c109:	57                   	push   %edi
  10c10a:	e8 c1 9e ff ff       	call   105fd0 <spinlock_release>
    return 0;
  10c10f:	83 c4 10             	add    $0x10,%esp
  10c112:	31 c0                	xor    %eax,%eax
  10c114:	5b                   	pop    %ebx
  10c115:	5e                   	pop    %esi
  10c116:	5f                   	pop    %edi
  10c117:	c3                   	ret
  10c118:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10c11f:	00 
        flock->num_sh_active--;
  10c120:	8b 46 08             	mov    0x8(%esi),%eax
        if (flock->num_ex_waiting > 0) {
  10c123:	8b 56 04             	mov    0x4(%esi),%edx
        flock->num_sh_active--;
  10c126:	83 e8 01             	sub    $0x1,%eax
  10c129:	89 46 08             	mov    %eax,0x8(%esi)
        if (flock->num_ex_waiting > 0) {
  10c12c:	85 d2                	test   %edx,%edx
  10c12e:	7e 50                	jle    10c180 <flock_release+0xb0>
            if (flock->num_sh_active == 0) {
  10c130:	85 c0                	test   %eax,%eax
  10c132:	75 d2                	jne    10c106 <flock_release+0x36>
                flock->state = INACTIVE;
  10c134:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  10c13b:	2e 8d 74 26 00       	lea    %cs:0x0(%esi,%eiz,1),%esi
                cv_signal(&flock->ex_flock);
  10c140:	83 ec 0c             	sub    $0xc,%esp
  10c143:	83 c6 1c             	add    $0x1c,%esi
  10c146:	56                   	push   %esi
  10c147:	e8 64 fc ff ff       	call   10bdb0 <cv_signal>
  10c14c:	83 c4 10             	add    $0x10,%esp
  10c14f:	eb b5                	jmp    10c106 <flock_release+0x36>
  10c151:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        if (flock->num_ex_waiting > 0) {
  10c158:	8b 4e 04             	mov    0x4(%esi),%ecx
        flock->ex_active = FALSE;
  10c15b:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
        flock->state = INACTIVE;
  10c15f:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
        if (flock->num_ex_waiting > 0) {
  10c166:	85 c9                	test   %ecx,%ecx
  10c168:	7f d6                	jg     10c140 <flock_release+0x70>
            cv_broadcast(&flock->sh_flock);
  10c16a:	83 ec 0c             	sub    $0xc,%esp
  10c16d:	81 c6 28 01 00 00    	add    $0x128,%esi
  10c173:	56                   	push   %esi
  10c174:	e8 b7 fc ff ff       	call   10be30 <cv_broadcast>
  10c179:	83 c4 10             	add    $0x10,%esp
  10c17c:	eb 88                	jmp    10c106 <flock_release+0x36>
  10c17e:	66 90                	xchg   %ax,%ax
            if (flock->num_sh_active == 0) {
  10c180:	85 c0                	test   %eax,%eax
  10c182:	75 e6                	jne    10c16a <flock_release+0x9a>
                flock->state = INACTIVE;
  10c184:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  10c18b:	eb dd                	jmp    10c16a <flock_release+0x9a>
        spinlock_release(&flock->lock);
  10c18d:	83 ec 0c             	sub    $0xc,%esp
  10c190:	57                   	push   %edi
  10c191:	e8 3a 9e ff ff       	call   105fd0 <spinlock_release>
        return -1;
  10c196:	83 c4 10             	add    $0x10,%esp
  10c199:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  10c19e:	e9 71 ff ff ff       	jmp    10c114 <flock_release+0x44>
  10c1a3:	66 90                	xchg   %ax,%ax
  10c1a5:	66 90                	xchg   %ax,%ax
  10c1a7:	66 90                	xchg   %ax,%ax
  10c1a9:	66 90                	xchg   %ax,%ax
  10c1ab:	66 90                	xchg   %ax,%ax
  10c1ad:	66 90                	xchg   %ax,%ax
  10c1af:	90                   	nop

0010c1b0 <bbuffer_init>:
/**
 * Initialize the bounded buffer.
 * Only called once (during boot)
*/
void bbuffer_init(void)
{
  10c1b0:	56                   	push   %esi
  10c1b1:	53                   	push   %ebx
  10c1b2:	e8 eb 41 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10c1b7:	81 c3 3d ae 00 00    	add    $0xae3d,%ebx
  10c1bd:	83 ec 10             	sub    $0x10,%esp
	global_buffer.read_idx = 0;
  10c1c0:	c7 83 8c 56 d6 00 00 	movl   $0x0,0xd6568c(%ebx)
  10c1c7:	00 00 00 
	global_buffer.write_idx = 0;
	spinlock_init(&global_buffer.lock);
  10c1ca:	8d b3 94 56 d6 00    	lea    0xd65694(%ebx),%esi
  10c1d0:	56                   	push   %esi
	global_buffer.write_idx = 0;
  10c1d1:	c7 83 90 56 d6 00 00 	movl   $0x0,0xd65690(%ebx)
  10c1d8:	00 00 00 
	spinlock_init(&global_buffer.lock);
  10c1db:	e8 e0 9c ff ff       	call   105ec0 <spinlock_init>

	global_buffer.size = 0;
	cv_init(&global_buffer.bufferIsEmpty);
  10c1e0:	8d 46 08             	lea    0x8(%esi),%eax
	global_buffer.size = 0;
  10c1e3:	c7 83 b4 58 d6 00 00 	movl   $0x0,0xd658b4(%ebx)
  10c1ea:	00 00 00 
	cv_init(&global_buffer.bufferIsEmpty);
  10c1ed:	89 04 24             	mov    %eax,(%esp)
  10c1f0:	e8 8b fa ff ff       	call   10bc80 <cv_init>
	cv_init(&global_buffer.bufferIsFull); 
  10c1f5:	8d 86 14 01 00 00    	lea    0x114(%esi),%eax
  10c1fb:	89 04 24             	mov    %eax,(%esp)
  10c1fe:	e8 7d fa ff ff       	call   10bc80 <cv_init>
}
  10c203:	83 c4 14             	add    $0x14,%esp
  10c206:	5b                   	pop    %ebx
  10c207:	5e                   	pop    %esi
  10c208:	c3                   	ret
  10c209:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0010c210 <bbuffer_insert_item>:
/**
 * Adds item to the buffer; waits until the buffer is 
 * not full to add the item 
*/
void bbuffer_insert_item(int item)
{
  10c210:	55                   	push   %ebp
  10c211:	57                   	push   %edi
  10c212:	8d 3d 8c 56 d6 00    	lea    0xd6568c,%edi
  10c218:	56                   	push   %esi
  10c219:	53                   	push   %ebx
  10c21a:	e8 83 41 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10c21f:	81 c3 d5 ad 00 00    	add    $0xadd5,%ebx
  10c225:	83 ec 18             	sub    $0x18,%esp
	spinlock_acquire(&global_buffer.lock);
  10c228:	8d b3 94 56 d6 00    	lea    0xd65694(%ebx),%esi
  10c22e:	56                   	push   %esi
  10c22f:	e8 1c 9d ff ff       	call   105f50 <spinlock_acquire>
	return global_buffer.size; 
  10c234:	8b 8b b4 58 d6 00    	mov    0xd658b4(%ebx),%ecx

	while (get_buffer_size() >= CAPACITY) {
  10c23a:	83 c4 10             	add    $0x10,%esp
  10c23d:	83 f9 04             	cmp    $0x4,%ecx
  10c240:	7e 27                	jle    10c269 <bbuffer_insert_item+0x59>
		cv_wait(&global_buffer.bufferIsFull, &global_buffer.lock);
  10c242:	8d ae 14 01 00 00    	lea    0x114(%esi),%ebp
  10c248:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10c24f:	00 
  10c250:	83 ec 08             	sub    $0x8,%esp
  10c253:	56                   	push   %esi
  10c254:	55                   	push   %ebp
  10c255:	e8 46 fa ff ff       	call   10bca0 <cv_wait>
	return global_buffer.size; 
  10c25a:	8b 8c 1f 28 02 00 00 	mov    0x228(%edi,%ebx,1),%ecx
	while (get_buffer_size() >= CAPACITY) {
  10c261:	83 c4 10             	add    $0x10,%esp
  10c264:	83 f9 04             	cmp    $0x4,%ecx
  10c267:	7f e7                	jg     10c250 <bbuffer_insert_item+0x40>
	global_buffer.buffer[global_buffer.write_idx] = item;
  10c269:	8b b3 90 56 d6 00    	mov    0xd65690(%ebx),%esi
  10c26f:	8b 54 24 20          	mov    0x20(%esp),%edx
	// intr_local_disable();
	// KERN_DEBUG("CPU: %d, Process: %d, DONE inserting item %d into buffer\n", get_pcpu_idx(), get_curid(), item);
	// KERN_DEBUG("global_buffer.size = %d\n", global_buffer.size);
	// intr_local_enable();

	cv_signal(&global_buffer.bufferIsEmpty); 
  10c273:	83 ec 0c             	sub    $0xc,%esp
	global_buffer.size++; 
  10c276:	83 c1 01             	add    $0x1,%ecx
  10c279:	89 8b b4 58 d6 00    	mov    %ecx,0xd658b4(%ebx)
	global_buffer.buffer[global_buffer.write_idx] = item;
  10c27f:	8d 84 b3 20 02 00 00 	lea    0x220(%ebx,%esi,4),%eax
	global_buffer.write_idx++;
  10c286:	83 c6 01             	add    $0x1,%esi
	global_buffer.buffer[global_buffer.write_idx] = item;
  10c289:	89 54 07 0c          	mov    %edx,0xc(%edi,%eax,1)
	global_buffer.write_idx %= CAPACITY; 
  10c28d:	b8 cd cc cc cc       	mov    $0xcccccccd,%eax
  10c292:	f7 e6                	mul    %esi
  10c294:	89 d0                	mov    %edx,%eax
  10c296:	83 e2 fc             	and    $0xfffffffc,%edx
  10c299:	c1 e8 02             	shr    $0x2,%eax
  10c29c:	01 c2                	add    %eax,%edx
  10c29e:	29 d6                	sub    %edx,%esi
  10c2a0:	89 b3 90 56 d6 00    	mov    %esi,0xd65690(%ebx)
	cv_signal(&global_buffer.bufferIsEmpty); 
  10c2a6:	8d b3 9c 56 d6 00    	lea    0xd6569c(%ebx),%esi
  10c2ac:	56                   	push   %esi
  10c2ad:	e8 fe fa ff ff       	call   10bdb0 <cv_signal>
	spinlock_release(&global_buffer.lock); 
  10c2b2:	8d 46 f8             	lea    -0x8(%esi),%eax
  10c2b5:	89 04 24             	mov    %eax,(%esp)
  10c2b8:	e8 13 9d ff ff       	call   105fd0 <spinlock_release>
}
  10c2bd:	83 c4 1c             	add    $0x1c,%esp
  10c2c0:	5b                   	pop    %ebx
  10c2c1:	5e                   	pop    %esi
  10c2c2:	5f                   	pop    %edi
  10c2c3:	5d                   	pop    %ebp
  10c2c4:	c3                   	ret
  10c2c5:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10c2cc:	00 
  10c2cd:	8d 76 00             	lea    0x0(%esi),%esi

0010c2d0 <bbuffer_remove_item>:
/**
 * Removes an item from the buffer; waits until the buffer
 * has at least one item before removing it
*/
int bbuffer_remove_item(void)
{
  10c2d0:	55                   	push   %ebp
  10c2d1:	57                   	push   %edi
  10c2d2:	8d 3d 8c 56 d6 00    	lea    0xd6568c,%edi
  10c2d8:	56                   	push   %esi
  10c2d9:	53                   	push   %ebx
  10c2da:	e8 c3 40 ff ff       	call   1003a2 <__x86.get_pc_thunk.bx>
  10c2df:	81 c3 15 ad 00 00    	add    $0xad15,%ebx
  10c2e5:	83 ec 18             	sub    $0x18,%esp
	int item;

	spinlock_acquire(&global_buffer.lock);
  10c2e8:	8d b3 94 56 d6 00    	lea    0xd65694(%ebx),%esi
  10c2ee:	56                   	push   %esi
  10c2ef:	e8 5c 9c ff ff       	call   105f50 <spinlock_acquire>
	return global_buffer.size; 
  10c2f4:	8b 8b b4 58 d6 00    	mov    0xd658b4(%ebx),%ecx
	
	while (get_buffer_size() == 0) {
  10c2fa:	83 c4 10             	add    $0x10,%esp
  10c2fd:	85 c9                	test   %ecx,%ecx
  10c2ff:	75 1f                	jne    10c320 <bbuffer_remove_item+0x50>
		cv_wait(&global_buffer.bufferIsEmpty, &global_buffer.lock);
  10c301:	8d 6e 08             	lea    0x8(%esi),%ebp
  10c304:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  10c308:	83 ec 08             	sub    $0x8,%esp
  10c30b:	56                   	push   %esi
  10c30c:	55                   	push   %ebp
  10c30d:	e8 8e f9 ff ff       	call   10bca0 <cv_wait>
	return global_buffer.size; 
  10c312:	8b 8c 1f 28 02 00 00 	mov    0x228(%edi,%ebx,1),%ecx
	while (get_buffer_size() == 0) {
  10c319:	83 c4 10             	add    $0x10,%esp
  10c31c:	85 c9                	test   %ecx,%ecx
  10c31e:	74 e8                	je     10c308 <bbuffer_remove_item+0x38>
	int removed_item = global_buffer.buffer[global_buffer.read_idx];
  10c320:	8b 83 8c 56 d6 00    	mov    0xd6568c(%ebx),%eax
	// intr_local_disable();
	// KERN_DEBUG("CPU: %d, Process: %d, DONE Removing item %d from buffer\n", get_pcpu_idx(), get_curid(), item);
	// KERN_DEBUG("global_buffer.size = %d\n", get_buffer_size());
	// intr_local_enable(); 

	cv_signal(&global_buffer.bufferIsFull); 
  10c326:	83 ec 0c             	sub    $0xc,%esp
	global_buffer.size--; 
  10c329:	83 e9 01             	sub    $0x1,%ecx
  10c32c:	89 8b b4 58 d6 00    	mov    %ecx,0xd658b4(%ebx)
	int removed_item = global_buffer.buffer[global_buffer.read_idx];
  10c332:	8d 94 83 20 02 00 00 	lea    0x220(%ebx,%eax,4),%edx
  10c339:	8b 74 17 0c          	mov    0xc(%edi,%edx,1),%esi
	global_buffer.read_idx++;
  10c33d:	8d 78 01             	lea    0x1(%eax),%edi
	global_buffer.read_idx %= CAPACITY;
  10c340:	b8 cd cc cc cc       	mov    $0xcccccccd,%eax
  10c345:	f7 e7                	mul    %edi
  10c347:	89 d0                	mov    %edx,%eax
  10c349:	83 e2 fc             	and    $0xfffffffc,%edx
  10c34c:	c1 e8 02             	shr    $0x2,%eax
  10c34f:	01 c2                	add    %eax,%edx
  10c351:	29 d7                	sub    %edx,%edi
  10c353:	89 bb 8c 56 d6 00    	mov    %edi,0xd6568c(%ebx)
	cv_signal(&global_buffer.bufferIsFull); 
  10c359:	8d bb a8 57 d6 00    	lea    0xd657a8(%ebx),%edi
  10c35f:	57                   	push   %edi
  10c360:	e8 4b fa ff ff       	call   10bdb0 <cv_signal>
	spinlock_release(&global_buffer.lock);
  10c365:	8d 87 ec fe ff ff    	lea    -0x114(%edi),%eax
  10c36b:	89 04 24             	mov    %eax,(%esp)
  10c36e:	e8 5d 9c ff ff       	call   105fd0 <spinlock_release>
	return item; 
  10c373:	83 c4 1c             	add    $0x1c,%esp
  10c376:	89 f0                	mov    %esi,%eax
  10c378:	5b                   	pop    %ebx
  10c379:	5e                   	pop    %esi
  10c37a:	5f                   	pop    %edi
  10c37b:	5d                   	pop    %ebp
  10c37c:	c3                   	ret
  10c37d:	66 90                	xchg   %ax,%ax
  10c37f:	90                   	nop

0010c380 <__udivdi3>:
  10c380:	f3 0f 1e fb          	endbr32
  10c384:	55                   	push   %ebp
  10c385:	57                   	push   %edi
  10c386:	56                   	push   %esi
  10c387:	53                   	push   %ebx
  10c388:	83 ec 1c             	sub    $0x1c,%esp
  10c38b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  10c38f:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  10c393:	8b 74 24 34          	mov    0x34(%esp),%esi
  10c397:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  10c39b:	85 c0                	test   %eax,%eax
  10c39d:	75 19                	jne    10c3b8 <__udivdi3+0x38>
  10c39f:	39 de                	cmp    %ebx,%esi
  10c3a1:	73 4d                	jae    10c3f0 <__udivdi3+0x70>
  10c3a3:	31 ff                	xor    %edi,%edi
  10c3a5:	89 e8                	mov    %ebp,%eax
  10c3a7:	89 f2                	mov    %esi,%edx
  10c3a9:	f7 f3                	div    %ebx
  10c3ab:	89 fa                	mov    %edi,%edx
  10c3ad:	83 c4 1c             	add    $0x1c,%esp
  10c3b0:	5b                   	pop    %ebx
  10c3b1:	5e                   	pop    %esi
  10c3b2:	5f                   	pop    %edi
  10c3b3:	5d                   	pop    %ebp
  10c3b4:	c3                   	ret
  10c3b5:	8d 76 00             	lea    0x0(%esi),%esi
  10c3b8:	39 c6                	cmp    %eax,%esi
  10c3ba:	73 14                	jae    10c3d0 <__udivdi3+0x50>
  10c3bc:	31 ff                	xor    %edi,%edi
  10c3be:	31 c0                	xor    %eax,%eax
  10c3c0:	89 fa                	mov    %edi,%edx
  10c3c2:	83 c4 1c             	add    $0x1c,%esp
  10c3c5:	5b                   	pop    %ebx
  10c3c6:	5e                   	pop    %esi
  10c3c7:	5f                   	pop    %edi
  10c3c8:	5d                   	pop    %ebp
  10c3c9:	c3                   	ret
  10c3ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10c3d0:	0f bd f8             	bsr    %eax,%edi
  10c3d3:	83 f7 1f             	xor    $0x1f,%edi
  10c3d6:	75 48                	jne    10c420 <__udivdi3+0xa0>
  10c3d8:	39 f0                	cmp    %esi,%eax
  10c3da:	72 06                	jb     10c3e2 <__udivdi3+0x62>
  10c3dc:	31 c0                	xor    %eax,%eax
  10c3de:	39 dd                	cmp    %ebx,%ebp
  10c3e0:	72 de                	jb     10c3c0 <__udivdi3+0x40>
  10c3e2:	b8 01 00 00 00       	mov    $0x1,%eax
  10c3e7:	eb d7                	jmp    10c3c0 <__udivdi3+0x40>
  10c3e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  10c3f0:	89 d9                	mov    %ebx,%ecx
  10c3f2:	85 db                	test   %ebx,%ebx
  10c3f4:	75 0b                	jne    10c401 <__udivdi3+0x81>
  10c3f6:	b8 01 00 00 00       	mov    $0x1,%eax
  10c3fb:	31 d2                	xor    %edx,%edx
  10c3fd:	f7 f3                	div    %ebx
  10c3ff:	89 c1                	mov    %eax,%ecx
  10c401:	31 d2                	xor    %edx,%edx
  10c403:	89 f0                	mov    %esi,%eax
  10c405:	f7 f1                	div    %ecx
  10c407:	89 c6                	mov    %eax,%esi
  10c409:	89 e8                	mov    %ebp,%eax
  10c40b:	89 f7                	mov    %esi,%edi
  10c40d:	f7 f1                	div    %ecx
  10c40f:	89 fa                	mov    %edi,%edx
  10c411:	83 c4 1c             	add    $0x1c,%esp
  10c414:	5b                   	pop    %ebx
  10c415:	5e                   	pop    %esi
  10c416:	5f                   	pop    %edi
  10c417:	5d                   	pop    %ebp
  10c418:	c3                   	ret
  10c419:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  10c420:	89 f9                	mov    %edi,%ecx
  10c422:	ba 20 00 00 00       	mov    $0x20,%edx
  10c427:	29 fa                	sub    %edi,%edx
  10c429:	d3 e0                	shl    %cl,%eax
  10c42b:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c42f:	89 d1                	mov    %edx,%ecx
  10c431:	89 d8                	mov    %ebx,%eax
  10c433:	d3 e8                	shr    %cl,%eax
  10c435:	89 c1                	mov    %eax,%ecx
  10c437:	8b 44 24 08          	mov    0x8(%esp),%eax
  10c43b:	09 c1                	or     %eax,%ecx
  10c43d:	89 f0                	mov    %esi,%eax
  10c43f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10c443:	89 f9                	mov    %edi,%ecx
  10c445:	d3 e3                	shl    %cl,%ebx
  10c447:	89 d1                	mov    %edx,%ecx
  10c449:	d3 e8                	shr    %cl,%eax
  10c44b:	89 f9                	mov    %edi,%ecx
  10c44d:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  10c451:	89 eb                	mov    %ebp,%ebx
  10c453:	d3 e6                	shl    %cl,%esi
  10c455:	89 d1                	mov    %edx,%ecx
  10c457:	d3 eb                	shr    %cl,%ebx
  10c459:	09 f3                	or     %esi,%ebx
  10c45b:	89 c6                	mov    %eax,%esi
  10c45d:	89 f2                	mov    %esi,%edx
  10c45f:	89 d8                	mov    %ebx,%eax
  10c461:	f7 74 24 08          	divl   0x8(%esp)
  10c465:	89 d6                	mov    %edx,%esi
  10c467:	89 c3                	mov    %eax,%ebx
  10c469:	f7 64 24 0c          	mull   0xc(%esp)
  10c46d:	39 d6                	cmp    %edx,%esi
  10c46f:	72 1f                	jb     10c490 <__udivdi3+0x110>
  10c471:	89 f9                	mov    %edi,%ecx
  10c473:	d3 e5                	shl    %cl,%ebp
  10c475:	39 c5                	cmp    %eax,%ebp
  10c477:	73 04                	jae    10c47d <__udivdi3+0xfd>
  10c479:	39 d6                	cmp    %edx,%esi
  10c47b:	74 13                	je     10c490 <__udivdi3+0x110>
  10c47d:	89 d8                	mov    %ebx,%eax
  10c47f:	31 ff                	xor    %edi,%edi
  10c481:	e9 3a ff ff ff       	jmp    10c3c0 <__udivdi3+0x40>
  10c486:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10c48d:	00 
  10c48e:	66 90                	xchg   %ax,%ax
  10c490:	8d 43 ff             	lea    -0x1(%ebx),%eax
  10c493:	31 ff                	xor    %edi,%edi
  10c495:	e9 26 ff ff ff       	jmp    10c3c0 <__udivdi3+0x40>
  10c49a:	66 90                	xchg   %ax,%ax
  10c49c:	66 90                	xchg   %ax,%ax
  10c49e:	66 90                	xchg   %ax,%ax

0010c4a0 <__umoddi3>:
  10c4a0:	f3 0f 1e fb          	endbr32
  10c4a4:	55                   	push   %ebp
  10c4a5:	57                   	push   %edi
  10c4a6:	56                   	push   %esi
  10c4a7:	53                   	push   %ebx
  10c4a8:	83 ec 1c             	sub    $0x1c,%esp
  10c4ab:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  10c4af:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  10c4b3:	8b 74 24 30          	mov    0x30(%esp),%esi
  10c4b7:	8b 7c 24 38          	mov    0x38(%esp),%edi
  10c4bb:	89 da                	mov    %ebx,%edx
  10c4bd:	85 c0                	test   %eax,%eax
  10c4bf:	75 17                	jne    10c4d8 <__umoddi3+0x38>
  10c4c1:	39 fb                	cmp    %edi,%ebx
  10c4c3:	73 53                	jae    10c518 <__umoddi3+0x78>
  10c4c5:	89 f0                	mov    %esi,%eax
  10c4c7:	f7 f7                	div    %edi
  10c4c9:	89 d0                	mov    %edx,%eax
  10c4cb:	31 d2                	xor    %edx,%edx
  10c4cd:	83 c4 1c             	add    $0x1c,%esp
  10c4d0:	5b                   	pop    %ebx
  10c4d1:	5e                   	pop    %esi
  10c4d2:	5f                   	pop    %edi
  10c4d3:	5d                   	pop    %ebp
  10c4d4:	c3                   	ret
  10c4d5:	8d 76 00             	lea    0x0(%esi),%esi
  10c4d8:	89 f1                	mov    %esi,%ecx
  10c4da:	39 c3                	cmp    %eax,%ebx
  10c4dc:	73 12                	jae    10c4f0 <__umoddi3+0x50>
  10c4de:	89 f0                	mov    %esi,%eax
  10c4e0:	83 c4 1c             	add    $0x1c,%esp
  10c4e3:	5b                   	pop    %ebx
  10c4e4:	5e                   	pop    %esi
  10c4e5:	5f                   	pop    %edi
  10c4e6:	5d                   	pop    %ebp
  10c4e7:	c3                   	ret
  10c4e8:	2e 8d b4 26 00 00 00 	lea    %cs:0x0(%esi,%eiz,1),%esi
  10c4ef:	00 
  10c4f0:	0f bd e8             	bsr    %eax,%ebp
  10c4f3:	83 f5 1f             	xor    $0x1f,%ebp
  10c4f6:	75 48                	jne    10c540 <__umoddi3+0xa0>
  10c4f8:	39 d8                	cmp    %ebx,%eax
  10c4fa:	0f 82 d0 00 00 00    	jb     10c5d0 <__umoddi3+0x130>
  10c500:	39 fe                	cmp    %edi,%esi
  10c502:	0f 83 c8 00 00 00    	jae    10c5d0 <__umoddi3+0x130>
  10c508:	89 c8                	mov    %ecx,%eax
  10c50a:	83 c4 1c             	add    $0x1c,%esp
  10c50d:	5b                   	pop    %ebx
  10c50e:	5e                   	pop    %esi
  10c50f:	5f                   	pop    %edi
  10c510:	5d                   	pop    %ebp
  10c511:	c3                   	ret
  10c512:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10c518:	89 f9                	mov    %edi,%ecx
  10c51a:	85 ff                	test   %edi,%edi
  10c51c:	75 0b                	jne    10c529 <__umoddi3+0x89>
  10c51e:	b8 01 00 00 00       	mov    $0x1,%eax
  10c523:	31 d2                	xor    %edx,%edx
  10c525:	f7 f7                	div    %edi
  10c527:	89 c1                	mov    %eax,%ecx
  10c529:	89 d8                	mov    %ebx,%eax
  10c52b:	31 d2                	xor    %edx,%edx
  10c52d:	f7 f1                	div    %ecx
  10c52f:	89 f0                	mov    %esi,%eax
  10c531:	f7 f1                	div    %ecx
  10c533:	89 d0                	mov    %edx,%eax
  10c535:	31 d2                	xor    %edx,%edx
  10c537:	eb 94                	jmp    10c4cd <__umoddi3+0x2d>
  10c539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  10c540:	89 e9                	mov    %ebp,%ecx
  10c542:	ba 20 00 00 00       	mov    $0x20,%edx
  10c547:	29 ea                	sub    %ebp,%edx
  10c549:	d3 e0                	shl    %cl,%eax
  10c54b:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c54f:	89 d1                	mov    %edx,%ecx
  10c551:	89 f8                	mov    %edi,%eax
  10c553:	d3 e8                	shr    %cl,%eax
  10c555:	89 54 24 04          	mov    %edx,0x4(%esp)
  10c559:	8b 54 24 04          	mov    0x4(%esp),%edx
  10c55d:	89 c1                	mov    %eax,%ecx
  10c55f:	8b 44 24 08          	mov    0x8(%esp),%eax
  10c563:	09 c1                	or     %eax,%ecx
  10c565:	89 d8                	mov    %ebx,%eax
  10c567:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10c56b:	89 e9                	mov    %ebp,%ecx
  10c56d:	d3 e7                	shl    %cl,%edi
  10c56f:	89 d1                	mov    %edx,%ecx
  10c571:	d3 e8                	shr    %cl,%eax
  10c573:	89 e9                	mov    %ebp,%ecx
  10c575:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  10c579:	d3 e3                	shl    %cl,%ebx
  10c57b:	89 c7                	mov    %eax,%edi
  10c57d:	89 d1                	mov    %edx,%ecx
  10c57f:	89 f0                	mov    %esi,%eax
  10c581:	d3 e8                	shr    %cl,%eax
  10c583:	89 fa                	mov    %edi,%edx
  10c585:	89 e9                	mov    %ebp,%ecx
  10c587:	09 d8                	or     %ebx,%eax
  10c589:	d3 e6                	shl    %cl,%esi
  10c58b:	f7 74 24 08          	divl   0x8(%esp)
  10c58f:	89 d3                	mov    %edx,%ebx
  10c591:	f7 64 24 0c          	mull   0xc(%esp)
  10c595:	89 c7                	mov    %eax,%edi
  10c597:	89 d1                	mov    %edx,%ecx
  10c599:	39 d3                	cmp    %edx,%ebx
  10c59b:	72 06                	jb     10c5a3 <__umoddi3+0x103>
  10c59d:	75 10                	jne    10c5af <__umoddi3+0x10f>
  10c59f:	39 c6                	cmp    %eax,%esi
  10c5a1:	73 0c                	jae    10c5af <__umoddi3+0x10f>
  10c5a3:	2b 44 24 0c          	sub    0xc(%esp),%eax
  10c5a7:	1b 54 24 08          	sbb    0x8(%esp),%edx
  10c5ab:	89 d1                	mov    %edx,%ecx
  10c5ad:	89 c7                	mov    %eax,%edi
  10c5af:	89 f2                	mov    %esi,%edx
  10c5b1:	29 fa                	sub    %edi,%edx
  10c5b3:	19 cb                	sbb    %ecx,%ebx
  10c5b5:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  10c5ba:	89 d8                	mov    %ebx,%eax
  10c5bc:	d3 e0                	shl    %cl,%eax
  10c5be:	89 e9                	mov    %ebp,%ecx
  10c5c0:	d3 ea                	shr    %cl,%edx
  10c5c2:	d3 eb                	shr    %cl,%ebx
  10c5c4:	09 d0                	or     %edx,%eax
  10c5c6:	89 da                	mov    %ebx,%edx
  10c5c8:	83 c4 1c             	add    $0x1c,%esp
  10c5cb:	5b                   	pop    %ebx
  10c5cc:	5e                   	pop    %esi
  10c5cd:	5f                   	pop    %edi
  10c5ce:	5d                   	pop    %ebp
  10c5cf:	c3                   	ret
  10c5d0:	89 da                	mov    %ebx,%edx
  10c5d2:	89 f1                	mov    %esi,%ecx
  10c5d4:	29 f9                	sub    %edi,%ecx
  10c5d6:	19 c2                	sbb    %eax,%edx
  10c5d8:	89 c8                	mov    %ecx,%eax
  10c5da:	e9 2b ff ff ff       	jmp    10c50a <__umoddi3+0x6a>
